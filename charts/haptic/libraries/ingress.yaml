# Ingress Template Library
#
# Provides Kubernetes networking.k8s.io/v1 Ingress support.
# Features: path matching (Exact, Prefix), TLS certificates, backend generation.

watchedResources:
  ingresses:
    apiVersion: networking.k8s.io/v1
    resources: ingresses
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true
    # fieldSelector: injected by Helm from ingressClass.name
  services:
    apiVersion: v1
    resources: services
    indexBy: ["metadata.namespace", "metadata.name"]
  endpoints:
    apiVersion: discovery.k8s.io/v1
    resources: endpointslices
    indexBy: ["metadata.namespace", "metadata.labels.kubernetes\\.io/service-name"]

templateSnippets:
  # ============================================================================
  # Feature Registration
  # ============================================================================

  features-100-ingress-tls:
    template: |
      {#- Registers TLS certificates from Ingress spec.tls with SSL infrastructure -#}
      {%- var gf = shared.Get("globalFeatures").(map[string]any) %}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%%
          var tlsList = ingress | dig("spec", "tls")
          if tlsList == nil {
            continue
          }
        %%}
        {%- for _, tls := range tlsList %}
          {%%
            var secretName = tls | dig("secretName")
            if secretName == nil {
              continue
            }
            // Unique key for this secret (namespace + name)
            var namespace = ingress | dig("metadata", "namespace") | fallback("")
            if !first_seen("ingress_tls", namespace, secretName) {
              continue
            }

            // Fetch Secret and extract cert+key
            var secret = resources.secrets.GetSingle(namespace, secretName)
            var secretData = secret | dig("data")
            var tlsCrt = secretData | dig("tls.crt")
            var tlsKey = secretData | dig("tls.key")
            if secretData == nil || tlsCrt == nil || tlsKey == nil {
              continue
            }

            // Combine cert and key into single PEM (HAProxy format)
            var combinedPem = (tlsCrt | b64decode()) + "\n" + (tlsKey | b64decode())

            // Register certificate file dynamically using file_registry
            // The filename is sanitized by PathResolver (dots replaced with underscores, etc.)
            var certFilename = tostring(namespace) + "_" + tostring(secretName) + ".pem"
            var certPath, certRegErr = fileRegistry.Register("cert", certFilename, combinedPem)
            if certRegErr != nil {
              fail("failed to register certificate " + certFilename + ": " + tostring(certRegErr))
            }

            // Extract the sanitized filename from the returned path
            // This is needed because HAProxy client-native sanitizes filenames for storage
            var sanitizedFilename = basename(certPath)

            // Register with SSL infrastructure for crt-list generation
            // Use sanitized_filename to ensure crt-list matches the actual file on disk
            var tlsCert = map[string]any{
              "secret_namespace": namespace,
              "secret_name": secretName,
              "sni_patterns": tls | dig("hosts") | fallback([]any{}),
              "sanitized_filename": sanitizedFilename,
            }
            gf["tlsCertificates"] = append(gf["tlsCertificates"].([]any), tlsCert)
          %%}
        {%- end %}
      {%- end %}

  # ============================================================================
  # Backend Generation
  # ============================================================================

  util-backend-name-ingress:
    template: |
      {#- Generates backend name: ing_<ns>_<name>_<svc>_<port> -#}
      {% macro BackendNameIngress(ingress any, path any) string %}{%%
        var namespace = tostring(ingress | dig("metadata", "namespace") | fallback(""))
        var name = tostring(ingress | dig("metadata", "name") | fallback(""))
        var serviceName = tostring(path | dig("backend", "service", "name") | fallback(""))
        var portIdentifier = (path | dig("backend", "service", "port", "name")) | fallback(path | dig("backend", "service", "port", "number") | fallback(""))
        show "ing_" + namespace + "_" + name + "_" + serviceName + "_" + tostring(portIdentifier)
      %%}{% end %}

  util-path-map-entry-ingress-shard:
    template: |
      {#- Generates map entries for a slice of Ingress resources -#}
      {%- import "util-backend-name-ingress" for BackendNameIngress -%}

      {% macro PathMapEntryIngressShard(ingresses []any, pathTypes []string, suffix string) string %}
        {%- for _, ingress := range ingresses -%}
          {%- var rules = ingress | dig("spec", "rules") | fallback([]any{}) -%}
          {%- var matchCount = 0 -%}
          {#- Count matching paths -#}
          {%- for _, rule := range rules -%}
            {%- var http = rule | dig("http") -%}
            {%- if http != nil -%}
              {%- for _, path := range http | dig("paths") | fallback([]any{}) -%}
                {%- var pathValue = path | dig("path") -%}
                {%- if pathValue != nil -%}
                  {%- var pathType = path | dig("pathType") | fallback("") -%}
                  {%- for _, checkType := range pathTypes -%}
                    {%- if pathType == checkType -%}{%- matchCount = matchCount + 1 -%}{%- end -%}
                  {%- end -%}
                {%- end -%}
              {%- end -%}
            {%- end -%}
          {%- end -%}
          {%- if matchCount > 0 -%}
      {{ "\n" }}# Ingress: {{ ingress | dig("metadata", "namespace") | fallback("") }}/{{ ingress | dig("metadata", "name") | fallback("") }} ({{ matchCount }} paths)
            {%- for _, rule := range rules -%}
              {%- var http = rule | dig("http") -%}
              {%- if http != nil -%}
                {%- for _, path := range http | dig("paths") | fallback([]any{}) -%}
                  {%- var pathValue = path | dig("path") -%}
                  {%- if pathValue != nil -%}
                    {%- var pathType = path | dig("pathType") | fallback("") -%}
                    {%- for _, checkType := range pathTypes -%}
                      {%- if pathType == checkType -%}
                        {%- var pathStr = pathValue | tostring() -%}
                        {%- var actualSuffix = suffix -%}
                        {%- if suffix == "/" && hasSuffix(pathStr, "/") -%}{%- actualSuffix = "" -%}{%- end -%}
      {{ "\n" }}{{ rule | dig("host") | fallback("") }}{{ pathStr }}{{ actualSuffix }} BACKEND:{{ BackendNameIngress(ingress, path) }}
                      {%- end -%}
                    {%- end -%}
                  {%- end -%}
                {%- end -%}
              {%- end -%}
            {%- end -%}
          {%- end -%}
        {%- end %}
      {% end %}

  # ============================================================================
  # Map File Generation (Sharded)
  # ============================================================================

  util-sharded-path-map-entry-ingress:
    template: |
      {#- Wraps PathMapEntryIngressShard with parallel sharding logic -#}
      {%- import "util-path-map-entry-ingress-shard" for PathMapEntryIngressShard -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {% macro ShardedPathMapEntryIngress(pathTypes []string, suffix string) string %}
      {%- var allIngresses = resources.ingresses.List() -%}
      {%- var n = toint(CalculateShardCount(len(allIngresses), 100)) -%}
      {%- if n <= 1 || len(allIngresses) < 100 -%}
      {{ PathMapEntryIngressShard(allIngresses, pathTypes, suffix) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go PathMapEntryIngressShard(shard_slice(allIngresses, i, n), pathTypes, suffix) }}
      {%- end -%}
      {%- end -%}
      {% end %}

  util-path-map-entry-ingress:
    template: |
      {#- Backward-compatible wrapper for ShardedPathMapEntryIngress -#}
      {%- import "util-sharded-path-map-entry-ingress" for ShardedPathMapEntryIngress -%}
      {% macro PathMapEntryIngress(pathTypes []string, suffix string) string %}
      {{ ShardedPathMapEntryIngress(pathTypes, suffix) }}
      {% end %}

  # ============================================================================
  # Backend Generation
  # ============================================================================

  util-generate-backends-ingress:
    template: |
      {#- Generates backend sections for a list of Ingresses -#}
      {%- import "util-backend-name-ingress" for BackendNameIngress -%}
      {%- import "util-backend-servers" for BackendServers -%}
      {% macro GenerateIngressBackends(ingresses []any) string %}
        {%- for _, ingress := range ingresses -%}
          {%- var ns = ingress | dig("metadata", "namespace") | fallback("") -%}
          {%- var name = ingress | dig("metadata", "name") | fallback("") -%}
          {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) -%}
            {%- for _, path := range rule | dig("http", "paths") | fallback([]any{}) -%}
              {%- var svc = path | dig("backend", "service") -%}
              {%- if svc != nil -%}
                {%- var svcName = svc | dig("name") | fallback("") -%}
                {%- var port = svc | dig("port", "number") | fallback(80) -%}
                {%- var portId = (svc | dig("port", "name")) | fallback(svc | dig("port", "number") | fallback("")) -%}
                {%- if first_seen("ingress_backend", ns, name, svcName, portId) -%}
                  {%- var healthPath = path | dig("path") | fallback("/") %}
      # Backend for: Ingress {{ ns }}/{{ name }} â†’ Service {{ svcName }}:{{ port }}
      backend {{ BackendNameIngress(ingress, path) }}
        balance roundrobin
        option httpchk GET {{ healthPath }}
        default-server check
                  {%- var serverOpts = map[string]any{"flags": []any{}} -%}
                  {{- render_glob "backend-directives-*" inherit_context }}
        {{ BackendServers(tostring(svcName), 0, toint(port), serverOpts) }}
                {%- end -%}
              {%- end -%}
            {%- end -%}
          {%- end -%}
        {%- end %}
      {% end %}

  util-sharded-backends-ingress:
    template: |
      {#- Sharded backend generator for Ingress resources -#}
      {%- import "util-generate-backends-ingress" for GenerateIngressBackends -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {% macro ShardedIngressBackends(ingresses []any) string %}
        {%- var n = toint(CalculateShardCount(len(ingresses), 100)) -%}
        {%- if n <= 1 || len(ingresses) < 100 -%}
      {{ GenerateIngressBackends(ingresses) }}
        {%- else -%}
          {%- for i := 0; i < n; i++ -%}
      {{ go GenerateIngressBackends(shard_slice(ingresses, i, n)) }}
          {%- end -%}
        {%- end -%}
      {% end %}

  backends-500-ingress:
    template: |
      {#- Generates HAProxy backend sections for all Ingress resources -#}
      {%- import "util-sharded-backends-ingress" for ShardedIngressBackends -%}
      {%- var allIngresses = resources.ingresses.List() -%}
      {%- if len(allIngresses) > 0 %}
      # ingress/backends-ingress
      {{ ShardedIngressBackends(allIngresses) }}
      {%- end -%}
  util-generate-host-map-ingress:
    template: |
      {#- Macro to generate host map entries for Ingress resources -#}
      {%- macro GenerateIngressHostMap(ingresses []any) -%}
      {%- for _, ingress := range ingresses -%}
      {%- var rules = ingress | dig("spec", "rules") | fallback([]any{}) %}
      {%- var rulesWithHttp = selectattr(rules, "http") %}
      {%- if len(rulesWithHttp) > 0 %}
      # Ingress: {{ ingress | dig("metadata", "namespace") | fallback("") }}/{{ ingress | dig("metadata", "name") | fallback("") }} ({{ len(rulesWithHttp) }} hosts)
      {% for _, rule := range rulesWithHttp %}
      {%- var hostWithoutAsterisk = tostring(rule | dig("host") | fallback("")) | replace("*", "") %}
      {{ hostWithoutAsterisk }} {{ hostWithoutAsterisk }}
      {% end %}
      {%- end %}
      {%- end %}
      {%- end macro -%}

  util-sharded-host-map-ingress:
    template: |
      {#- Sharded host map generator for Ingress resources -#}
      {%- import "util-generate-host-map-ingress" for GenerateIngressHostMap -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedIngressHostMap(ingresses []any) -%}
      {%- var n = toint(CalculateShardCount(len(ingresses), 100)) -%}
      {%- if n <= 1 || len(ingresses) < 100 -%}
      {{ GenerateIngressHostMap(ingresses) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GenerateIngressHostMap(shard_slice(ingresses, i, n)) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  map-host-500-ingress:
    template: |
      {#- Generate host map entries for Ingress resources (wildcards converted to suffix form) -#}
      {%- import "util-sharded-host-map-ingress" for ShardedIngressHostMap %}
      {%- var allIngresses = resources.ingresses.List() %}
      {%- if len(allIngresses) > 0 %}
      # ingress/map-host-ingress
      {{ ShardedIngressHostMap(allIngresses) }}
      {%- end -%}

  map-path-exact-500-ingress:
    template: |
      {#-
        Ingress Exact Path Map Entries

        Purpose: Generates path-exact.map entries for Ingress exact path matching.

        Extension Point: map-path-exact-* (priority 500)

        Matches: Ingress paths with pathType: Exact
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-exact-ingress
      {{ PathMapEntryIngress([]string{"Exact"}, "") }}

  map-path-prefix-exact-500-ingress:
    template: |
      {#-
        Ingress Prefix-Exact Path Map Entries

        Purpose: Generates path-prefix-exact.map entries for exact prefix boundary matching.

        Extension Point: map-path-prefix-exact-* (priority 500)

        Matches: Ingress paths with pathType: Prefix or ImplementationSpecific
        Note: No trailing slash - matches exact path for prefix boundary check.
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-prefix-exact-ingress
      {{ PathMapEntryIngress([]string{"Prefix", "ImplementationSpecific"}, "") }}

  map-path-prefix-500-ingress:
    template: |
      {#-
        Ingress Prefix Path Map Entries

        Purpose: Generates path-prefix.map entries for prefix path matching.

        Extension Point: map-path-prefix-* (priority 500)

        Matches: Ingress paths with pathType: Prefix or ImplementationSpecific
        Note: Adds trailing slash for HAProxy map_beg matching.
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-prefix-ingress
      {{ PathMapEntryIngress([]string{"Prefix", "ImplementationSpecific"}, "/") }}

validationTests:
  test-ingress-duplicate-backend-different-ports:
    description: Ingress with multiple paths to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-svc
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: admin
                port: 81
                targetPort: 8081
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-svc-abc123
            namespace: default
            labels:
              kubernetes.io/service-name: api-svc
          addressType: IPv4
          endpoints:
            - addresses:
                - "10.0.0.1"
              targetRef:
                kind: Pod
                name: api-pod-1
          ports:
            - name: http
              port: 8080
              protocol: TCP
            - name: admin
              port: 8081
              protocol: TCP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: multi-port
            namespace: default
          spec:
            ingressClassName: haproxy
            rules:
              - host: example.com
                http:
                  paths:
                    - path: /api
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 80
                    - path: /admin
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 81
                    - path: /app
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_80"
        description: Must generate backend for port 80

      - type: contains
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_81"
        description: Must generate backend for port 81

      - type: match_count
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/api/ BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix map must use BACKEND qualifier for /api

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/admin/ BACKEND:ing_default_multi-port_api-svc_81"
        description: Path prefix map must use BACKEND qualifier for /admin

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/app/ BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix map must use BACKEND qualifier for /app

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/api BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix-exact map must use BACKEND qualifier for /api

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/admin BACKEND:ing_default_multi-port_api-svc_81"
        description: Path prefix-exact map must use BACKEND qualifier for /admin

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/app BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix-exact map must use BACKEND qualifier for /app

      # Map Formatting Tests - Ensure proper line separation
      - type: not_contains
        target: map:host.map
        pattern: "hosts\\)\\S"
        description: Host map comments must not concatenate with entries (no non-whitespace immediately after comment)

      - type: not_contains
        target: map:path-prefix.map
        pattern: "paths\\)\\S"
        description: Path prefix map comments must not concatenate with entries

      - type: not_contains
        target: map:path-prefix-exact.map
        pattern: "paths\\)\\S"
        description: Path prefix-exact map comments must not concatenate with entries

      - type: contains
        target: map:host.map
        pattern: "(?m)^example\\.com example\\.com$"
        description: Host map entries must start at beginning of line and be properly formatted

      - type: contains
        target: map:path-prefix.map
        pattern: "(?m)^example\\.com/api/ BACKEND:"
        description: Path prefix map entries must start at beginning of line

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "(?m)^example\\.com/api BACKEND:"
        description: Path prefix-exact map entries must start at beginning of line

  test-ingress-tls-basic:
    description: Ingress with spec.tls should register TLS certificates
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: example-tls
            namespace: default
          data:
            # Test certificate (base64-encoded)
            tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lVT2FGRWhyWlRXZ1JpbEorSFJCOWhJQnlzT2xNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZERVNNQkFHQTFVRUF3d0piRzlqWVd4b2IzTjBNQ0FYRFRJMU1URXhPVEU0TWpVMU1Wb1lEekl4TWpVeApNREkyTVRneU5UVXhXakFVTVJJd0VBWURWUVFEREFsc2IyTmhiR2h2YzNRd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDWDJIQnA0V00rbFIvSXljLzRMR01qUHk0bUdFcUtVYm5xaFdRbU9nMXgKNHlnRkkzMkcyNWZYR1djZ0ZtVmg4YkZSZVFxdTB0Z1k2SUo5UE9nWmd5eHNhaUgzeldBMi8wbkdEejVvN2dYeQp5Z0VLaTdZY3M3bHNFNng0Y3lLK2tZaFdvZkNNaDJDck5LNWVCVzlRUnh3U3pieDNWREZqVS9HdVVaQnRBVWxICkRLd2ZCb0ZHNEhzaEZDUHl2Y3BuTlNLbUdwS0wwZ0UyczNBTHN5NWpqYjRpMnpyQng4Mng0Y3hQZUlCOEt6ckMKMDZvQXVwbzJDdUxaQTFMMkMrZVB5UlQ0QWxRUGNOL2l3WmdqMyt3eG8vWkFJaUxQK2NXbUY1dUdXeTZUREoybAo2K2FLYWFOajFCVVBWSkxTdW92WFhCMmc2akYxdWxIM1VWNVhPMlVMQ1ZzUkFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlRHdi9VWG5nZ2tKaytpTkN0WnFwMStTSS9JaGpBZkJnTlZIU01FR0RBV2dCVEd2L1VYbmdna0prK2kKTkN0WnFwMStTSS9JaGpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBSwozb3QyQTRyR05DWEpuZHB5OWlBa0dUUnk2SWxCcExKUlNJZ1JOWmlZQkU4SEtlWnUyR3JnUGI3V0ZUL1RyWkI2Cm5jMjhzVjdsYUNDNXlyZVUxeGVpL2ZjTllPSHlscWdBR2lFYmt2Um1za1hTd24wSlFaanpUNWl1a2hObVBkV0QKSWx0bWhCU3FsZlRsWFRYaytjMVlzeUJrVkN5TVNOdUZMd3pkODlLanJlU2xsZzE5clRVUmlLRzZGU0o2azBPSQprVE1lbWczRGZabldZSytNZnBxdjlVSDJSblBhMVJlbHJ4aTNLTWZoV0h2b2wxeUlVSGdnT0g3MkE4Wkd6eFZMClh4L09rSS8weXozUFhvM0xtUkRqczMzWUpXSzRTMmRwaFpyS3RMS2hqcEFIZzI1Nk8zUlN1bWd2d2NpYzZVRWMKaEpvWitneWZacUdBcnJ6M1dWTTkKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
            tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV1d0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktVd2dnU2hBZ0VBQW9JQkFRQ1gySEJwNFdNK2xSL0kKeWMvNExHTWpQeTRtR0VxS1VibnFoV1FtT2cxeDR5Z0ZJMzJHMjVmWEdXY2dGbVZoOGJGUmVRcXUwdGdZNklKOQpQT2daZ3l4c2FpSDN6V0EyLzBuR0R6NW83Z1h5eWdFS2k3WWNzN2xzRTZ4NGN5SytrWWhXb2ZDTWgyQ3JOSzVlCkJXOVFSeHdTemJ4M1ZERmpVL0d1VVpCdEFVbEhES3dmQm9GRzRIc2hGQ1B5dmNwbk5TS21HcEtMMGdFMnMzQUwKc3k1ampiNGkyenJCeDgyeDRjeFBlSUI4S3pyQzA2b0F1cG8yQ3VMWkExTDJDK2VQeVJUNEFsUVBjTi9pd1pnagozK3d4by9aQUlpTFArY1dtRjV1R1d5NlRESjJsNithS2FhTmoxQlVQVkpMU3VvdlhYQjJnNmpGMXVsSDNVVjVYCk8yVUxDVnNSQWdNQkFBRUNnZjhKSHBhaHhVZVFtcVF1Q3ZEU2x0ZmRaZzMvZTdYK1dLb3h5NUVZT3FSVUVyQjAKbm8wTGJHVFNKbFJyT08wZDFNWXhmbk9GekdQdUd3aTdQTTB6dXcwUDljL1VjaUUxTEYvaDVVaDZSTkZXbzRzcwpkdmVaQWJKQksyMVFUcG5ubUJYNEhnRzBidXovVzBxZG12WDBmRkRUVUVmaFlzMFVpaFlad2d4S2Y2bEcrd1FzClZRclNiTzlMKzRJaHN2cnNSQlRGYU1nV0FMNGp0a3VpcTdSaVFkamRpejRkMmZJd1FtcVR5VEFvWlh5ZW9WRmEKM2JlRXh3aWtJME5pcXBNTWlaUjlXeTYzZkw2TlowZ0F5T0dKL09FaVU2Q3kyV2JCQzZrbVhnRlpOVW1Va1B5dAp3TXlqNTg5ZG1taDNaTGw1VEloNzVOc1dTNlVvTm1abzV3MmxLWUVDZ1lFQXh5N3dJeWxFbDlLaURvT1Q5V3gyCjFOcnp3bjQzLzVVbFAxakVFM0NiMXBiRDJCQjRUNXM4TmxCSEFOa0tFeFI1RUJnNTNYakw3aVlvTU1rWWUwL1YKRFVOdWFLRzlaaHhUSklualdPNURNUDE2NVFwNlBzdklObmlVZ1JLcW1Bc1hSNkNkN0NXeVIzcEZVOUZPcEJpWgo2aWt1eFVNYnZFWW8xVHNUWjB2Umw5RUNnWUVBd3lpNVNORWpEM2x6UHozcm5OVllRTEJBL2V1NS8wS1JXc2hQCmJVcit0YUszN1l4ZEJMV1JHOVpjOHd2ZU9pVWZTUHhWNmwyWnFRdVQ0VVVFdmYrbTlJWEZGZXZxUE1IanNZUVQKVVlRQVRxMkgwelF3Mm5kS2thdDlWSk81UVZKV252N0YxaWY5S3VPRFozbEhiUk96aEJjZjZXUWlBS0RNQWQ3cwpQNDNYbjBFQ2dZRUFxNmFacjlONmwxUWY4RjRYL2lLdzdaS2JDdnQzQ3J6ZlVvNE91Nm9Kd280K3pFNjFQL1ZKCm1JenFBNk1HK1pabEZpZXFobC81Ym94WGltTml3N0h5cXZGM2pwZ0QvcUZlVFZpL0lmNkN6UTlFLzJsZUhBdkYKeUp0MWJ4NUZBYTVkSzQ4UlNWYmJJcG9PY01NcUFHUnJEODdaelltZHQwekhGNnRIZDNkeGNtRUNnWUFzRWJNZApWVlNVZHZsbVM0WTc2UlUvcmsxT3lYODd1LzEwd1l6bUFpeFlPY0ZNM0FoWk91TGtwVmhoN2NrbDJpSWhhaEhBCmxaaFFTdlAreDRZVm5YaEcrVG9UQkMzbHdHYTVQRGpjakhGQlV3QTcyaW81K3Z3VXZ1UFRTSFJwNHJ6NnRFOWEKVjdkY2l2bXVVUDJuRE83Wm9oc3JxZGZmeW0rbThIN3FydzRFd1FLQmdEV1RqME82TXpyUUVhQVlrUVVucERVLwpYOFd5OGlPcStFYU5ZejNWWUtKSm5xVkJTeldLZDIrRFRQVmlvVHZqOVhVYkhGK1p3MW9ieXljcklDcVgrd0RCCkl4ZXBoMlBNNERKUHVlRnFJVzRqY3lQSkJuVGt4OVBuNUNKem1XSUJybE1vZjZON2tvWFIzMFBMbjlDRlRpNFoKa1dhTnhjR3BROVNldjVQeEoxL2QKLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQo=
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: web-svc
            namespace: default
          spec:
            ports:
              - port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: web-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: web-svc
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
              protocol: TCP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: tls-ingress
            namespace: default
          spec:
            ingressClassName: haproxy
            tls:
              - hosts:
                  - example.com
                  - www.example.com
                secretName: example-tls
            rules:
              - host: example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: web-svc
                          port:
                            number: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid with Ingress TLS

      - type: contains
        target: crt-list:certificate-list.txt
        pattern: "default_example-tls\\.pem \\[ocsp-update on\\] example\\.com www\\.example\\.com"
        description: CRT-list must include Ingress TLS certificate with SNI patterns

      - type: contains
        target: cert:default_example-tls.pem
        pattern: "BEGIN CERTIFICATE"
        description: TLS certificate file must be generated from Secret
