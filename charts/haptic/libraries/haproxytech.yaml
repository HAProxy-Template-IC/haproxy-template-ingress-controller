# HAProxyTech Annotations Library
#
# Provides haproxy.org/* annotation support for Ingress resources.
# Gateway API uses filters instead - see docs/libraries/gateway.md.

watchedResources:
  secrets:
    apiVersion: v1
    resources: secrets
    indexBy: ["metadata.namespace", "metadata.name"]

templateSnippets:
  # ============================================================================
  # Annotation Helpers
  # ============================================================================

  util-haproxytech-helpers:
    template: |
      {#- Annotation processing helpers -#}

      {#- Gets haproxy.org/<name> annotation with default -#}
      {% macro Ann(ingress any, name string, def string) string %}
        {%% show ingress | dig("metadata", "annotations", "haproxy.org/" + name) | fallback(def) | tostring() %%}
      {% end %}

      {#- Gets Ingress key as ns/name -#}
      {% macro IKey(ingress any) string %}
        {%% show (ingress | dig("metadata", "namespace") | fallback("")) + "/" + (ingress | dig("metadata", "name") | fallback("")) %%}
      {% end %}

      {#- Extracts hosts from Ingress rules -#}
      {% macro IHosts(ingress any) []any %}
        {%%
          var hosts = []any{}
          for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) {
            if h := rule | dig("host"); h != nil {
              hosts = append(hosts, h)
            }
          }
          show hosts
        %%}
      {% end %}

  util-haproxytech-ssl-passthrough:
    template: |
      {#- Caches SSL passthrough backends from haproxy.org/ssl-passthrough annotations.
          Uses ComputeIfAbsent for race-free caching across parallel template renders.
          The compute function runs exactly once, even with concurrent access. -#}
      {%- import "util-build-haproxytech-ssl-passthrough" for BuildHaproxytechSSLPassthrough %}
      {%%
        var _, _ = shared.ComputeIfAbsent("haproxytech_sslPassthrough", func() any {
          var sslData = map[string]any{"backends": []any{}}
          BuildHaproxytechSSLPassthrough(sslData)
          return sslData
        })
      %%}

  util-build-haproxytech-ssl-passthrough:
    template: |
      {#- Macro to populate SSL passthrough data from haproxy.org/ssl-passthrough annotations.
          Called from ComputeIfAbsent to enable use of template functions. -#}
      {%- macro BuildHaproxytechSSLPassthrough(sslData map[string]any) %}
        {%- for _, ingress := range resources.ingresses.List() %}
          {%- var passthrough = ingress | dig("metadata", "annotations", "haproxy.org/ssl-passthrough") | fallback("") | tostring() %}
          {%- if passthrough == "true" %}
            {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
            {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
            {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
              {%- var host = rule | dig("host") %}
              {%- if host != nil && first_seen("haproxytech_sslPassthrough_host", tostring(host)) %}
                {%- sslData["backends"] = append(sslData["backends"].([]any), map[string]any{
                  "name": "ssl-passthrough-" + ns + "-" + name,
                  "sni": host, "namespace": ns, "ingress": name,
                }) %}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end macro %}

  # ============================================================================
  # Frontend Filters - Applied before backend selection
  # ============================================================================

  frontend-filters-100-haproxytech-basic-headers:
    template: |
      {#- HAProxy forwarded-for option (frontend-level, output once if any ingress enables it) -#}
      {%- var forwardforEnabled = false %}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_basic_headers", key) %}
          {%- var value = ingress | dig("metadata", "annotations", "haproxy.org/forwarded-for") | fallback("") | tostring() %}
          {%- if value != "" && value != "true" && value != "false" %}
            {{- fail("Invalid value '" + value + "' for annotation 'haproxy.org/forwarded-for' on Ingress '" + key + "'. Valid values: 'true', 'false'") -}}
          {%- end %}
          {%- if value == "true" %}{%- forwardforEnabled = true %}{%- end %}
        {%- end %}
      {%- end %}
      {%- if forwardforEnabled %}
      # haproxytech/frontend-filters-haproxytech-basic-headers (forwarded-for)
      option forwardfor
      {%- end -%}

  frontend-filters-150-haproxytech-timeouts:
    template: |
      {#- HAProxy frontend timeouts (client, http-request, http-keep-alive) -#}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_timeouts", key) %}
          {%- var tClient = ingress | dig("metadata", "annotations", "haproxy.org/timeout-client") | fallback("") | tostring() %}
          {%- var tHttpReq = ingress | dig("metadata", "annotations", "haproxy.org/timeout-http-request") | fallback("") | tostring() %}
          {%- var tKeepAlive = ingress | dig("metadata", "annotations", "haproxy.org/timeout-http-keep-alive") | fallback("") | tostring() %}
          {%- if tClient != "" %}
      # haproxytech/frontend-filters-haproxytech-timeouts
      timeout client {{ tClient }}
          {% end %}
          {%- if tHttpReq != "" %}
      timeout http-request {{ tHttpReq }}
          {% end %}
          {%- if tKeepAlive != "" %}
      timeout http-keep-alive {{ tKeepAlive }}
          {% end %}
        {%- end %}
      {%- end -%}

  frontend-filters-200-haproxytech-access-control:
    template: |
      {#- HAProxy IP allowlist/denylist -#}
      {%- import "util-ingress-helpers" for HostMatchCondition -%}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_access_control", key) %}
          {%- var hosts = []any{} %}
          {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
            {%- var h = rule | dig("host") %}
            {%- if h != nil %}{%- hosts = append(hosts, h) %}{%- end %}
          {%- end %}
          {%- var allowlist = ingress | dig("metadata", "annotations", "haproxy.org/allowlist") | fallback("") | tostring() %}
          {%- var denylist = ingress | dig("metadata", "annotations", "haproxy.org/denylist") | fallback("") | tostring() %}
          {%- if allowlist != "" && len(hosts) > 0 %}
            {%- var aclName = "haproxytech_allowlist_" + ns + "_" + name %}
      # haproxytech/frontend-filters-haproxytech-access-control (allowlist for {{ key }})
      acl {{ aclName }} src{% for _, ip := range split(allowlist, ",") %}{% var t = trimSpace(ip) %}{% if t != "" %} {{ t }}{% end %}{% end %}
      http-request deny if {{ HostMatchCondition(hosts) }} !{{ aclName }}
          {%- end %}
          {%- if denylist != "" && len(hosts) > 0 %}
            {%- var aclName = "haproxytech_denylist_" + ns + "_" + name %}
      # haproxytech/frontend-filters-haproxytech-access-control (denylist for {{ key }})
      acl {{ aclName }} src{% for _, ip := range split(denylist, ",") %}{% var t = trimSpace(ip) %}{% if t != "" %} {{ t }}{% end %}{% end %}
      http-request deny if {{ HostMatchCondition(hosts) }} {{ aclName }}
          {%- end %}
        {%- end %}
      {%- end -%}

  frontend-filters-300-haproxytech-cors:
    template: |
      {#- HAProxy CORS configuration -#}
      {%- import "util-ingress-helpers" for HostMatchCondition -%}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_cors", key) %}
          {%- var corsEnabled = ingress | dig("metadata", "annotations", "haproxy.org/cors-enable") | fallback("") | tostring() %}
          {%- if corsEnabled == "true" %}
            {%- var hosts = []any{} %}
            {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
              {%- var h = rule | dig("host") %}
              {%- if h != nil %}{%- hosts = append(hosts, h) %}{%- end %}
            {%- end %}
            {%- var origin = ingress | dig("metadata", "annotations", "haproxy.org/cors-allow-origin") | fallback("*") | tostring() %}
            {%- var methods = ingress | dig("metadata", "annotations", "haproxy.org/cors-allow-methods") | fallback("GET, POST") | tostring() %}
            {%- var headers = ingress | dig("metadata", "annotations", "haproxy.org/cors-allow-headers") | fallback("") | tostring() %}
            {%- var credentials = ingress | dig("metadata", "annotations", "haproxy.org/cors-allow-credentials") | fallback("false") | tostring() %}
            {%- var maxAge = ingress | dig("metadata", "annotations", "haproxy.org/cors-max-age") | fallback("0") | tostring() %}
            {%- if credentials == "true" && origin == "*" %}
              {{- fail("CORS configuration error on Ingress '" + key + "': cors-allow-credentials cannot be 'true' when cors-allow-origin is '*'. Specify an explicit origin.") -}}
            {%- end %}
            {%- if len(hosts) > 0 %}
              {%- var cond = HostMatchCondition(hosts) %}
      # haproxytech/frontend-filters-haproxytech-cors (for {{ key }})
      http-request capture req.hdr(Origin) len 128 if {{ cond }}

      http-response set-header Access-Control-Allow-Origin '{{ origin }}' if {{ cond }}

      http-response set-header Access-Control-Allow-Methods '{{ methods }}' if {{ cond }}

              {% if headers != "" -%}
      http-response set-header Access-Control-Allow-Headers '{{ headers }}' if {{ cond }}

              {% end -%}
              {% if credentials == "true" -%}
      http-response set-header Access-Control-Allow-Credentials 'true' if {{ cond }}

              {% end -%}
              {% if maxAge != "0" -%}
      http-response set-header Access-Control-Max-Age '{{ maxAge }}' if {{ cond }}

              {% end -%}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  frontend-filters-400-haproxytech-ssl-redirect:
    template: |
      {#- HAProxy SSL redirect -#}
      {%- import "util-ingress-helpers" for HostMatchCondition -%}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_sslRedirect", key) %}
          {%- var sslRedirect = ingress | dig("metadata", "annotations", "haproxy.org/ssl-redirect") | fallback("") | tostring() %}
          {%- if sslRedirect == "true" %}
            {%- var hosts = []any{} %}
            {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
              {%- var h = rule | dig("host") %}
              {%- if h != nil %}{%- hosts = append(hosts, h) %}{%- end %}
            {%- end %}
            {%- var code = ingress | dig("metadata", "annotations", "haproxy.org/ssl-redirect-code") | fallback("302") | tostring() %}
            {%- if len(hosts) > 0 %}
      # haproxytech/frontend-filters-haproxytech-ssl-redirect (for {{ key }})
      http-request redirect scheme https code {{ code }} if !{ ssl_fc } {{ HostMatchCondition(hosts) }}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  frontend-filters-450-haproxytech-redirects:
    template: |
      {#- HAProxy request redirect -#}
      {%- import "util-ingress-helpers" for HostMatchCondition -%}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_redirects", key) %}
          {%- var target = ingress | dig("metadata", "annotations", "haproxy.org/request-redirect") | fallback("") | tostring() %}
          {%- if target != "" %}
            {%- var code = ingress | dig("metadata", "annotations", "haproxy.org/request-redirect-code") | fallback("302") | tostring() %}
            {%- var validCodes = []string{"301", "302", "303", "307", "308"} %}
            {%- var codeValid = false %}
            {%- for _, v := range validCodes %}{%- if code == v %}{%- codeValid = true %}{%- end %}{%- end %}
            {%- if !codeValid %}
              {{- fail("Invalid value '" + code + "' for annotation 'haproxy.org/request-redirect-code' on Ingress '" + key + "'. Valid values: 301, 302, 303, 307, 308") -}}
            {%- end %}
            {%- var hosts = []any{} %}
            {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
              {%- var h = rule | dig("host") %}
              {%- if h != nil %}{%- hosts = append(hosts, h) %}{%- end %}
            {%- end %}
            {%- if len(hosts) > 0 %}
      # haproxytech/frontend-filters-haproxytech-redirects (for {{ key }})
      http-request redirect location {{ target }} code {{ code }} if {{ HostMatchCondition(hosts) }}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  frontend-filters-500-haproxytech-logging:
    template: |
      {#- HAProxy request capture and source IP detection -#}
      {%- import "util-ingress-helpers" for HostMatchCondition -%}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- if first_seen("haproxytech_logging", key) %}
          {%- var srcIpHeader = ingress | dig("metadata", "annotations", "haproxy.org/src-ip-header") | fallback("") | tostring() %}
          {%- var reqCapture = ingress | dig("metadata", "annotations", "haproxy.org/request-capture") | fallback("") | tostring() %}
          {%- var captureLen = ingress | dig("metadata", "annotations", "haproxy.org/request-capture-len") | fallback("128") | tostring() %}
          {%- if srcIpHeader != "" %}
            {%- var hosts = []any{} %}
            {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
              {%- var h = rule | dig("host") %}
              {%- if h != nil %}{%- hosts = append(hosts, h) %}{%- end %}
            {%- end %}
            {%- if len(hosts) > 0 %}
      # haproxytech/frontend-filters-haproxytech-logging (src-ip-header for {{ key }})
      http-request set-src hdr({{ srcIpHeader }}) if {{ HostMatchCondition(hosts) }}
            {%- end %}
          {%- end %}
          {%- if reqCapture != "" %}
      # haproxytech/frontend-filters-haproxytech-logging (request-capture for {{ key }})
            {%- for _, line := range split(reqCapture, "\n") %}
              {%- var t = trimSpace(line) %}
              {%- if t != "" %}
      capture request header {{ t }} len {{ captureLen }}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  # ============================================================================
  # Global Top-Level Sections
  # ============================================================================

  global-top-500-haproxytech-ingress-auth:
    template: |
      {#- HAProxy userlist generation for basic authentication -#}
      {#- Uses per-secret userlist naming for deduplication (improves validation performance) -#}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var authType = ingress | dig("metadata", "annotations", "haproxy.org/auth-type") | fallback("") | tostring() %}
        {%- if authType != "" && authType != "basic-auth" %}
          {{- fail("Invalid value '" + authType + "' for annotation 'haproxy.org/auth-type' on Ingress '" + key + "'. Valid values: 'basic-auth'") -}}
        {%- end %}
        {%- if authType == "basic-auth" %}
          {%- var authSecret = ingress | dig("metadata", "annotations", "haproxy.org/auth-secret") | fallback("") | tostring() %}
          {%- if authSecret != "" %}
            {#- Parse secret reference (supports "ns/name" or just "name") -#}
            {%- var secretNs = ns %}
            {%- var secretName = authSecret %}
            {%- if strings_contains(authSecret, "/") %}
              {%- var parts = split(authSecret, "/") %}
              {%- secretNs = parts[0] %}
              {%- secretName = parts[1] %}
            {%- end %}
            {#- Userlist name is per-secret for deduplication -#}
            {%- var userlistName = "auth_" + secretNs + "_" + secretName %}
            {%- if first_seen("haproxytech_userlist", userlistName) %}
              {%- var secret = resources.secrets.GetSingle(secretNs, secretName) %}
              {%- if secret != nil %}
      # haproxytech/global-top-haproxytech-ingress-auth
      userlist {{ userlistName }}
                {% var secretData = secret | dig("data") | fallback(map[string]any{}) -%}
                {%- var hashRegex = extraContext | dig("password_hash_validation_regex") | fallback("^.*$") | tostring() %}
                {%- var hashErrMsg = extraContext | dig("password_hash_validation_error_message") | fallback("Invalid password hash") | tostring() %}
                {%- for _, username := range keys(secretData) %}
                  {%- var passwordHash = secretData[username] | b64decode() | tostring() %}
                  {%- if !regex_search(passwordHash, hashRegex) %}
                    {{- fail(hashErrMsg + " for user '" + username + "' in Secret '" + secretNs + "/" + secretName + "' (pattern \"" + hashRegex + "\")") -}}
                  {%- end %}
        user {{ username }} password {{ passwordHash }}
                {% end -%}
              {%- else %}
                {{- fail("Secret '" + secretNs + "/" + secretName + "' referenced by annotation 'haproxy.org/auth-secret' does not exist. Please create the secret or update the annotation.") -}}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  # ============================================================================
  # Backend Directives - Applied per-backend (requires ingress in context)
  # ============================================================================

  backend-directives-100-haproxytech-pod-maxconn:
    template: |
      {#- HAProxy pod-maxconn (divided by HAProxy pod count) -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var podMaxconn = ingress | dig("metadata", "annotations", "haproxy.org/pod-maxconn") | fallback("") | tostring() %}
        {%- if podMaxconn != "" %}
          {%- var val = toint(podMaxconn) %}
          {%- if val <= 0 %}
            {{- fail("Invalid value '" + podMaxconn + "' for annotation 'haproxy.org/pod-maxconn' on Ingress '" + key + "'. Must be a positive integer.") -}}
          {%- end %}
          {%- var haproxyPodCount = 0 %}
          {%- if controller != nil %}
            {%- var pods = controller.haproxy_pods %}
            {%- if pods != nil %}{%- haproxyPodCount = len(pods.List()) %}{%- end %}
          {%- end %}
          {%- if haproxyPodCount > 0 %}
            {%- var perPod = ((val | float64()) / (haproxyPodCount | float64())) | ceil() %}
      # haproxytech/backend-directives-haproxytech-pod-maxconn
      # pod-maxconn: {{ podMaxconn }} total / {{ haproxyPodCount }} HAProxy pods = {{ perPod }} per pod
            {% serverOpts["podMaxconnValue"] = perPod -%}
          {%- else %}
      # haproxytech/backend-directives-haproxytech-pod-maxconn
      # pod-maxconn: {{ podMaxconn }} (no HAProxy pods discovered yet, using full value)
            {% serverOpts["podMaxconnValue"] = val -%}
          {%- end %}
        {%- end %}
      {%- end -%}

  backend-directives-100-haproxytech-timeouts:
    template: |
      {#- HAProxy backend timeouts (server, connect, queue, tunnel, check) -#}
      {%- if ingress != nil %}
        {%- var tServer = ingress | dig("metadata", "annotations", "haproxy.org/timeout-server") | fallback("") | tostring() %}
        {%- var tConnect = ingress | dig("metadata", "annotations", "haproxy.org/timeout-connect") | fallback("") | tostring() %}
        {%- var tQueue = ingress | dig("metadata", "annotations", "haproxy.org/timeout-queue") | fallback("") | tostring() %}
        {%- var tTunnel = ingress | dig("metadata", "annotations", "haproxy.org/timeout-tunnel") | fallback("") | tostring() %}
        {%- var tCheck = ingress | dig("metadata", "annotations", "haproxy.org/timeout-check") | fallback("") | tostring() %}
        {%- if tServer != "" %}
      # haproxytech/backend-directives-haproxytech-timeouts
      timeout server {{ tServer }}
        {% end %}
        {%- if tConnect != "" %}
      timeout connect {{ tConnect }}
        {% end %}
        {%- if tQueue != "" %}
      timeout queue {{ tQueue }}
        {% end %}
        {%- if tTunnel != "" %}
      timeout tunnel {{ tTunnel }}
        {% end %}
        {%- if tCheck != "" %}
      timeout check {{ tCheck }}
        {% end %}
      {%- end -%}

  backend-directives-150-haproxytech-load-balance:
    template: |
      {#- HAProxy load balancing algorithm -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var lb = ingress | dig("metadata", "annotations", "haproxy.org/load-balance") | fallback("") | tostring() %}
        {%- if lb != "" %}
          {#- Exact match algorithms -#}
          {%- var exactValid = []string{"roundrobin", "static-rr", "leastconn", "first", "source", "random"} %}
          {#- Prefix match algorithms (support parameters like hdr(name), uri whole, url_param(name), rdp-cookie(name)) -#}
          {%- var prefixValid = []string{"uri", "url_param", "hdr", "rdp-cookie"} %}
          {%- var isValid = false %}
          {%- for _, v := range exactValid %}{%- if lb == v %}{%- isValid = true %}{%- end %}{%- end %}
          {%- if !isValid %}
            {%- for _, v := range prefixValid %}
              {%- if lb | hasPrefix(v) %}{%- isValid = true %}{%- end %}
            {%- end %}
          {%- end %}
          {%- if !isValid %}
            {{- fail("Invalid value '" + lb + "' for annotation 'haproxy.org/load-balance' on Ingress '" + key + "'. Valid algorithms: " + (exactValid | join(", ")) + ", or parameterized: " + (prefixValid | join("(...), ")) + "(...)") -}}
          {%- end %}
      # haproxytech/backend-directives-haproxytech-load-balance
      balance {{ lb }}
        {%- end %}
      {%- end -%}

  backend-directives-200-haproxytech-health-checks:
    template: |
      {#- HAProxy health check toggle -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var check = ingress | dig("metadata", "annotations", "haproxy.org/check") | fallback("") | tostring() %}
        {%- if check != "" %}
          {%- if check != "true" && check != "false" %}
            {{- fail("Invalid value '" + check + "' for annotation 'haproxy.org/check' on Ingress '" + key + "'. Valid values: 'true', 'false'") -}}
          {%- end %}
      # haproxytech/backend-directives-haproxytech-health-checks
      # Note: check annotation value: {{ check }}
        {%- end %}
      {%- end -%}

  backend-directives-210-haproxytech-advanced-health-checks:
    template: |
      {#- HAProxy advanced health check configuration -#}
      {%- if ingress != nil %}
        {%- var checkHttp = ingress | dig("metadata", "annotations", "haproxy.org/check-http") | fallback("") | tostring() %}
        {%- var checkInterval = ingress | dig("metadata", "annotations", "haproxy.org/check-interval") | fallback("") | tostring() %}
        {%- if checkHttp != "" %}
      # haproxytech/backend-directives-haproxytech-advanced-health-checks
          {%- if strings_contains(checkHttp, " ") %}
      option httpchk {{ checkHttp }}
          {%- else %}
      option httpchk GET {{ checkHttp }}
          {%- end %}
        {%- end %}
        {%- if checkInterval != "" %}
      # Note: check-interval annotation value: {{ checkInterval }}
        {%- end %}
      {%- end -%}

  backend-directives-250-haproxytech-rate-limiting:
    template: |
      {#- HAProxy rate limiting -#}
      {%- if ingress != nil %}
        {%- var rateReq = ingress | dig("metadata", "annotations", "haproxy.org/rate-limit-requests") | fallback("") | tostring() %}
        {%- if rateReq != "" %}
          {%- var period = ingress | dig("metadata", "annotations", "haproxy.org/rate-limit-period") | fallback("1s") | tostring() %}
          {%- var size = ingress | dig("metadata", "annotations", "haproxy.org/rate-limit-size") | fallback("100k") | tostring() %}
          {%- var status = ingress | dig("metadata", "annotations", "haproxy.org/rate-limit-status-code") | fallback("403") | tostring() %}
      # haproxytech/backend-directives-haproxytech-rate-limiting
      stick-table type ip size {{ size }} expire {{ period }} store http_req_rate({{ period }})
      http-request track-sc0 src
      http-request deny deny_status {{ status }} if { sc_http_req_rate(0) gt {{ rateReq }} }
        {%- end %}
      {%- end -%}

  backend-directives-250-haproxytech-set-host:
    template: |
      {#- HAProxy set-host header -#}
      {%- if ingress != nil %}
        {%- var host = ingress | dig("metadata", "annotations", "haproxy.org/set-host") | fallback("") | tostring() %}
        {%- if host != "" %}
      # haproxytech/backend-directives-haproxytech-set-host
      http-request set-header Host '{{ host }}'
        {%- end %}
      {%- end -%}

  backend-directives-300-haproxytech-header-manipulation:
    template: |
      {#- HAProxy request/response header manipulation -#}
      {%- if ingress != nil %}
        {%- var reqHeaders = ingress | dig("metadata", "annotations", "haproxy.org/request-set-header") | fallback("") | tostring() %}
        {%- var respHeaders = ingress | dig("metadata", "annotations", "haproxy.org/response-set-header") | fallback("") | tostring() %}
        {%- if reqHeaders != "" %}
      # haproxytech/backend-directives-haproxytech-header-manipulation (request)
          {%- for _, line := range split(reqHeaders, "\n") %}
            {%- var t = trimSpace(line) %}
            {%- if t != "" && strings_contains(t, " ") %}
              {%- var parts = split(t, " ") %}
      http-request set-header {{ parts[0] }} '{{ parts[1:] | join(" ") }}'
            {%- end %}
          {%- end %}
        {%- end %}
        {%- if respHeaders != "" %}
      # haproxytech/backend-directives-haproxytech-header-manipulation (response)
          {%- for _, line := range split(respHeaders, "\n") %}
            {%- var t = trimSpace(line) %}
            {%- if t != "" && strings_contains(t, " ") %}
              {%- var parts = split(t, " ") %}
      http-response set-header {{ parts[0] }} '{{ parts[1:] | join(" ") }}'
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end -%}

  backend-directives-350-haproxytech-path-rewrite:
    template: |
      {#- HAProxy path rewrite -#}
      {%- if ingress != nil %}
        {%- var rewrite = ingress | dig("metadata", "annotations", "haproxy.org/path-rewrite") | fallback("") | tostring() %}
        {%- if rewrite != "" %}
          {%- if strings_contains(rewrite, " ") %}
            {%- var parts = split(rewrite, " ") %}
      # haproxytech/backend-directives-haproxytech-path-rewrite
      http-request replace-path {{ parts[0] }} {{ parts[1:] | join(" ") }}
          {%- else %}
      # haproxytech/backend-directives-haproxytech-path-rewrite
      http-request replace-path (.*) {{ rewrite }}
          {%- end %}
        {%- end %}
      {%- end -%}

  backend-directives-400-haproxytech-session-persistence:
    template: |
      {#- HAProxy dynamic cookie persistence -#}
      {%- if ingress != nil %}
        {%- var cookie = ingress | dig("metadata", "annotations", "haproxy.org/cookie-persistence") | fallback("") | tostring() %}
        {%- if cookie != "" %}
      # haproxytech/backend-directives-haproxytech-session-persistence
      cookie {{ cookie }} insert indirect nocache dynamic
      # Note: dynamic-cookie-key would be set by base template for multi-instance support
        {%- end %}
      {%- end -%}

  backend-directives-401-haproxytech-session-persistence-no-dynamic:
    template: |
      {#- HAProxy static cookie persistence -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var dynamic = ingress | dig("metadata", "annotations", "haproxy.org/cookie-persistence") | fallback("") | tostring() %}
        {%- var static = ingress | dig("metadata", "annotations", "haproxy.org/cookie-persistence-no-dynamic") | fallback("") | tostring() %}
        {%- if dynamic != "" && static != "" %}
          {{- fail("Cannot use both 'haproxy.org/cookie-persistence' and 'haproxy.org/cookie-persistence-no-dynamic' on Ingress '" + key + "'. Use only one cookie persistence method.") -}}
        {%- end %}
        {%- if static != "" %}
      # haproxytech/backend-directives-haproxytech-session-persistence-no-dynamic
      cookie {{ static }} insert indirect nocache
        {%- end %}
      {%- end -%}

  backend-directives-500-haproxytech-ingress-auth:
    template: |
      {#- HAProxy basic authentication backend directive -#}
      {#- Uses per-secret userlist naming for deduplication -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}
        {%- var authType = ingress | dig("metadata", "annotations", "haproxy.org/auth-type") | fallback("") | tostring() %}
        {%- if authType != "" && authType != "basic-auth" %}
          {{- fail("Invalid value '" + authType + "' for annotation 'haproxy.org/auth-type' on Ingress '" + key + "'. Valid values: 'basic-auth'") -}}
        {%- end %}
        {%- if authType == "basic-auth" %}
          {%- var authSecret = ingress | dig("metadata", "annotations", "haproxy.org/auth-secret") | fallback("") | tostring() %}
          {%- var authRealm = ingress | dig("metadata", "annotations", "haproxy.org/auth-realm") | fallback("RestrictedArea") | tostring() %}
          {#- Validate auth realm: DataPlane API pattern ^[^\s]+$ forbids spaces -#}
          {%- if strings_contains(authRealm, " ") %}
            {%- var sanitize = extraContext | dig("sanitize_auth_realm") | fallback(false) %}
            {%- if sanitize %}
              {#- Auto-sanitize: replace spaces with dashes -#}
              {%- authRealm = replace(authRealm, " ", "-") %}
            {%- else %}
              {{- fail("Invalid auth-realm '" + authRealm + "' on Ingress '" + key + "': realm cannot contain spaces (DataPlane API limitation). Use hyphens or underscores, or set extraContext.sanitize_auth_realm=true to auto-replace spaces with dashes.") -}}
            {%- end %}
          {%- end %}
          {%- if authSecret != "" %}
            {#- Parse secret reference (supports "ns/name" or just "name") -#}
            {%- var secretNs = ns %}
            {%- var secretName = authSecret %}
            {%- if strings_contains(authSecret, "/") %}
              {%- var parts = split(authSecret, "/") %}
              {%- secretNs = parts[0] %}
              {%- secretName = parts[1] %}
            {%- end %}
            {#- Userlist name is per-secret for deduplication -#}
            {%- var userlistName = "auth_" + secretNs + "_" + secretName %}
      # haproxytech/backend-directives-haproxytech-ingress-auth
      http-request auth realm "{{ authRealm }}" unless { http_auth({{ userlistName }}) }
          {%- end -%}
        {%- end -%}
      {%- end -%}

  backend-directives-900-haproxytech-advanced:
    template: |
      {#- HAProxy advanced backend configuration -#}
      {%- if ingress != nil %}
        {%- var ns = ingress | dig("metadata", "namespace") | fallback("") | tostring() %}
        {%- var name = ingress | dig("metadata", "name") | fallback("") | tostring() %}
        {%- var key = ns + "/" + name %}

        {#- send-proxy-protocol -#}
        {%- var sendProxy = ingress | dig("metadata", "annotations", "haproxy.org/send-proxy-protocol") | fallback("") | tostring() %}
        {%- if sendProxy != "" %}
          {%- if sendProxy == "proxy" || sendProxy == "proxy-v1" %}
            {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "send-proxy") %}
          {%- else if sendProxy == "proxy-v2" %}
            {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "send-proxy-v2") %}
          {%- else if sendProxy == "proxy-v2-ssl" %}
            {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "send-proxy-v2-ssl") %}
          {%- else if sendProxy == "proxy-v2-ssl-cn" %}
            {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "send-proxy-v2-ssl-cn") %}
          {%- end %}
        {%- end %}

        {#- server-ssl -#}
        {%- var serverSsl = ingress | dig("metadata", "annotations", "haproxy.org/server-ssl") | fallback("") | tostring() %}
        {%- if serverSsl == "true" %}
          {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "ssl verify none") %}
        {%- end %}

        {#- server-proto -#}
        {%- var serverProto = ingress | dig("metadata", "annotations", "haproxy.org/server-proto") | fallback("") | tostring() %}
        {%- if serverProto != "" %}
          {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "proto " + serverProto) %}
        {%- end %}

        {#- server-ca: CA certificate for backend verification -#}
        {%- var serverCa = ingress | dig("metadata", "annotations", "haproxy.org/server-ca") | fallback("") | tostring() %}
        {%- if serverCa != "" %}
          {%- var caNs = ns %}
          {%- var caName = serverCa %}
          {%- if strings_contains(serverCa, "/") %}
            {%- var parts = split(serverCa, "/") %}
            {%- caNs = parts[0] %}
            {%- caName = parts[1] %}
          {%- end %}
          {%- var caSecret = resources.secrets.GetSingle(caNs, caName) %}
          {%- if caSecret != nil %}
            {%- var caContent = caSecret | dig("data", "ca.crt") | fallback("") | b64decode() %}
            {%- if caContent != "" %}
              {%- var caFilename = caNs + "-" + caName + "-ca.pem" %}
              {%- var caPath, caRegErr = fileRegistry.Register("file", caFilename, caContent) -%}
              {%- if caRegErr != nil -%}{{ fail("failed to register CA file " + caFilename + ": " + tostring(caRegErr)) }}{%- end -%}
              {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "ssl verify required ca-file " + caPath) %}
            {%- else %}
            # Warning: Secret {{ caNs }}/{{ caName }} missing 'ca.crt' key
            {%- end %}
          {%- else %}
            # Warning: Secret {{ caNs }}/{{ caName }} referenced by haproxy.org/server-ca not found
          {%- end %}
        {%- end %}

        {#- server-crt: Client certificate for mTLS -#}
        {%- var serverCrt = ingress | dig("metadata", "annotations", "haproxy.org/server-crt") | fallback("") | tostring() %}
        {%- if serverCrt != "" %}
          {%- var crtNs = ns %}
          {%- var crtName = serverCrt %}
          {%- if strings_contains(serverCrt, "/") %}
            {%- var parts = split(serverCrt, "/") %}
            {%- crtNs = parts[0] %}
            {%- crtName = parts[1] %}
          {%- end %}
          {%- var crtSecret = resources.secrets.GetSingle(crtNs, crtName) %}
          {%- if crtSecret != nil %}
            {%- var tlsCrt = crtSecret | dig("data", "tls.crt") | fallback("") | b64decode() %}
            {%- var tlsKey = crtSecret | dig("data", "tls.key") | fallback("") | b64decode() %}
            {%- if tlsCrt != "" && tlsKey != "" %}
              {%- var combinedPem = tlsCrt + "\n" + tlsKey %}
              {%- var crtFilename = crtNs + "-" + crtName + "-client.pem" %}
              {%- var _, crtRegErr = fileRegistry.Register("cert", crtFilename, combinedPem) -%}
              {%- if crtRegErr != nil -%}{{ fail("failed to register client cert " + crtFilename + ": " + tostring(crtRegErr)) }}{%- end -%}
              {#- Use just filename - HAProxy's crt-base directive resolves the full path -#}
              {%- serverOpts["flags"] = append(serverOpts["flags"].([]any), "crt " + crtFilename) %}
            {%- else %}
            # Warning: Secret {{ crtNs }}/{{ crtName }} missing 'tls.crt' or 'tls.key' keys
            {%- end %}
          {%- else %}
            # Warning: Secret {{ crtNs }}/{{ crtName }} referenced by haproxy.org/server-crt not found
          {%- end %}
        {%- end %}

        {#- scale-server-slots -#}
        {%- var serverSlots = ingress | dig("metadata", "annotations", "haproxy.org/scale-server-slots") | fallback("") | tostring() %}
        {%- if serverSlots != "" %}
          {%- var val = toint(serverSlots) %}
          {%- if val <= 0 %}
            {{- fail("Invalid value '" + serverSlots + "' for annotation 'haproxy.org/scale-server-slots' on Ingress '" + key + "'. Must be a positive integer.") -}}
          {%- end %}
          {%- serverOpts["serverSlotsValue"] = val %}
        {%- end %}

        {#- backend-config-snippet: Raw HAProxy backend directives -#}
        {%- var snippet = ingress | dig("metadata", "annotations", "haproxy.org/backend-config-snippet") | fallback("") %}
        {%- if snippet != "" %}
      # haproxytech/backend-config-snippet
      {{ snippet }}
        {%- end %}
      {%- end -%}

  # ============================================================================
  # Features and Backends
  # ============================================================================

  features-100-haproxytech-ssl-passthrough:
    template: |
      {#- Register SSL passthrough backends with global feature registry. -#}
      {{ render "util-haproxytech-ssl-passthrough" }}
      {%- var gf = shared.Get("globalFeatures").(map[string]any) %}
      {%- var sslBackends = gf | dig("sslPassthroughBackends") %}
      {%- if sslBackends != nil %}
        {%- var htVal, _ = shared.ComputeIfAbsent("haproxytech_sslPassthrough", func() any { return nil }) %}
        {%- if htVal != nil %}
          {%- var haproxytechBackends = htVal.(map[string]any)["backends"].([]any) %}
          {%- for _, backend := range haproxytechBackends %}
            {%- gf["sslPassthroughBackends"] = append(gf["sslPassthroughBackends"].([]any), backend) %}
          {%- end %}
        {%- end %}
      {%- end %}

  backends-501-haproxytech-ssl-passthrough:
    template: |
      {#- Generate SSL passthrough backends from Ingress resources -#}
      {%- import "util-backend-servers" for BackendServers -%}
      {{ render "util-haproxytech-ssl-passthrough" }}
      {%- var htVal, _ = shared.ComputeIfAbsent("haproxytech_sslPassthrough", func() any { return nil }) %}
      {%- if htVal == nil %}{% return %}{% end %}
      {%- var sslData = htVal.(map[string]any) %}
      {%- var backends = sslData["backends"].([]any) %}
      {%- for _, backendInfo := range backends %}
        {%- var info = backendInfo.(map[string]any) %}
        {%- var beNs = info["namespace"] | tostring() %}
        {%- var beIngress = info["ingress"] | tostring() %}
        {%- var beName = info["name"] | tostring() %}
        {%- if first_seen("sslPassthrough_backend", beNs + "/" + beIngress) %}
          {%- var ingress = resources.ingresses.GetSingle(beNs, beIngress) %}
          {%- var generated = false %}
          {%- for _, rule := range ingress | dig("spec", "rules") | fallback([]any{}) %}
            {%- if !generated %}
              {%- var http = rule | dig("http") %}
              {%- if http != nil %}
                {%- for _, path := range http | dig("paths") | fallback([]any{}) %}
                  {%- if !generated %}
                    {%- var svcName = path | dig("backend", "service", "name") | fallback("") | tostring() %}
                    {%- var svcPort = path | dig("backend", "service", "port", "number") | fallback(path | dig("backend", "service", "port", "name")) | toint() %}
      # haproxytech/backends-haproxytech-ssl-passthrough

      backend {{ beName }}
          mode tcp
          balance roundrobin
          {{ BackendServers(svcName, 10, svcPort, nil, nil, beName) | indent(4) }}
                    {%- generated = true %}
                  {%- end %}
                {%- end %}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}

# ============================================================================
# Validation Tests
# ============================================================================

validationTests:
  test-auth-basic-cross-namespace:
    description: Basic authentication with secret in different namespace
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: auth-system
            name: shared-auth
          type: Opaque
          data:
            admin: JDJ5JDA1JG1OMVdWazVRbmJnNFF3ZEFkWGJmei44YjNjZUg2UTVLT1ZDS3hSMklrTkFmSmdMaTVwSUtX
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: production
            name: api-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: auth-system/shared-auth
          spec:
            rules:
              - host: api.production.example.com
                http:
                  paths:
                    - path: /api
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 443
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: production
            name: api-service
          spec:
            ports:
              - port: 443
                targetPort: 8443
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-xyz789
            namespace: production
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.1.5"]
              targetRef:
                kind: Pod
                name: api-pod-1
          ports:
            - port: 8443
              protocol: TCP
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid
      - type: contains
        target: haproxy.cfg
        pattern: "userlist auth_auth-system_shared-auth"
        description: Must generate userlist named auth_{secretNamespace}_{secretName}
      - type: contains
        target: haproxy.cfg
        pattern: "user admin password"
        description: User entries must have password
      - type: contains
        target: haproxy.cfg
        pattern: "http_auth\\(auth_auth-system_shared-auth\\)"
        description: Backend must use http_auth with per-secret userlist

  test-auth-custom-realm:
    description: Basic authentication with custom realm
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: api-auth
          type: Opaque
          data:
            apiuser: JDJ5JDA1JDJlV1VoQVU5Z0VlZ2FDZkY4Uk4xZHV1WUNrdlhoUGtpS1BDL3pkTFBvN2xNYlkxcWlUQXRP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: secure-api-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: api-auth
              haproxy.org/auth-realm: "API-Access"
          spec:
            rules:
              - host: secure-api.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 8080
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: api-service
          spec:
            ports:
              - port: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-def456
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.2.10"]
              targetRef:
                kind: Pod
                name: api-pod-2
          ports:
            - port: 8080
              protocol: TCP
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid
      - type: contains
        target: haproxy.cfg
        pattern: 'http-request auth realm "API-Access"'
        description: Backend must use custom auth realm
      - type: not_contains
        target: haproxy.cfg
        pattern: 'realm "RestrictedArea"'
        description: Must not use default realm when custom realm specified

  test-auth-realm-with-spaces-strict:
    description: Auth realm with spaces fails in strict mode (default)
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: api-auth
          type: Opaque
          data:
            user1: JDJ5JDA1JDJlV1VoQVU5Z0VlZ2FDZkY4Uk4xZHV1WUNrdlhoUGtpS1BDL3pkTFBvN2xNYlkxcWlUQXRP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: space-realm-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: api-auth
              haproxy.org/auth-realm: "DeepL demo"
          spec:
            rules:
              - host: api.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: api-service
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
    assertions:
      - type: contains
        target: rendering_error
        pattern: "realm cannot contain spaces"
        description: Must fail with clear error about spaces in realm

  test-auth-realm-with-spaces-sanitize:
    description: Auth realm with spaces auto-sanitized when sanitize_auth_realm=true
    extraContext:
      sanitize_auth_realm: true
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: api-auth
          type: Opaque
          data:
            user1: JDJ5JDA1JDJlV1VoQVU5Z0VlZ2FDZkY4Uk4xZHV1WUNrdlhoUGtpS1BDL3pkTFBvN2xNYlkxcWlUQXRP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: space-realm-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: api-auth
              haproxy.org/auth-realm: "DeepL demo"
          spec:
            rules:
              - host: api.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: api-service
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid
      - type: contains
        target: haproxy.cfg
        pattern: 'http-request auth realm "DeepL-demo"'
        description: Realm must have spaces replaced with dashes

  test-auth-per-secret-userlists:
    description: Ingresses sharing the same secret share the same userlist (deduplication for performance)
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: shared-credentials
          type: Opaque
          data:
            admin: JDJ5JDA1JG1OMVdWazVRbmJnNFF3ZEFkWGJmei44YjNjZUg2UTVLT1ZDS3hSMklrTkFmSmdMaTVwSUtX
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: app1-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: shared-credentials
          spec:
            rules:
              - host: app1.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: app1-service
                          port:
                            number: 80
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: app2-ingress
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: shared-credentials
          spec:
            rules:
              - host: app2.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: app2-service
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: app1-service
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: app2-service
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app1-service-aaa111
            namespace: default
            labels:
              kubernetes.io/service-name: app1-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.3.20"]
              targetRef:
                kind: Pod
                name: app1-pod-1
          ports:
            - port: 80
              protocol: TCP
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app2-service-bbb222
            namespace: default
            labels:
              kubernetes.io/service-name: app2-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.3.21"]
              targetRef:
                kind: Pod
                name: app2-pod-1
          ports:
            - port: 80
              protocol: TCP
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid
      - type: contains
        target: haproxy.cfg
        pattern: "userlist auth_default_shared-credentials"
        description: Both ingresses share the same userlist based on secret reference
      - type: not_contains
        target: haproxy.cfg
        pattern: "userlist default-app1-ingress"
        description: Must NOT generate per-ingress userlists
      - type: not_contains
        target: haproxy.cfg
        pattern: "userlist default-app2-ingress"
        description: Must NOT generate per-ingress userlists
      - type: contains
        target: haproxy.cfg
        pattern: "http_auth\\(auth_default_shared-credentials\\)"
        description: Both backends use http_auth with shared userlist

  test-load-balance-hdr-parameter:
    description: Load balance with hdr(header-name) parameter for header-based routing
    fixtures:
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: sticky-ingress
            annotations:
              haproxy.org/load-balance: "hdr(x-session-id)"
          spec:
            rules:
              - host: api.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: api-service
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc123
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses:
                - 10.0.0.1
              conditions:
                ready: true
              targetRef:
                kind: Pod
                name: api-pod-1
          ports:
            - port: 8080
              protocol: TCP
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid
      - type: contains
        target: haproxy.cfg
        pattern: "balance hdr\\(x-session-id\\)"
        description: Must use hdr() balance algorithm with header name

  test-haproxytech-cors-regex-anchor:
    description: CORS origin with regex $ anchor must not cause HAProxy parse error
    fixtures:
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: cors-regex-ingress
            annotations:
              haproxy.org/cors-enable: "true"
              haproxy.org/cors-allow-origin: "^https://(.+\\.)?(dev\\.|test\\.)?example\\.com$"
              haproxy.org/cors-allow-methods: "GET, POST, OPTIONS"
          spec:
            ingressClassName: haproxy
            rules:
              - host: api.example.com
                http:
                  paths:
                    - path: /api
                      pathType: Prefix
                      backend:
                        service:
                          name: api-service
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: api-service
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid with regex $ anchor in CORS origin
      - type: contains
        target: haproxy.cfg
        pattern: "Access-Control-Allow-Origin"
        description: Must set CORS origin header
      - type: contains
        target: haproxy.cfg
        pattern: "com\\$'"
        description: Origin regex must contain the $ anchor followed by closing quote

  test-haproxytech-auth-password-hash-validation-reject:
    description: Password hash validation rejects non-matching hashes
    extraContext:
      password_hash_validation_regex: "^\\$apr1\\$"
      password_hash_validation_error_message: "Bcrypt hashes not allowed"
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: auth-secret
          type: Opaque
          data:
            admin: JDJ5JDEwJGJjcnlwdGhhc2g=
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: auth-test
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: auth-secret
          spec:
            rules:
              - host: test.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: test-svc
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: test-svc
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: test-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: test-svc
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
    assertions:
      - type: contains
        target: rendering_error
        pattern: "Bcrypt hashes not allowed"
        description: Must reject bcrypt hash with custom error message
      - type: contains
        target: rendering_error
        pattern: "admin"
        description: Error must include username
      - type: contains
        target: rendering_error
        pattern: "pattern"
        description: Error must include pattern info

  test-haproxytech-auth-password-hash-validation-allow:
    description: Password hash validation allows matching hashes
    extraContext:
      password_hash_validation_regex: "^\\$2[ayb]\\$"
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          metadata:
            namespace: default
            name: auth-secret
          type: Opaque
          data:
            admin: JDJ5JDA1JG1OMVdWazVRbmJnNFF3ZEFkWGJmei44YjNjZUg2UTVLT1ZDS3hSMklrTkFmSmdMaTVwSUtX
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            namespace: default
            name: auth-test
            annotations:
              haproxy.org/auth-type: basic-auth
              haproxy.org/auth-secret: auth-secret
          spec:
            rules:
              - host: test.example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: test-svc
                          port:
                            number: 80
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            namespace: default
            name: test-svc
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: test-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: test-svc
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid
      - type: contains
        target: haproxy.cfg
        pattern: "user admin password"
        description: User must be in config
