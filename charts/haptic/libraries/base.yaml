# Base Template Library for HAPTIC
#
# Provides resource-agnostic building blocks for HAProxy configuration generation.
# Libraries like ingress.yaml and gateway.yaml extend these primitives via:
#   - Plugin patterns: render_glob "backends-*", "map-host-*", etc.
#   - Composable macros: import and extend utility functions
#
# SSL/TLS infrastructure is in ssl.yaml (loaded separately when needed)

templateSnippets:
  # ============================================================================
  # Core Utility Macros
  # ============================================================================

  util-macros:
    template: |
      {#- Core utility macros for template rendering -#}

      {#- Escapes $ for HAProxy double-quoted contexts (prevents env var expansion) -#}
      {% macro SanitizeRegex(pattern string) string %}
        {%% show replace(pattern, "$", "\\$") %%}
      {% end %}

      {#- Calculates optimal shard count: clamp(count / itemsPerShard, 1, 2*GOMAXPROCS) -#}
      {% macro CalculateShardCount(resourceCount int, itemsPerShard int) string %}
        {%%
          var override = extraContext | dig("shardCountOverride")
          if override != nil {
            show tostring(toint(override))
            return
          }
          var maxShards = runtimeEnvironment.GOMAXPROCS * 2
          if maxShards < 1 { maxShards = 1 }
          var shardCount = resourceCount / itemsPerShard
          if shardCount < 1 { shardCount = 1 }
          if shardCount > maxShards { shardCount = maxShards }
          show tostring(shardCount)
        %%}
      {% end %}


  # ============================================================================
  # Ingress Helpers
  # ============================================================================

  util-ingress-helpers:
    template: |
      {#- Generates HAProxy host match condition: { var(txn.host) -m str host1 } or ... -#}
      {% macro HostMatchCondition(hosts []any) string %}
        {%%
          var parts = []any{}
          for _, host := range hosts {
            parts = append(parts, "{ var(txn.host) -m str " + tostring(host) + " }")
          }
          show join(parts, " or ")
        %%}
      {% end %}

  # ============================================================================
  # Frontend Routing Logic
  # ============================================================================

  frontend-routing-logic:
    template: |-
      {#-
        Path-based routing with qualifier system for backend selection.

        Qualifiers (set by map files, resolved here):
          - BACKEND:<name> → Direct routing to named backend
          - MULTIBACKEND:<weight>:<key> → Weighted routing via weighted-multi-backend.map

        Path Matching Order: Exact > Regex > Prefix-exact > Prefix
        (Override with path-regex-last library for: Exact > Prefix > Regex)

        Extension Points:
          - frontend-matchers-advanced-* → Advanced matchers (method, headers, query)
      -#}
      {%- var mapPath = func(name string) string { p, _ := pathResolver.GetPath(name, "map"); return p } -%}
      # base/frontend-routing-logic

      # Host and path extraction
      http-request set-var(txn.base) base
      http-request set-var(txn.path) path
      http-request set-var(txn.host) req.hdr(Host),field(1,:),lower
      http-request set-var(txn.host_match) var(txn.host),map({{ mapPath("host.map") }})
      http-request set-var(txn.host_match) var(txn.host),regsub(^[^.]*,,),map({{ mapPath("host.map") }},'') if !{ var(txn.host_match) -m found }

      # Path matching: Exact > Regex > Prefix-exact > Prefix
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ mapPath("path-exact.map") }})
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_reg({{ mapPath("path-regex.map") }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ mapPath("path-prefix-exact.map") }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_beg({{ mapPath("path-prefix.map") }}) if !{ var(txn.path_match) -m found }

      # Parse qualifier type
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # Extension point: advanced matchers (method/header/query)
      {{- render_glob "frontend-matchers-advanced-*" }}
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # MULTIBACKEND: weighted routing via random selection
      http-request set-var(txn.total_weight) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.random_weight) rand(),mod(txn.total_weight) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.route_key) var(txn.path_match),field(3,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.lookup_key) var(txn.random_weight),concat(:,txn.route_key,) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.backend_name) var(txn.lookup_key),map({{ mapPath("weighted-multi-backend.map") }}) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }

      # BACKEND: direct routing
      http-request set-var(txn.backend_name) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str BACKEND }

  # ============================================================================
  # Backend Server Generation
  # ============================================================================

  # ----------------------------------------------------------------------------
  # Backend Server Generation - Helper Macros
  # ----------------------------------------------------------------------------

  util-backend-servers-helpers:
    template: |
      {#-
        Helper macros for BackendServers. Import these using:
          {% import "util-backend-servers-helpers" for BuildServerOptions %}
      -#}

      {#- Builds the HAProxy server options string (flags, maxconn).
          Called inline in server line output.
      -#}
      {% macro BuildServerOptions(serverOpts map[string]any) %}
        {%- var opts = "" -%}
        {%- var flags = serverOpts | dig("flags") | toSlice() -%}
        {%- if len(flags) > 0 -%}
          {%- opts = " " + join(toStringSlice(flags), " ") -%}
        {%- end -%}
        {%- if maxconn := serverOpts | dig("podMaxconnValue"); maxconn != nil -%}
          {%- opts = opts + " maxconn " + tostring(maxconn) -%}
        {%- end -%}
        {{- opts -}}
      {% end %}

  # ----------------------------------------------------------------------------
  # Backend Server Generation - Main Macro
  # ----------------------------------------------------------------------------

  util-backend-servers:
    template: |
      {#-
        BackendServers - Generates HAProxy server lines from Kubernetes EndpointSlices.

        This macro handles the complete flow:
        1. Resolve server slot count from parameters or defaults
        2. Look up the Service to find port name (for targetPort resolution)
        3. Fetch EndpointSlices and resolve actual pod ports
        4. Build slot assignment map from current config (if available)
        5. Assign endpoints to slots, preserving existing assignments
        6. Generate server lines with proper options

        Slot Preservation (Zero-Reload Updates):
        When currentConfig is available, the macro looks up the existing backend
        and preserves server slot assignments during rolling deployments. This
        enables zero-reload updates via HAProxy runtime API by keeping the same
        SRV_N slot for each pod IP:port combination across config changes.

        Parameters:
          serviceName    - Service name to look up endpoints
          maxServerSlots - Max slots (0 = use serverOpts.serverSlotsValue or default 10)
          port           - Service port number (may differ from pod port via targetPort)
          serverOpts     - Options map:
                             .serverSlotsValue - override slot count
                             .flags[]          - server flags (e.g., "backup", "weight 10")
                             .podMaxconnValue  - per-server maxconn
          portName       - Port name for targetPort resolution (nil = auto-lookup)
          backendName    - HAProxy backend name for slot preservation (nil = disabled)

        Example:
          {{ BackendServers("my-service", 0, 80, serverOpts, nil, "ing_default_my-ingress_my-service_80") }}

        Output:
          server SRV_1 10.0.0.1:8080 check  # Pod: my-pod-abc
          server SRV_2 10.0.0.2:8080 check  # Pod: my-pod-def
          server SRV_3 127.0.0.1:1 disabled  # Placeholder
          ...
      -#}
      {% import "util-backend-servers-helpers" for BuildServerOptions %}
      {% macro BackendServers(serviceName string, maxServerSlots int, port int, serverOpts map[string]any, portName any, backendName any) %}
        {%%
          // ── 1. Resolve server slot count ──────────────────────────────────
          // Priority: maxServerSlots param > serverOpts.serverSlotsValue > default (10)
          var slots = 10
          if maxServerSlots > 0 {
            slots = maxServerSlots
          } else if v := serverOpts | dig("serverSlotsValue"); v != nil {
            slots = toint(v)
          }

          // ── 2. Get port name for targetPort resolution ────────────────────
          // If provided as parameter, use it. Otherwise, look it up below.
          var pn = ""
          if portName != nil && tostring(portName) != "" {
            pn = tostring(portName)
          }

          // ── 3. Fetch EndpointSlices for the service ───────────────────────
          var allSlices = resources.endpoints.Fetch(serviceName)

          // ── 4. Look up port name from Service if not provided ─────────────
          // This enables targetPort resolution (service port → pod port)
          if pn == "" && len(allSlices) > 0 {
            var ns = allSlices[0] | dig("metadata", "namespace") | fallback("")
            if ns != "" {
              var svc = resources.services.GetSingle(tostring(ns), serviceName)
              if svc != nil {
                for _, sp := range svc | dig("spec", "ports") | toSlice() {
                  if toint(sp | dig("port") | fallback(0)) == port {
                    pn = tostring(sp | dig("name") | fallback(""))
                    break
                  }
                }
              }
            }
          }

          // ── 5. Collect endpoints with resolved ports ──────────────────────
          var endpoints = []any{}
          for _, slice := range allSlices {
            // Resolve pod port from EndpointSlice's ports array
            var slicePorts = slice | dig("ports") | toSlice()
            var resolvedPort = port  // Default: use service port

            if pn != "" {
              // Look up port by name
              for _, p := range slicePorts {
                if tostring(p | dig("name") | fallback("")) == pn {
                  resolvedPort = toint(p | dig("port") | fallback(port))
                  break
                }
              }
            } else if len(slicePorts) == 1 {
              // Single port case: use it directly (common scenario)
              resolvedPort = toint(slicePorts[0] | dig("port") | fallback(port))
            }
            // Note: If multiple ports exist but no name available,
            // we use the service port as fallback.

            // Collect addresses from this slice
            for _, ep := range slice | dig("endpoints") | toSlice() {
              for _, addr := range ep | dig("addresses") | toSlice() {
                var name = ep | dig("targetRef", "name") | fallback(addr)
                endpoints = append(endpoints, map[string]any{
                  "name": name, "address": addr, "port": resolvedPort,
                })
              }
            }
          }

          // ── 6. Build slot assignment map from current config ──────────────
          // Maps address:port → slot number (1-based) from existing config.
          // Enables slot preservation during rolling deployments for zero-reload updates.
          var existingSlots = map[string]int{}
          var usedSlots = map[int]bool{}
          var bkName = ""
          if backendName != nil {
            bkName = tostring(backendName)
          }
          if bkName != "" && !isNil(currentConfig) {
            for _, backend := range currentConfig.Backends {
              if backend.Name == bkName {
                // Found the backend - extract server slot assignments
                for serverName, server := range backend.Servers {
                  // Extract slot number from server name (e.g., "SRV_1" → 1)
                  if hasPrefix(serverName, "SRV_") {
                    var slotStr = serverName[4:]
                    var slotNum = toint(slotStr)
                    if slotNum > 0 && slotNum <= slots {
                      // Skip placeholders (127.0.0.1:1)
                      if server.Address != "127.0.0.1" || (server.Port != nil && *server.Port != 1) {
                        var key = server.Address + ":" + tostring(*server.Port)
                        existingSlots[key] = slotNum
                        usedSlots[slotNum] = true
                      }
                    }
                  }
                }
                break
              }
            }
          }

          // ── 7. Assign endpoints to slots with preservation ────────────────
          // First pass: assign endpoints that have existing slots
          // Second pass: assign remaining endpoints to free slots
          var slotAssignments = map[int]map[string]any{}  // slot → endpoint
          var unassignedEndpoints = []any{}

          // First pass: preserve existing slot assignments
          for _, ep := range endpoints {
            var epMap = ep.(map[string]any)
            var key = tostring(epMap["address"]) + ":" + tostring(epMap["port"])
            if slot, ok := existingSlots[key]; ok {
              slotAssignments[slot] = epMap
            } else {
              unassignedEndpoints = append(unassignedEndpoints, ep)
            }
          }

          // Second pass: assign unassigned endpoints to free slots
          var nextFreeSlot = 1
          for _, ep := range unassignedEndpoints {
            // Find next free slot
            for nextFreeSlot <= slots && slotAssignments[nextFreeSlot] != nil {
              nextFreeSlot++
            }
            if nextFreeSlot <= slots {
              slotAssignments[nextFreeSlot] = ep.(map[string]any)
              nextFreeSlot++
            }
          }
        %%}
      {#- ── 8. Generate server lines ────────────────────────────────────── -#}
      {%- for i := 1; i <= slots; i++ %}
      {%- if ep := slotAssignments[i]; ep != nil %}
      server SRV_{{ i }} {{ ep["address"] }}:{{ ep["port"] }} enabled  # Pod: {{ ep["name"] }}
      {% else %}
      server SRV_{{ i }} 127.0.0.1:1 disabled  # Placeholder
      {% end %}
      {% end %}
      {% end %}
  # ============================================================================
  # Extension Points
  # ============================================================================

  global-top:
    template: |
      {#- Renders global-top-* snippets (e.g., userlist sections from haproxytech.yaml) -#}
      {{- render_glob "global-top-*" -}}

# ============================================================================
# Map Files
# ============================================================================
# Map files provide host and path routing tables.
# Resource libraries populate these via map-*-* snippets.

maps:
  host.map:
    template: |
      # Host to normalized host mapping (strips port, wildcards)
      {{- render_glob "map-host-*" -}}

  path-exact.map:
    template: |
      # Exact path matches (use with map() function)
      {{ render_glob "map-path-exact-*" -}}

  path-prefix-exact.map:
    template: |
      # Prefix boundary matches without trailing slash
      {{ render_glob "map-path-prefix-exact-*" -}}

  path-prefix.map:
    template: |
      # Prefix matches with trailing slash (use with map_beg())
      {{ render_glob "map-path-prefix-*" -}}

  path-regex.map:
    template: |
      # Regex matches (use with map_reg())
      {{- render_glob "map-path-regex-*" -}}

  weighted-multi-backend.map:
    template: |
      # Weighted routing: random_weight:route_key → backend_name
      {{- render_glob "map-weighted-backend-*" }}

files:
  400.http:
    template: |
      HTTP/1.0 400 Bad Request
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>400 Bad Request</h1>
      <p>Your browser sent a request that this server could not understand.</p>
      </body></html>

  403.http:
    template: |
      HTTP/1.0 403 Forbidden
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>403 Forbidden</h1>
      <p>You don't have permission to access this resource.</p>
      </body></html>

  408.http:
    template: |
      HTTP/1.0 408 Request Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>408 Request Time-out</h1>
      <p>Your browser didn't send a complete request in time.</p>
      </body></html>

  500.http:
    template: |
      HTTP/1.0 500 Internal Server Error
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>500 Internal Server Error</h1>
      <p>An internal server error occurred.</p>
      </body></html>

  502.http:
    template: |
      HTTP/1.0 502 Bad Gateway
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>502 Bad Gateway</h1>
      <p>The server received an invalid response from an upstream server.</p>
      </body></html>

  503.http:
    template: |
      HTTP/1.0 503 Service Unavailable
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>503 Service Unavailable</h1>
      <p>No server is available to handle this request.</p>
      </body></html>

  504.http:
    template: |
      HTTP/1.0 504 Gateway Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>504 Gateway Time-out</h1>
      <p>The server didn't respond in time.</p>
      </body></html>

haproxyConfig:
  template: |
    global
        log stdout len 4096 local0 info
        daemon
        default-path origin {{ pathResolver.GetBaseDir() }}
        crt-base {{ pathResolver.GetPath("", "cert") }}
        tune.ssl.default-dh-param 2048

    defaults
        mode http
        log global
        option httplog
        option dontlognull
        option log-health-checks
        option forwardfor
        timeout connect 5000
        timeout client 50000
        timeout server 50000
        errorfile 400 {{ pathResolver.GetPath("400.http", "file") }}
        errorfile 403 {{ pathResolver.GetPath("403.http", "file") }}
        errorfile 408 {{ pathResolver.GetPath("408.http", "file") }}
        errorfile 500 {{ pathResolver.GetPath("500.http", "file") }}
        errorfile 502 {{ pathResolver.GetPath("502.http", "file") }}
        errorfile 503 {{ pathResolver.GetPath("503.http", "file") }}
        errorfile 504 {{ pathResolver.GetPath("504.http", "file") }}

    {# Include global top-level snippets (e.g., userlist sections) #}
    {{ render "global-top" }}

    {# Phase 1: Feature Registration #}
    {# Initialize SSL features first (if SSL library is loaded) #}
    {# Uses render_glob since features-ssl-initialization is from optional ssl.yaml library #}
    {{ render_glob "features-ssl-initialization" }}
    {# Let resource libraries scan resources and register infrastructure needs #}
    {{- render_glob "features-*" -}}

    frontend status
        bind *:8404
        no log
        http-request return status 200 content-type text/plain string "OK" if { path /healthz }
        http-request return status 200 content-type text/plain string "READY" if { path /ready }

    frontend http_frontend
        bind *:{{ extraContext | dig("httpPort") | fallback(8080) }}

        {# Include frontend routing logic (can be overridden by libraries) #}
        {{ render "frontend-routing-logic" }}
        # Debug headers (when enabled via templating settings)
        {%- var debug bool = extraContext | dig("debug") | fallback(false) -%}
        {%- if debug %}
        # HAProxy routing decision introspection
        http-response set-header X-HAProxy-Backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }
        http-response set-header X-HAProxy-Host-Match %[var(txn.host_match)] if { var(txn.host_match) -m found }
        http-response set-header X-HAProxy-Path-Match %[var(txn.path_match)] if { var(txn.path_match) -m found }
        http-response set-header X-HAProxy-Path-Match-Qualifier %[var(txn.path_match_qualifier)] if { var(txn.path_match_qualifier) -m found }
        http-response set-header X-HAProxy-Total-Weight %[var(txn.total_weight)] if { var(txn.total_weight) -m found }
        http-response set-header X-HAProxy-Random-Weight %[var(txn.random_weight)] if { var(txn.random_weight) -m found }
        http-response set-header X-HAProxy-Route-Key %[var(txn.route_key)] if { var(txn.route_key) -m found }
        # Gateway-specific headers (set by gateway.yaml advanced matchers)
        http-response set-header X-Gateway-Matched-Route %[var(txn.matched_route)] if { var(txn.matched_route) -m found }
        http-response set-header X-Gateway-Match-Reason %[var(txn.match_reason)] if { var(txn.match_reason) -m found }
        http-response set-header X-Gateway-Filters-Applied %[var(txn.filters_applied)] if { var(txn.filters_applied) -m found }
        {%- end -%}
        {# Extension point for frontend request/response filters #}
        {# Runs AFTER routing decisions, BEFORE backend selection #}
        {# Libraries can inject filter logic here (header modification, redirects, rewrites) #}
        {{- render_glob "frontend-filters-*" }}
        # Use backend from txn.backend_name (set by qualifier logic in "frontend-routing-logic")
        # Falls through to default_backend if backend_name is empty
        use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

        # Default backend
        default_backend default_backend

    {# Extension point for additional frontends (e.g., custom TCP services) #}
    {# Resource libraries can inject frontends-* snippets #}
    {{- render_glob "frontends-*" -}}

    {# Include all resource-specific backend definitions using plugin pattern #}
    {# Resource libraries implement backends-* snippets (e.g., backends-ingress, backends-gateway) #}
    {{- render_glob "backends-*" }}

    backend default_backend
        http-request return status 404
    {# Trailing newline preserved #}

  # Post-processing: Normalize indentation to 2 spaces
  # Applies regex replacement to ensure consistent indentation throughout the config
  postProcessing:
    - type: regex_replace
      params:
        pattern: "^[ ]+"
        replace: "  "

# Global fixtures merged with all validation tests
# Test fixtures override global fixtures when same resource exists (by namespace/name)
# NOTE: SSL certificate fixtures moved to ssl.yaml library
validationTests:
  _global:
    description: Global fixtures for all validation tests (SSL fixtures moved to ssl.yaml)
    fixtures: {}
    assertions:
      - type: haproxy_valid
        description: Base configuration must be valid
      - type: deterministic
        description: Template rendering must be deterministic (identical output on repeated renders)
