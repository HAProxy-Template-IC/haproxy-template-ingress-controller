# Ingress template library for HAProxy Template Ingress Controller
# Provides support for Kubernetes networking.k8s.io/v1 Ingress resources
# Implements the resource_ingress_* plugin interface for the base library

watchedResources:
  ingresses:
    apiVersion: networking.k8s.io/v1
    resources: ingresses
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true
    # Filter by ingress class name (only watches ingresses with matching spec.ingressClassName)
    # Set to empty string ("") to watch all ingresses regardless of class
    fieldSelector: "spec.ingressClassName=haproxy"
  services:
    apiVersion: v1
    resources: services
    indexBy: ["metadata.namespace", "metadata.name"]
  endpoints:
    apiVersion: discovery.k8s.io/v1
    resources: endpointslices
    indexBy: ["metadata.namespace", "metadata.labels.kubernetes\\.io/service-name"]

templateSnippets:
  features-100-ingress-tls:
    template: |
      {#-
        Ingress TLS Certificate Registration

        Purpose: Registers TLS certificates from Ingress spec.tls with SSL infrastructure.

        Extension Point: features-* (priority 100)

        Dependencies:
          - ssl.yaml features-050-ssl-initialization (initializes tlsCertificates array)
          - secrets watchedResource

        Behavior:
          - Scans all Ingress resources for spec.tls entries
          - Fetches referenced TLS Secrets
          - Registers certificate files via fileRegistry.Register()
          - Appends to shared.globalFeatures.tlsCertificates for crt-list generation
          - Deduplicates: each secret registered only once
      -#}
      {#- Register TLS certificates from Ingress spec.tls with SSL infrastructure -#}
      {#- Each TLS entry contains hosts (SNI patterns) and a secretName -#}
      {#- Dynamically generates certificate files using file_registry.Register() -#}
      {#- Deduplication: Only register each secret once even if multiple Ingresses use it -#}
      {%- for _, ingress := range resources.ingresses.List() %}
        {%%
          var tlsList = ingress | dig("spec", "tls")
          if tlsList == nil {
            continue
          }
        %%}
        {%- for _, tls := range tlsList %}
          {%%
            var secretName = tls | dig("secretName")
            if secretName == nil {
              continue
            }
            // Unique key for this secret (namespace + name)
            var namespace = ingress | dig("metadata", "namespace") | fallback("")
            if !first_seen("ingress_tls", namespace, secretName) {
              continue
            }

            // Fetch Secret and extract cert+key
            var secret = resources.secrets.GetSingle(namespace, secretName)
            var secretData = secret | dig("data")
            var tlsCrt = secretData | dig("tls.crt")
            var tlsKey = secretData | dig("tls.key")
            if secretData == nil || tlsCrt == nil || tlsKey == nil {
              continue
            }

            // Combine cert and key into single PEM (HAProxy format)
            var combinedPem = (tlsCrt | b64decode()) + "\n" + (tlsKey | b64decode())

            // Register certificate file dynamically using file_registry
            var certFilename = tostring(namespace) + "_" + tostring(secretName) + ".pem"
            var _, certRegErr = fileRegistry.Register("cert", certFilename, combinedPem)
            if certRegErr != nil {
              fail("failed to register certificate " + certFilename + ": " + tostring(certRegErr))
            }

            // Register with SSL infrastructure for crt-list generation
            var tlsCert = map[string]any{
              "secret_namespace": namespace,
              "secret_name": secretName,
              "sni_patterns": tls | dig("hosts") | fallback([]any{}),
            }
            shared["globalFeatures"].(map[string]any)["tlsCertificates"] = append(shared["globalFeatures"].(map[string]any)["tlsCertificates"].([]any), tlsCert)
          %%}
        {%- end %}
      {%- end %}

  util-backend-name-ingress:
    template: |
      {#-
        Ingress Backend Name Generator

        Purpose: Generates consistent backend names for Ingress resources.

        Provides:
          - BackendNameIngress(ingress, path) macro

        Naming Pattern:
          ing_<namespace>_<ingress-name>_<service-name>_<port>

        Usage:
          {% import "util-backend-name-ingress" for BackendNameIngress %}
          {{ BackendNameIngress(ingress, path) }}
      -#}

      {% macro BackendNameIngress(ingress any, path any) string %}{%%
        var namespace = tostring(ingress | dig("metadata", "namespace") | fallback(""))
        var name = tostring(ingress | dig("metadata", "name") | fallback(""))
        var serviceName = tostring(path | dig("backend", "service", "name") | fallback(""))
        var portIdentifier = (path | dig("backend", "service", "port", "name")) | fallback(path | dig("backend", "service", "port", "number") | fallback(""))
        show "ing_" + namespace + "_" + name + "_" + serviceName + "_" + tostring(portIdentifier)
      %%}{% end %}

  util-path-map-entry-ingress-shard:
    template: |
      {#-
        Ingress Path Map Entry Shard Processor

        Purpose: Generates map file entries for a slice of Ingress resources.
        This is the inner macro used by sharding - accepts ingresses as parameter.

        Provides:
          - PathMapEntryIngressShard(ingresses, pathTypes, suffix) macro
      -#}
      {%- import "util-backend-name-ingress" for BackendNameIngress -%}

      {% macro PathMapEntryIngressShard(ingresses []any, pathTypes []string, suffix string) string %}
        {%- for _, ingress := range ingresses %}
        {%- var rules = ingress | dig("spec", "rules") | fallback([]any{}) %}
        {%- var allPaths = []any{} %}
        {%- for _, rule := range rules %}
        {%- var http = rule | dig("http") %}
        {%- if http != nil %}
        {%- var paths = http | dig("paths") | fallback([]any{}) %}
        {%- for _, path := range paths %}
        {%- var pathValue = path | dig("path") %}
        {%- if pathValue != nil %}
        {%- var pathType = path | dig("pathType") | fallback("") %}
        {%- for _, checkType := range pathTypes %}
        {%- if pathType == checkType %}
        {%- allPaths = append(allPaths, path) %}
        {%- end %}
        {%- end %}
        {%- end %}
        {%- end %}
        {%- end %}
        {%- end %}
        {%- if len(allPaths) > 0 %}
      # Ingress: {{ ingress | dig("metadata", "namespace") | fallback("") }}/{{ ingress | dig("metadata", "name") | fallback("") }} ({{ len(allPaths) }} paths)
        {% for _, rule := range rules -%}
        {%- var http = rule | dig("http") -%}
        {%- if http != nil -%}
        {%- var paths = http | dig("paths") | fallback([]any{}) -%}
        {%- for _, path := range paths -%}
        {%- var pathValue = path | dig("path") -%}
        {%- if pathValue != nil -%}
        {%- var pathType = path | dig("pathType") | fallback("") -%}
        {%- for _, checkType := range pathTypes -%}
        {%- if pathType == checkType %}
      #   - {{ rule | dig("host") | fallback("") }}{{ pathValue }} → {{ path | dig("backend", "service", "name") | fallback("") }}:{{ (path | dig("backend", "service", "port", "number")) | fallback(path | dig("backend", "service", "port", "name") | fallback("")) }}
        {% end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end %}
        {% for _, rule := range rules -%}
        {%- var http = rule | dig("http") -%}
        {%- if http != nil -%}
        {%- var paths = http | dig("paths") | fallback([]any{}) -%}
        {%- for _, path := range paths -%}
        {%- var pathValue = path | dig("path") -%}
        {%- if pathValue != nil -%}
        {%- var pathType = path | dig("pathType") | fallback("") -%}
        {%- for _, checkType := range pathTypes -%}
        {%- if pathType == checkType %}
        {%- var pathStr = pathValue | tostring() -%}
        {%- var actualSuffix = suffix -%}
        {%- if suffix == "/" && hasSuffix(pathStr, "/") -%}
          {%- actualSuffix = "" -%}
        {%- end %}
      {{ rule | dig("host") | fallback("") }}{{ pathStr }}{{ actualSuffix }} BACKEND:{{ BackendNameIngress(ingress, path) }}
        {% end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end %}
      {% end %}

  util-sharded-path-map-entry-ingress:
    template: |
      {#-
        Sharded Ingress Path Map Entry Generator

        Purpose: Wraps PathMapEntryIngressShard with parallel sharding logic.

        Provides:
          - ShardedPathMapEntryIngress(pathTypes, suffix) macro

        Parameters:
          - pathTypes ([]string): List of pathTypes to include
          - suffix (string): Suffix to append to paths

        Usage:
          {% import "util-sharded-path-map-entry-ingress" for ShardedPathMapEntryIngress %}
          {{ ShardedPathMapEntryIngress([]string{"Exact"}, "") }}
      -#}
      {%- import "util-path-map-entry-ingress-shard" for PathMapEntryIngressShard -%}
      {%- import "util-macros" for CalculateShardCount -%}

      {% macro ShardedPathMapEntryIngress(pathTypes []string, suffix string) string %}
      {%- var allIngresses = resources.ingresses.List() -%}
      {%- var n = toint(CalculateShardCount(len(allIngresses), 100)) -%}
      {%- if n <= 1 || len(allIngresses) < 100 -%}
      {{ PathMapEntryIngressShard(allIngresses, pathTypes, suffix) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go PathMapEntryIngressShard(shard_slice(allIngresses, i, n), pathTypes, suffix) }}
      {%- end -%}
      {%- end -%}
      {% end %}

  util-path-map-entry-ingress:
    template: |
      {#-
        Ingress Path Map Entry Generator (Compatibility Wrapper)

        Purpose: Provides backward-compatible PathMapEntryIngress macro.
        Internally uses the sharded implementation.

        Provides:
          - PathMapEntryIngress(pathTypes, suffix) macro
      -#}
      {%- import "util-sharded-path-map-entry-ingress" for ShardedPathMapEntryIngress -%}

      {% macro PathMapEntryIngress(pathTypes []string, suffix string) string %}
      {{ ShardedPathMapEntryIngress(pathTypes, suffix) }}
      {% end %}

  backends-500-ingress:
    template: |
      {#-
        Ingress Backend Definitions

        Purpose: Generates HAProxy backend sections for all Ingress resources.

        Extension Point: backends-* (priority 500)

        Dependencies:
          - util-backend-name-ingress
          - util-backend-servers (from base.yaml)
          - backend-directives-* (extension point for haproxytech annotations)

        Behavior:
          - Iterates all Ingress resources
          - Generates one backend per unique service+port combination
          - Deduplicates: multiple paths to same service+port share one backend
          - Injects backend-directives-* snippets for annotations (load balancing, timeouts, etc.)

        Parallel Sharding:
          - Shard count is auto-calculated: clamp(resourceCount / 300, 1, 2 * GOMAXPROCS)
          - Override by setting extraContext.shardCountOverride
          - When shardCount > 1, work is split across parallel shards using go MacroName()
          - Each shard processes a subset of ingresses
          - Deduplication via first_seen() is thread-safe (uses sync.Map)
      -#}
      {%- import "util-backend-name-ingress" for BackendNameIngress -%}
      {%- import "util-backend-servers" for BackendServers -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {#- Macro to process a slice of ingresses (used by both sequential and parallel paths) -#}
      {% macro BackendsIngressShard(ingresses []any) string %}
        {%- for _, ingress := range ingresses -%}
        {%- var rules = ingress | dig("spec", "rules") %}
        {%- if rules != nil %}
        {%- for _, rule := range rules -%}
        {%- var httpPaths = rule | dig("http", "paths") %}
        {%- if httpPaths != nil %}
        {%- for _, path := range httpPaths -%}
        {%- var service = path | dig("backend", "service") %}
        {%- if service != nil %}
        {%- var serviceName = service | dig("name") | fallback("") -%}
        {%- var port = service | dig("port", "number") | fallback(80) -%}
        {#- Deduplication: first_seen checks if this backend was already generated -#}
        {%- var portIdentifier = (service | dig("port", "name")) | fallback(service | dig("port", "number") | fallback("")) -%}
        {%- if first_seen("ingress_backend", ingress | dig("metadata", "namespace"), ingress | dig("metadata", "name"), serviceName, portIdentifier) -%}
      # Backend for: Ingress {{ ingress | dig("metadata", "namespace") | fallback("") }}/{{ ingress | dig("metadata", "name") | fallback("") }} → Service {{ serviceName }}:{{ port }}
      backend {{ BackendNameIngress(ingress, path) }}
        balance roundrobin
        option httpchk GET {{ path | dig("path") | fallback("/") }}
        default-server check
        {#- Initialize server options map before backend-directives can append to it -#}
        {%- var serverOpts = map[string]any{"flags": []any{}} %}
        {{- render_glob "backend-directives-*" inherit_context }}
        {{ BackendServers(tostring(serviceName), 0, toint(port), serverOpts) }}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
        {%- end -%}
      {% end %}
      {#- Get sharding configuration (auto-calculated based on resource count and GOMAXPROCS) -#}
      {%- var allIngresses = resources.ingresses.List() %}
      {%- var shardCount = toint(CalculateShardCount(len(allIngresses), 100)) %}
      {%- if len(allIngresses) > 0 %}
      # ingress/backends-ingress
      {%- end %}
      {%- if shardCount <= 1 || len(allIngresses) < 100 %}
      {#- Sequential execution: process all ingresses in a single pass -#}
      {{ BackendsIngressShard(allIngresses) }}
      {%- else %}
      {#- Parallel execution: split work across shards using go MacroName() -#}
      {%- for shardIdx := 0; shardIdx < shardCount; shardIdx++ %}
      {{ go BackendsIngressShard(shard_slice(allIngresses, shardIdx, shardCount)) }}
      {%- end %}
      {%- end -%}
  util-generate-host-map-ingress:
    template: |
      {#- Macro to generate host map entries for Ingress resources -#}
      {%- macro GenerateIngressHostMap(ingresses []any) -%}
      {%- for _, ingress := range ingresses -%}
      {%- var rules = ingress | dig("spec", "rules") | fallback([]any{}) %}
      {%- var rulesWithHttp = selectattr(rules, "http") %}
      {%- if len(rulesWithHttp) > 0 %}
      # Ingress: {{ ingress | dig("metadata", "namespace") | fallback("") }}/{{ ingress | dig("metadata", "name") | fallback("") }} ({{ len(rulesWithHttp) }} hosts)
      {% for _, rule := range rulesWithHttp %}
      {%- var hostWithoutAsterisk = tostring(rule | dig("host") | fallback("")) | replace("*", "") %}
      {{ hostWithoutAsterisk }} {{ hostWithoutAsterisk }}
      {% end %}
      {%- end %}
      {%- end %}
      {%- end macro -%}

  util-sharded-host-map-ingress:
    template: |
      {#- Sharded host map generator for Ingress resources -#}
      {%- import "util-generate-host-map-ingress" for GenerateIngressHostMap -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedIngressHostMap(ingresses []any) -%}
      {%- var n = toint(CalculateShardCount(len(ingresses), 100)) -%}
      {%- if n <= 1 || len(ingresses) < 100 -%}
      {{ GenerateIngressHostMap(ingresses) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GenerateIngressHostMap(shard_slice(ingresses, i, n)) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  map-host-500-ingress:
    template: |
      {#- Generate host map entries for Ingress resources (wildcards converted to suffix form) -#}
      {%- import "util-sharded-host-map-ingress" for ShardedIngressHostMap %}
      {%- var allIngresses = resources.ingresses.List() %}
      {%- if len(allIngresses) > 0 %}
      # ingress/map-host-ingress
      {{ ShardedIngressHostMap(allIngresses) }}
      {%- end -%}

  map-path-exact-500-ingress:
    template: |
      {#-
        Ingress Exact Path Map Entries

        Purpose: Generates path-exact.map entries for Ingress exact path matching.

        Extension Point: map-path-exact-* (priority 500)

        Matches: Ingress paths with pathType: Exact
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-exact-ingress
      {{ PathMapEntryIngress([]string{"Exact"}, "") }}

  map-path-prefix-exact-500-ingress:
    template: |
      {#-
        Ingress Prefix-Exact Path Map Entries

        Purpose: Generates path-prefix-exact.map entries for exact prefix boundary matching.

        Extension Point: map-path-prefix-exact-* (priority 500)

        Matches: Ingress paths with pathType: Prefix or ImplementationSpecific
        Note: No trailing slash - matches exact path for prefix boundary check.
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-prefix-exact-ingress
      {{ PathMapEntryIngress([]string{"Prefix", "ImplementationSpecific"}, "") }}

  map-path-prefix-500-ingress:
    template: |
      {#-
        Ingress Prefix Path Map Entries

        Purpose: Generates path-prefix.map entries for prefix path matching.

        Extension Point: map-path-prefix-* (priority 500)

        Matches: Ingress paths with pathType: Prefix or ImplementationSpecific
        Note: Adds trailing slash for HAProxy map_beg matching.
      -#}
      {%- import "util-path-map-entry-ingress" for PathMapEntryIngress -%}
      # ingress/map-path-prefix-ingress
      {{ PathMapEntryIngress([]string{"Prefix", "ImplementationSpecific"}, "/") }}

validationTests:
  test-ingress-duplicate-backend-different-ports:
    description: Ingress with multiple paths to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-svc
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: admin
                port: 81
                targetPort: 8081
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-svc-abc123
            namespace: default
            labels:
              kubernetes.io/service-name: api-svc
          addressType: IPv4
          endpoints:
            - addresses:
                - "10.0.0.1"
              targetRef:
                kind: Pod
                name: api-pod-1
          ports:
            - name: http
              port: 8080
              protocol: TCP
            - name: admin
              port: 8081
              protocol: TCP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: multi-port
            namespace: default
          spec:
            ingressClassName: haproxy
            rules:
              - host: example.com
                http:
                  paths:
                    - path: /api
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 80
                    - path: /admin
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 81
                    - path: /app
                      pathType: Prefix
                      backend:
                        service:
                          name: api-svc
                          port:
                            number: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_80"
        description: Must generate backend for port 80

      - type: contains
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_81"
        description: Must generate backend for port 81

      - type: match_count
        target: haproxy.cfg
        pattern: "backend ing_default_multi-port_api-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/api/ BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix map must use BACKEND qualifier for /api

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/admin/ BACKEND:ing_default_multi-port_api-svc_81"
        description: Path prefix map must use BACKEND qualifier for /admin

      - type: contains
        target: map:path-prefix.map
        pattern: "example.com/app/ BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix map must use BACKEND qualifier for /app

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/api BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix-exact map must use BACKEND qualifier for /api

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/admin BACKEND:ing_default_multi-port_api-svc_81"
        description: Path prefix-exact map must use BACKEND qualifier for /admin

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "example.com/app BACKEND:ing_default_multi-port_api-svc_80"
        description: Path prefix-exact map must use BACKEND qualifier for /app

      # Map Formatting Tests - Ensure proper line separation
      - type: not_contains
        target: map:host.map
        pattern: "hosts\\)\\S"
        description: Host map comments must not concatenate with entries (no non-whitespace immediately after comment)

      - type: not_contains
        target: map:path-prefix.map
        pattern: "paths\\)\\S"
        description: Path prefix map comments must not concatenate with entries

      - type: not_contains
        target: map:path-prefix-exact.map
        pattern: "paths\\)\\S"
        description: Path prefix-exact map comments must not concatenate with entries

      - type: contains
        target: map:host.map
        pattern: "(?m)^example\\.com example\\.com$"
        description: Host map entries must start at beginning of line and be properly formatted

      - type: contains
        target: map:path-prefix.map
        pattern: "(?m)^example\\.com/api/ BACKEND:"
        description: Path prefix map entries must start at beginning of line

      - type: contains
        target: map:path-prefix-exact.map
        pattern: "(?m)^example\\.com/api BACKEND:"
        description: Path prefix-exact map entries must start at beginning of line

  test-ingress-tls-basic:
    description: Ingress with spec.tls should register TLS certificates
    fixtures:
      secrets:
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: example-tls
            namespace: default
          data:
            # Test certificate (base64-encoded)
            tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lVT2FGRWhyWlRXZ1JpbEorSFJCOWhJQnlzT2xNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZERVNNQkFHQTFVRUF3d0piRzlqWVd4b2IzTjBNQ0FYRFRJMU1URXhPVEU0TWpVMU1Wb1lEekl4TWpVeApNREkyTVRneU5UVXhXakFVTVJJd0VBWURWUVFEREFsc2IyTmhiR2h2YzNRd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDWDJIQnA0V00rbFIvSXljLzRMR01qUHk0bUdFcUtVYm5xaFdRbU9nMXgKNHlnRkkzMkcyNWZYR1djZ0ZtVmg4YkZSZVFxdTB0Z1k2SUo5UE9nWmd5eHNhaUgzeldBMi8wbkdEejVvN2dYeQp5Z0VLaTdZY3M3bHNFNng0Y3lLK2tZaFdvZkNNaDJDck5LNWVCVzlRUnh3U3pieDNWREZqVS9HdVVaQnRBVWxICkRLd2ZCb0ZHNEhzaEZDUHl2Y3BuTlNLbUdwS0wwZ0UyczNBTHN5NWpqYjRpMnpyQng4Mng0Y3hQZUlCOEt6ckMKMDZvQXVwbzJDdUxaQTFMMkMrZVB5UlQ0QWxRUGNOL2l3WmdqMyt3eG8vWkFJaUxQK2NXbUY1dUdXeTZUREoybAo2K2FLYWFOajFCVVBWSkxTdW92WFhCMmc2akYxdWxIM1VWNVhPMlVMQ1ZzUkFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlRHdi9VWG5nZ2tKaytpTkN0WnFwMStTSS9JaGpBZkJnTlZIU01FR0RBV2dCVEd2L1VYbmdna0prK2kKTkN0WnFwMStTSS9JaGpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBSwozb3QyQTRyR05DWEpuZHB5OWlBa0dUUnk2SWxCcExKUlNJZ1JOWmlZQkU4SEtlWnUyR3JnUGI3V0ZUL1RyWkI2Cm5jMjhzVjdsYUNDNXlyZVUxeGVpL2ZjTllPSHlscWdBR2lFYmt2Um1za1hTd24wSlFaanpUNWl1a2hObVBkV0QKSWx0bWhCU3FsZlRsWFRYaytjMVlzeUJrVkN5TVNOdUZMd3pkODlLanJlU2xsZzE5clRVUmlLRzZGU0o2azBPSQprVE1lbWczRGZabldZSytNZnBxdjlVSDJSblBhMVJlbHJ4aTNLTWZoV0h2b2wxeUlVSGdnT0g3MkE4Wkd6eFZMClh4L09rSS8weXozUFhvM0xtUkRqczMzWUpXSzRTMmRwaFpyS3RMS2hqcEFIZzI1Nk8zUlN1bWd2d2NpYzZVRWMKaEpvWitneWZacUdBcnJ6M1dWTTkKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
            tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV1d0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktVd2dnU2hBZ0VBQW9JQkFRQ1gySEJwNFdNK2xSL0kKeWMvNExHTWpQeTRtR0VxS1VibnFoV1FtT2cxeDR5Z0ZJMzJHMjVmWEdXY2dGbVZoOGJGUmVRcXUwdGdZNklKOQpQT2daZ3l4c2FpSDN6V0EyLzBuR0R6NW83Z1h5eWdFS2k3WWNzN2xzRTZ4NGN5SytrWWhXb2ZDTWgyQ3JOSzVlCkJXOVFSeHdTemJ4M1ZERmpVL0d1VVpCdEFVbEhES3dmQm9GRzRIc2hGQ1B5dmNwbk5TS21HcEtMMGdFMnMzQUwKc3k1ampiNGkyenJCeDgyeDRjeFBlSUI4S3pyQzA2b0F1cG8yQ3VMWkExTDJDK2VQeVJUNEFsUVBjTi9pd1pnagozK3d4by9aQUlpTFArY1dtRjV1R1d5NlRESjJsNithS2FhTmoxQlVQVkpMU3VvdlhYQjJnNmpGMXVsSDNVVjVYCk8yVUxDVnNSQWdNQkFBRUNnZjhKSHBhaHhVZVFtcVF1Q3ZEU2x0ZmRaZzMvZTdYK1dLb3h5NUVZT3FSVUVyQjAKbm8wTGJHVFNKbFJyT08wZDFNWXhmbk9GekdQdUd3aTdQTTB6dXcwUDljL1VjaUUxTEYvaDVVaDZSTkZXbzRzcwpkdmVaQWJKQksyMVFUcG5ubUJYNEhnRzBidXovVzBxZG12WDBmRkRUVUVmaFlzMFVpaFlad2d4S2Y2bEcrd1FzClZRclNiTzlMKzRJaHN2cnNSQlRGYU1nV0FMNGp0a3VpcTdSaVFkamRpejRkMmZJd1FtcVR5VEFvWlh5ZW9WRmEKM2JlRXh3aWtJME5pcXBNTWlaUjlXeTYzZkw2TlowZ0F5T0dKL09FaVU2Q3kyV2JCQzZrbVhnRlpOVW1Va1B5dAp3TXlqNTg5ZG1taDNaTGw1VEloNzVOc1dTNlVvTm1abzV3MmxLWUVDZ1lFQXh5N3dJeWxFbDlLaURvT1Q5V3gyCjFOcnp3bjQzLzVVbFAxakVFM0NiMXBiRDJCQjRUNXM4TmxCSEFOa0tFeFI1RUJnNTNYakw3aVlvTU1rWWUwL1YKRFVOdWFLRzlaaHhUSklualdPNURNUDE2NVFwNlBzdklObmlVZ1JLcW1Bc1hSNkNkN0NXeVIzcEZVOUZPcEJpWgo2aWt1eFVNYnZFWW8xVHNUWjB2Umw5RUNnWUVBd3lpNVNORWpEM2x6UHozcm5OVllRTEJBL2V1NS8wS1JXc2hQCmJVcit0YUszN1l4ZEJMV1JHOVpjOHd2ZU9pVWZTUHhWNmwyWnFRdVQ0VVVFdmYrbTlJWEZGZXZxUE1IanNZUVQKVVlRQVRxMkgwelF3Mm5kS2thdDlWSk81UVZKV252N0YxaWY5S3VPRFozbEhiUk96aEJjZjZXUWlBS0RNQWQ3cwpQNDNYbjBFQ2dZRUFxNmFacjlONmwxUWY4RjRYL2lLdzdaS2JDdnQzQ3J6ZlVvNE91Nm9Kd280K3pFNjFQL1ZKCm1JenFBNk1HK1pabEZpZXFobC81Ym94WGltTml3N0h5cXZGM2pwZ0QvcUZlVFZpL0lmNkN6UTlFLzJsZUhBdkYKeUp0MWJ4NUZBYTVkSzQ4UlNWYmJJcG9PY01NcUFHUnJEODdaelltZHQwekhGNnRIZDNkeGNtRUNnWUFzRWJNZApWVlNVZHZsbVM0WTc2UlUvcmsxT3lYODd1LzEwd1l6bUFpeFlPY0ZNM0FoWk91TGtwVmhoN2NrbDJpSWhhaEhBCmxaaFFTdlAreDRZVm5YaEcrVG9UQkMzbHdHYTVQRGpjakhGQlV3QTcyaW81K3Z3VXZ1UFRTSFJwNHJ6NnRFOWEKVjdkY2l2bXVVUDJuRE83Wm9oc3JxZGZmeW0rbThIN3FydzRFd1FLQmdEV1RqME82TXpyUUVhQVlrUVVucERVLwpYOFd5OGlPcStFYU5ZejNWWUtKSm5xVkJTeldLZDIrRFRQVmlvVHZqOVhVYkhGK1p3MW9ieXljcklDcVgrd0RCCkl4ZXBoMlBNNERKUHVlRnFJVzRqY3lQSkJuVGt4OVBuNUNKem1XSUJybE1vZjZON2tvWFIzMFBMbjlDRlRpNFoKa1dhTnhjR3BROVNldjVQeEoxL2QKLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQo=
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: web-svc
            namespace: default
          spec:
            ports:
              - port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: web-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: web-svc
          addressType: IPv4
          endpoints:
            - addresses: ["10.0.0.1"]
          ports:
            - port: 8080
              protocol: TCP
      ingresses:
        - apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: tls-ingress
            namespace: default
          spec:
            ingressClassName: haproxy
            tls:
              - hosts:
                  - example.com
                  - www.example.com
                secretName: example-tls
            rules:
              - host: example.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: web-svc
                          port:
                            number: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid with Ingress TLS

      - type: contains
        target: crt-list:certificate-list.txt
        pattern: "default_example-tls\\.pem \\[ocsp-update on\\] example\\.com www\\.example\\.com"
        description: CRT-list must include Ingress TLS certificate with SNI patterns

      - type: contains
        target: cert:default_example-tls.pem
        pattern: "BEGIN CERTIFICATE"
        description: TLS certificate file must be generated from Secret
