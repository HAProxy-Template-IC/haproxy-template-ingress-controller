# SSL/TLS Infrastructure Library for HAProxy Template Ingress Controller
# Contains SSL certificate management, HTTPS frontends, and SSL passthrough infrastructure
# Must be loaded after base.yaml to access frontend-routing-logic and file registry

# Test certificate fixtures (YAML anchors for reuse across validation tests)
_test_tls_crt: &test_tls_crt LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lVT2FGRWhyWlRXZ1JpbEorSFJCOWhJQnlzT2xNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZERVNNQkFHQTFVRUF3d0piRzlqWVd4b2IzTjBNQ0FYRFRJMU1URXhPVEU0TWpVMU1Wb1lEekl4TWpVeApNREkyTVRneU5UVXhXakFVTVJJd0VBWURWUVFEREFsc2IyTmhiR2h2YzNRd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDWDJIQnA0V00rbFIvSXljLzRMR01qUHk0bUdFcUtVYm5xaFdRbU9nMXgKNHlnRkkzMkcyNWZYR1djZ0ZtVmg4YkZSZVFxdTB0Z1k2SUo5UE9nWmd5eHNhaUgzeldBMi8wbkdEejVvN2dYeQp5Z0VLaTdZY3M3bHNFNng0Y3lLK2tZaFdvZkNNaDJDck5LNWVCVzlRUnh3U3pieDNWREZqVS9HdVVaQnRBVWxICkRLd2ZCb0ZHNEhzaEZDUHl2Y3BuTlNLbUdwS0wwZ0UyczNBTHN5NWpqYjRpMnpyQng4Mng0Y3hQZUlCOEt6ckMKMDZvQXVwbzJDdUxaQTFMMkMrZVB5UlQ0QWxRUGNOL2l3WmdqMyt3eG8vWkFJaUxQK2NXbUY1dUdXeTZUREoybAo2K2FLYWFOajFCVVBWSkxTdW92WFhCMmc2akYxdWxIM1VWNVhPMlVMQ1ZzUkFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlRHdi9VWG5nZ2tKaytpTkN0WnFwMStTSS9JaGpBZkJnTlZIU01FR0RBV2dCVEd2L1VYbmdna0prK2kKTkN0WnFwMStTSS9JaGpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBSwozb3QyQTRyR05DWEpuZHB5OWlBa0dUUnk2SWxCcExKUlNJZ1JOWmlZQkU4SEtlWnUyR3JnUGI3V0ZUL1RyWkI2Cm5jMjhzVjdsYUNDNXlyZVUxeGVpL2ZjTllPSHlscWdBR2lFYmt2Um1za1hTd24wSlFaanpUNWl1a2hObVBkV0QKSWx0bWhCU3FsZlRsWFRYaytjMVlzeUJrVkN5TVNOdUZMd3pkODlLanJlU2xsZzE5clRVUmlLRzZGU0o2azBPSQprVE1lbWczRGZabldZSytNZnBxdjlVSDJSblBhMVJlbHJ4aTNLTWZoV0h2b2wxeUlVSGdnT0g3MkE4Wkd6eFZMClh4L09rSS8weXozUFhvM0xtUkRqczMzWUpXSzRTMmRwaFpyS3RMS2hqcEFIZzI1Nk8zUlN1bWd2d2NpYzZVRWMKaEpvWitneWZacUdBcnJ6M1dWTTkKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
_test_tls_key: &test_tls_key LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV1d0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktVd2dnU2hBZ0VBQW9JQkFRQ1gySEJwNFdNK2xSL0kKeWMvNExHTWpQeTRtR0VxS1VibnFoV1FtT2cxeDR5Z0ZJMzJHMjVmWEdXY2dGbVZoOGJGUmVRcXUwdGdZNklKOQpQT2daZ3l4c2FpSDN6V0EyLzBuR0R6NW83Z1h5eWdFS2k3WWNzN2xzRTZ4NGN5SytrWWhXb2ZDTWgyQ3JOSzVlCkJXOVFSeHdTemJ4M1ZERmpVL0d1VVpCdEFVbEhES3dmQm9GRzRIc2hGQ1B5dmNwbk5TS21HcEtMMGdFMnMzQUwKc3k1ampiNGkyenJCeDgyeDRjeFBlSUI4S3pyQzA2b0F1cG8yQ3VMWkExTDJDK2VQeVJUNEFsUVBjTi9pd1pnagozK3d4by9aQUlpTFArY1dtRjV1R1d5NlRESjJsNithS2FhTmoxQlVQVkpMU3VvdlhYQjJnNmpGMXVsSDNVVjVYCk8yVUxDVnNSQWdNQkFBRUNnZjhKSHBhaHhVZVFtcVF1Q3ZEU2x0ZmRaZzMvZTdYK1dLb3h5NUVZT3FSVUVyQjAKbm8wTGJHVFNKbFJyT08wZDFNWXhmbk9GekdQdUd3aTdQTTB6dXcwUDljL1VjaUUxTEYvaDVVaDZSTkZXbzRzcwpkdmVaQWJKQksyMVFUcG5ubUJYNEhnRzBidXovVzBxZG12WDBmRkRUVUVmaFlzMFVpaFlad2d4S2Y2bEcrd1FzClZRclNiTzlMKzRJaHN2cnNSQlRGYU1nV0FMNGp0a3VpcTdSaVFkamRpejRkMmZJd1FtcVR5VEFvWlh5ZW9WRmEKM2JlRXh3aWtJME5pcXBNTWlaUjlXeTYzZkw2TlowZ0F5T0dKL09FaVU2Q3kyV2JCQzZrbVhnRlpOVW1Va1B5dAp3TXlqNTg5ZG1taDNaTGw1VEloNzVOc1dTNlVvTm1abzV3MmxLWUVDZ1lFQXh5N3dJeWxFbDlLaURvT1Q5V3gyCjFOcnp3bjQzLzVVbFAxakVFM0NiMXBiRDJCQjRUNXM4TmxCSEFOa0tFeFI1RUJnNTNYakw3aVlvTU1rWWUwL1YKRFVOdWFLRzlaaHhUSklualdPNURNUDE2NVFwNlBzdklObmlVZ1JLcW1Bc1hSNkNkN0NXeVIzcEZVOUZPcEJpWgo2aWt1eFVNYnZFWW8xVHNUWjB2Umw5RUNnWUVBd3lpNVNORWpEM2x6UHozcm5OVllRTEJBL2V1NS8wS1JXc2hQCmJVcit0YUszN1l4ZEJMV1JHOVpjOHd2ZU9pVWZTUHhWNmwyWnFRdVQ0VVVFdmYrbTlJWEZGZXZxUE1IanNZUVQKVVlRQVRxMkgwelF3Mm5kS2thdDlWSk81UVZKV252N0YxaWY5S3VPRFozbEhiUk96aEJjZjZXUWlBS0RNQWQ3cwpQNDNYbjBFQ2dZRUFxNmFacjlONmwxUWY4RjRYL2lLdzdaS2JDdnQzQ3J6ZlVvNE91Nm9Kd280K3pFNjFQL1ZKCm1JenFBNk1HK1pabEZpZXFobC81Ym94WGltTml3N0h5cXZGM2pwZ0QvcUZlVFZpL0lmNkN6UTlFLzJsZUhBdkYKeUp0MWJ4NUZBYTVkSzQ4UlNWYmJJcG9PY01NcUFHUnJEODdaelltZHQwekhGNnRIZDNkeGNtRUNnWUFzRWJNZApWVlNVZHZsbVM0WTc2UlUvcmsxT3lYODd1LzEwd1l6bUFpeFlPY0ZNM0FoWk91TGtwVmhoN2NrbDJpSWhhaEhBCmxaaFFTdlAreDRZVm5YaEcrVG9UQkMzbHdHYTVQRGpjakhGQlV3QTcyaW81K3Z3VXZ1UFRTSFJwNHJ6NnRFOWEKVjdkY2l2bXVVUDJuRE83Wm9oc3JxZGZmeW0rbThIN3FydzRFd1FLQmdEV1RqME82TXpyUUVhQVlrUVVucERVLwpYOFd5OGlPcStFYU5ZejNWWUtKSm5xVkJTeldLZDIrRFRQVmlvVHZqOVhVYkhGK1p3MW9ieXljcklDcVgrd0RCCkl4ZXBoMlBNNERKUHVlRnFJVzRqY3lQSkJuVGt4OVBuNUNKem1XSUJybE1vZjZON2tvWFIzMFBMbjlDRlRpNFoKa1dhTnhjR3BROVNldjVQeEoxL2QKLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQo=

# Watch secrets for SSL certificate loading
watchedResources:
  secrets:
    apiVersion: v1
    resources: secrets
    indexBy: ["metadata.namespace", "metadata.name"]

templateSnippets:
  # SSL bind options utility - used by both HTTPS frontend and SSL passthrough
  # Uses crt-list for certificate management with per-certificate OCSP configuration
  util-ssl-bind-options:
    template: >-
      {{- " " -}}ssl crt-list {{ pathResolver.GetPath("certificate-list.txt", "crt-list") }} alpn h2,http/1.1

  features-050-ssl-initialization:
    template: |
      {#-
        SSL Infrastructure Initialization

        Purpose: Initializes data structures for SSL feature registration.

        Extension Point: features-* (priority 050 - runs first)

        Provides (in shared.globalFeatures):
          - sslPassthroughBackends: Array for SSL passthrough backend registrations
          - tlsCertificates: Array for TLS certificate registrations

        Dependencies: None (this initializes the infrastructure)

        Used By:
          - features-100-gateway-ssl-passthrough
          - features-100-gateway-tls
          - features-100-ingress-tls
          - features-100-haproxytech-ssl-passthrough
      -#}

      {# Initialize SSL data structures atomically - ComputeIfAbsent ensures this runs exactly once #}
      {%- var _, _ = shared.ComputeIfAbsent("globalFeatures", func() any {
        return map[string]any{
          "sslPassthroughBackends": []any{},
          "tlsCertificates": []any{},
        }
      }) -%}
      {# Ensure fields exist (in case globalFeatures was created elsewhere without these fields) #}
      {%- var gf = shared.Get("globalFeatures").(map[string]any) -%}
      {%- if gf["sslPassthroughBackends"] == nil -%}
        {%- gf["sslPassthroughBackends"] = []any{} -%}
      {%- end -%}
      {%- if gf["tlsCertificates"] == nil -%}
        {%- gf["tlsCertificates"] = []any{} -%}
      {%- end -%}

  features-150-ssl-crtlist:
    template: |
      {#-
        SSL CRT-List Generation

        Purpose: Generates HAProxy crt-list file from registered TLS certificates.

        Extension Point: features-* (priority 150 - runs after certificate registration)

        Dependencies:
          - features-050-ssl-initialization
          - features-100-*-tls snippets (register certificates)

        Output:
          - certificate-list.txt crt-list file via fileRegistry.Register()

        Format: <cert-path> [ssl-options] [sni-filter ...]
        See: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/#5.1-crt-list
      -#}

      {%- var gf = shared.Get("globalFeatures") -%}
      {%- var crtlistLines = []any{} -%}

      {# Generate entries for each registered TLS certificate #}
      {%- var tlsCerts []any = coalesce(gf["tlsCertificates"], []any{}) -%}
      {%- for _, tlsCert := range tlsCerts -%}
        {%- var tc map[string]any = tlsCert -%}
        {%- var certFilename = tc["secret_namespace"] + "_" + tc["secret_name"] + ".pem" -%}
        {# Paths in crt-list are relative to crt-base, so just use filename #}
        {%- var sslOptions = "[ocsp-update on]" -%}
        {%- var sniList = tc["sni_patterns"] | toStringSlice() | join(" ") -%}
        {%- var line = certFilename + " " + sslOptions + " " + sniList -%}
        {%- crtlistLines = append(crtlistLines, line) -%}
      {%- end -%}

      {# Default certificate (no SNI filter = matches everything not matched above) #}
      {# Paths in crt-list are relative to crt-base, so just use filename #}
      {%- var defaultLine = "default.pem [ocsp-update on]" -%}
      {%- crtlistLines = append(crtlistLines, defaultLine) -%}

      {# Register the crt-list file with file_registry #}
      {# Add trailing newline to satisfy HAProxy's parser #}
      {%- var crtlistContent = (crtlistLines | toStringSlice() | join("\n")) + "\n" -%}
      {%- var _, crtListErr = fileRegistry.Register("crt-list", "certificate-list.txt", crtlistContent) -%}
      {%- if crtListErr != nil -%}{{ fail("failed to register crt-list: " + tostring(crtListErr)) }}{%- end -%}

  # Global OCSP configuration - enables automatic OCSP stapling for all SSL certificates
  global-ssl-ocsp-config:
    template: |
      {# Global OCSP Update Configuration #}
      {# Enables automatic fetching and caching of OCSP responses for certificate validation #}
      {# See: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/#3.1-ocsp-update.mode #}
      # ssl/global-ssl-ocsp-config
      ocsp-update.mode on
      ocsp-update.mindelay 300
      ocsp-update.maxdelay 3600

  frontends-500-ssl-tcp:
    template: |
      {#-
        SSL Passthrough TCP Frontend

        Purpose: TCP frontend for SNI-based SSL passthrough routing.

        Extension Point: frontends-* (priority 500)

        Conditional: Only generated when sslPassthroughBackends is non-empty.

        Architecture:
          - Extracts SNI from TLS ClientHello
          - Routes to passthrough backends based on SNI match
          - Falls back to ssl-loopback backend for SSL termination

        Dependencies:
          - features-050-ssl-initialization
          - features-100-*-ssl-passthrough snippets
      -#}
      {%- var gf = shared.Get("globalFeatures") -%}
      {%- var passthroughBackends []any = gf["sslPassthroughBackends"] -%}
      {%- if len(passthroughBackends) > 0 -%}
      {# TCP frontend extracts SNI and routes to passthrough backends or loopback #}
      # ssl/frontends-ssl-tcp

      frontend ssl-tcp
          mode tcp
          bind *:{{ extraContext | dig("httpsPort") | fallback(8443) }}

          # Extract SNI for routing decisions (wait up to 5s for client hello)
          tcp-request inspect-delay 5s
          tcp-request content accept if { req_ssl_hello_type 1 }

          # Route to passthrough backends based on SNI
          {% for _, backend := range passthroughBackends -%}
          {%- var b map[string]any = backend %}
          use_backend {{ b["name"] }} if { req_ssl_sni -m str {{ b["sni"] }} }
          {%- end %}

          # Default: route to loopback backend for SSL termination
          default_backend ssl-loopback

      {% end -%}

  backends-500-ssl-loopback:
    template: |
      {#-
        SSL Loopback Backend

        Purpose: Bridges TCP frontend to HTTPS frontend via Unix socket.

        Extension Point: backends-* (priority 500)

        Conditional: Only generated when sslPassthroughBackends is non-empty.

        Architecture:
          - TCP mode backend
          - Forwards to unix@/etc/haproxy/ssl-frontend.sock with PROXY protocol
          - Enables HTTPS frontend to receive connections from TCP frontend
      -#}
      {%- var gf = shared.Get("globalFeatures") -%}
      {%- var passthroughBackends []any = gf["sslPassthroughBackends"] -%}
      {%- if len(passthroughBackends) > 0 -%}
      # ssl/backends-ssl-loopback

      backend ssl-loopback
          mode tcp
          server loopback unix@/etc/haproxy/ssl-frontend.sock send-proxy-v2

      {%- end -%}

  frontends-500-https:
    template: |
      {#-
        HTTPS Frontend with SSL Termination

        Purpose: HTTPS frontend that terminates SSL and routes to backends.

        Extension Point: frontends-* (priority 500)

        Binding Modes:
          - With SSL passthrough: Binds to Unix socket (receives from ssl-loopback)
          - Without SSL passthrough: Binds directly to HTTPS port

        Dependencies:
          - util-ssl-bind-options (SSL bind configuration)
          - frontend-routing-logic (from base.yaml)
          - features-150-ssl-crtlist (certificate list)
      -#}
      {%- var gf = shared.Get("globalFeatures") -%}
      {%- var passthroughBackends []any = gf["sslPassthroughBackends"] -%}
      # ssl/frontends-https

      frontend https
          mode http
      {% if len(passthroughBackends) > 0 -%}
          bind unix@/etc/haproxy/ssl-frontend.sock mode 660{{ render "util-ssl-bind-options" }} accept-proxy
      {% else -%}
          bind *:{{ extraContext | dig("httpsPort") | fallback(8443) }}{{ render "util-ssl-bind-options" }}
      {% end %}

          {# Reuse frontend routing logic from base.yaml #}
          {# Note: indent filter removed - content should already be properly indented #}
          {{ render "frontend-routing-logic" }}

          # Use backend from txn.backend_name (set by qualifier logic)
          use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

          # Default backend
          default_backend default_backend

# SSL certificate files
#
# NOTE: Dynamic TLS certificate file generation
# ============================================
# TLS certificates are automatically generated using file_registry.Register() by resource
# libraries (ingress.yaml, gateway.yaml) when processing Ingress spec.tls and Gateway TLS
# configurations. No pre-declaration is needed - any TLS Secret referenced in these resources
# will be automatically converted to a certificate file.
#
# The crt-list file below references these certificates using the naming pattern:
#   {namespace}_{secretname}.pem
#
# Only the default certificate (fallback for SNI mismatch) needs to be defined here.
# All other certificates are registered dynamically at template rendering time.

sslCertificates:
  # Default SSL certificate (fallback for SNI mismatch)
  default.pem:
    template: |
      {# Default SSL certificate for HTTPS frontend #}
      {# Loads certificate from TLS Secret (configurable via values.yaml) #}
      {# Secret name and namespace come from templatingSettings.extraContext #}
      {%- var certNamespace = default_ssl_certNamespace default "haproxy-template-ic" -%}
      {%- var certName = default_ssl_certName default "default-ssl-cert" -%}
      {%- var secret = resources.secrets.GetSingle(certNamespace, certName) -%}
      {%- if secret == nil -%}
      {{ fail("TLS Secret not found: " + certNamespace + "/" + certName + ". Ensure the Secret exists and is watched.") }}
      {%- end -%}
      {%- var secretMap map[string]any = secret -%}
      {%- var secretData map[string]any = secretMap["data"] -%}
      {%- if secretData == nil || secretData["tls.crt"] == nil || secretData["tls.key"] == nil -%}
      {{ fail("Invalid TLS Secret " + certNamespace + "/" + certName + ": missing tls.crt or tls.key fields. Ensure the Secret is of type kubernetes.io/tls.") }}
      {%- end -%}
      {{- b64decode(secretData["tls.crt"]) -}}
      {{- b64decode(secretData["tls.key"]) -}}

# Validation tests for SSL functionality
validationTests:
  _global:
    description: Global SSL test fixtures
    fixtures:
      secrets:
        # Provide default SSL certificate in both common namespaces for test flexibility
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: default-ssl-cert
            namespace: haproxy-template-ic
          data:
            tls.crt: *test_tls_crt
            tls.key: *test_tls_key
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: default-ssl-cert
            namespace: default
          data:
            tls.crt: *test_tls_crt
            tls.key: *test_tls_key

  test-ssl-certificate-loading:
    description: Verify default SSL certificate is loaded correctly
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid with SSL certificate loaded

  test-ssl-https-frontend-basic:
    description: Verify HTTPS frontend is generated with correct bind options
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid

      - type: contains
        target: haproxy.cfg
        pattern: "frontend https"
        description: Must generate HTTPS frontend

      - type: contains
        target: haproxy.cfg
        pattern: "bind .*:8443.*ssl crt"
        description: HTTPS frontend must bind with SSL options

      - type: contains
        target: haproxy.cfg
        pattern: "alpn h2,http/1.1"
        description: HTTPS frontend must enable ALPN negotiation

  test-ssl-crtlist-basic:
    description: Verify crt-list file is generated with OCSP configuration
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid

      - type: contains
        target: haproxy.cfg
        pattern: "ssl crt-list .*/certificate-list\\.txt"
        description: HTTPS frontend must use crt-list for certificate loading

      - type: contains
        target: crt-list:certificate-list.txt
        pattern: "default\\.pem \\[ocsp-update on\\]"
        description: CRT-list must include default certificate with OCSP enabled

      - type: not_contains
        target: crt-list:certificate-list.txt
        pattern: "^\\s*$"
        description: CRT-list must not contain empty lines
