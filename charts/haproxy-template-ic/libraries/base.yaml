# Base template library for HAProxy Template Ingress Controller
# Contains resource-agnostic core template snippets, files, and HAProxy configuration
# Uses plugin patterns (resource_*) to discover resource-specific implementations
#
# NOTE: SSL/TLS infrastructure moved to ssl.yaml library
# - SSL test fixtures (moved to ssl.yaml)
# - util-ssl-bind-options (moved to ssl.yaml)
# - sslCertificates.default.pem (moved to ssl.yaml)
# - frontend https (moved to ssl.yaml)
# - SSL passthrough infrastructure (moved to ssl.yaml)

templateSnippets:
  util-macros:
    template: |
      {#-
        Utility Macros

        Purpose: Reusable macros for template orchestration and string manipulation.

        Provides:
          - SanitizeRegex(pattern): Escapes regex patterns for HAProxy double-quoted context

        Usage:
          {% import "util-macros" for SanitizeRegex %}
          {{ SanitizeRegex("^/api/v[0-9]+$") }}
      -#}
      {% macro SanitizeRegex(pattern string) string %}
        {%% show replace(pattern, "$", "\\$") %%}
      {% end %}

  frontend-routing-logic:
    template: |-
      {#-
        Frontend Routing Logic

        Purpose: Core path-based routing with qualifier system for backend selection.

        Extension Point: Rendered directly by haproxyConfig template.

        Qualifiers:
          - BACKEND:<name> - Direct routing to named backend
          - MULTIBACKEND:<weight>:<key> - Weighted routing via weighted-multi-backend.map

        Path Matching Order (default):
          1. Exact match (path-exact.map)
          2. Regex match (path-regex.map)
          3. Prefix-exact match (path-prefix-exact.map)
          4. Prefix match (path-prefix.map)

        Override: Use path-regex-last library for performance-first ordering (Exact > Prefix > Regex).

        Extension Points:
          - frontend-matchers-advanced-* - Advanced matchers (method, headers, query)
      -#}
      {%- var hostMap, hostMapErr = pathResolver.GetPath("host.map", "map") -%}
      {%- if hostMapErr != nil -%}{{ fail("failed to resolve host.map path: " + tostring(hostMapErr)) }}{%- end -%}
      {%- var pathExactMap, pathExactMapErr = pathResolver.GetPath("path-exact.map", "map") -%}
      {%- if pathExactMapErr != nil -%}{{ fail("failed to resolve path-exact.map path: " + tostring(pathExactMapErr)) }}{%- end -%}
      {%- var pathRegexMap, pathRegexMapErr = pathResolver.GetPath("path-regex.map", "map") -%}
      {%- if pathRegexMapErr != nil -%}{{ fail("failed to resolve path-regex.map path: " + tostring(pathRegexMapErr)) }}{%- end -%}
      {%- var pathPrefixExactMap, pathPrefixExactMapErr = pathResolver.GetPath("path-prefix-exact.map", "map") -%}
      {%- if pathPrefixExactMapErr != nil -%}{{ fail("failed to resolve path-prefix-exact.map path: " + tostring(pathPrefixExactMapErr)) }}{%- end -%}
      {%- var pathPrefixMap, pathPrefixMapErr = pathResolver.GetPath("path-prefix.map", "map") -%}
      {%- if pathPrefixMapErr != nil -%}{{ fail("failed to resolve path-prefix.map path: " + tostring(pathPrefixMapErr)) }}{%- end -%}
      {%- var weightedMap, weightedMapErr = pathResolver.GetPath("weighted-multi-backend.map", "map") -%}
      {%- if weightedMapErr != nil -%}{{ fail("failed to resolve weighted-multi-backend.map path: " + tostring(weightedMapErr)) }}{%- end -%}
      # base/frontend-routing-logic

      # Set variables for path-based routing
      http-request set-var(txn.base) base
      http-request set-var(txn.path) path
      http-request set-var(txn.host) req.hdr(Host),field(1,:),lower
      http-request set-var(txn.host_match) var(txn.host),map({{ hostMap }})
      http-request set-var(txn.host_match) var(txn.host),regsub(^[^.]*,,),map({{ hostMap }},'') if !{ var(txn.host_match) -m found }

      # Path matching order: Exact > Regex > Prefix-exact > Prefix
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ pathExactMap }})
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_reg({{ pathRegexMap }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ pathPrefixExactMap }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_beg({{ pathPrefixMap }}) if !{ var(txn.path_match) -m found }

      # Parse qualifier from path match (field 1 = qualifier type)
      # Empty string if no path match - falls through gracefully
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # Extension point for advanced matchers (method/header/query)
      # Libraries can inject ordered http-request statements here
      {{- render_glob "frontend-matchers-advanced-*" }}
      # Re-parse path_match_qualifier after advanced matchers may have changed path_match
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # MULTIBACKEND qualifier: weighted routing
      # Format: MULTIBACKEND:<total_weight>:<route_key>
      # Field 2 = total_weight, Field 3 = route_key
      # Result: sets txn.backend_name via weighted-multi-backend.map lookup
      http-request set-var(txn.total_weight) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.random_weight) rand(),mod(txn.total_weight) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.route_key) var(txn.path_match),field(3,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.lookup_key) var(txn.random_weight),concat(:,txn.route_key,) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.backend_name) var(txn.lookup_key),map({{ weightedMap }}) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }

      # BACKEND qualifier: direct routing
      # Format: BACKEND:<backend_name>
      # Field 2 = backend name
      # Result: sets txn.backend_name directly
      http-request set-var(txn.backend_name) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str BACKEND }

  util-backend-servers:
    template: |
      {#-
        Backend Server Pool Generation

        Purpose: Generates HAProxy server lines from Kubernetes EndpointSlices.

        Provides:
          - BackendServers(serviceName, maxServerSlots, port, serverOpts) macro

        Parameters:
          - serviceName (string): Kubernetes Service name to look up endpoints
          - maxServerSlots (int): Maximum server slots (0 = use serverOpts.serverSlotsValue or default 10)
          - port (int): Target port number
          - serverOpts (map): Server options map with keys:
            - serverSlotsValue (int): Override for max slots
            - flags ([]any): Server flags (e.g., ["ssl", "verify none"])
            - podMaxconnValue (any): Per-pod maxconn value

        Usage:
          {% import "util-backend-servers" for BackendServers %}
          {{ BackendServers("my-service", 10, 8080, nil) }}
          {{ BackendServers("my-service", 0, 8080, serverOpts) }}
      -#}

      {% macro BackendServers(serviceName string, maxServerSlots int, port int, serverOpts map[string]any) string %}
        {%%
          // Determine slot count
          var slots = 10
          if maxServerSlots > 0 {
            slots = maxServerSlots
          } else if serverOpts != nil {
            var serverSlotsValue = serverOpts | dig("serverSlotsValue")
            if serverSlotsValue != nil {
              slots = serverSlotsValue
            }
          }

          // Collect endpoints from EndpointSlices
          var endpoints = []any{}
          for _, endpointSlice := range resources.endpoints.Fetch(serviceName) {
            var epList = endpointSlice | dig("endpoints") | fallback([]any{})
            for _, ep := range epList {
              var addresses = ep | dig("addresses") | fallback([]any{})
              for _, address := range addresses {
                var endpointName string = address
                var targetRef = ep | dig("targetRef")
                if targetRef != nil {
                  var refName = targetRef | dig("name")
                  if refName != nil {
                    endpointName = refName
                  }
                }
                endpoints = append(endpoints, map[string]any{"name": endpointName, "address": address, "port": port})
              }
            }
          }
          var activeCount = len(endpoints)

          // Build server options string from flags
          var serverOptsStr = ""
          if serverOpts != nil {
            var flags = serverOpts | dig("flags")
            if flags != nil {
              var flagsSlice []any = flags
              if len(flagsSlice) > 0 {
                serverOptsStr = " " + join(toStringSlice(flagsSlice), " ")
              }
            }
          }

          // Build maxconn option
          var maxconnOpt = ""
          if serverOpts != nil {
            var podMaxconn = serverOpts | dig("podMaxconnValue")
            if podMaxconn != nil {
              maxconnOpt = " maxconn " + podMaxconn
            }
          }
        %%}
      # base/util-backend-servers
      {%- for i := 1; i <= slots; i++ %}
      {%- if i-1 < activeCount %}
      {%- var ep map[string]any = endpoints[i-1] %}
      server SRV_{{ i }} {{ ep["address"] }}:{{ ep["port"] }}{{ serverOptsStr }}{{ maxconnOpt }} check  # Pod: {{ ep["name"] }}
      {% else %}
      server SRV_{{ i }} 127.0.0.1:1 disabled  # Placeholder
      {% end %}
      {% end %}
      {% end %}
  global-top:
    template: |
      {#-
        Global Top-Level Sections

        Purpose: Orchestrator that renders all global-top-* snippets for top-level HAProxy sections.

        Extension Point: Implements render_glob "global-top-*" pattern.

        Generated Sections:
          - userlist (authentication) - from haproxytech.yaml
          - resolvers (DNS) - future use

        Usage:
          {{ render "global-top" }}
      -#}
      {{- render_glob "global-top-*" -}}

maps:
  host.map:
    template: |
      # base/host.map
      {# Generic host mapping infrastructure #}
      {# Resource libraries populate this map via map-host-* snippets #}
      {{- render_glob "map-host-*" -}}

  path-exact.map:
    template: |
      # base/path-exact.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the equality string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ pathResolver.GetPath("path-exact.map", "map") }})
      {# Resource libraries populate this map via map-path-exact-* snippets #}
      {{- render_glob "map-path-exact-*" -}}

  path-prefix-exact.map:
    template: |
      # base/path-prefix-exact.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      {# Resource libraries populate this map via map-path-prefix-exact-* snippets #}
      {{- render_glob "map-path-prefix-exact-*" -}}

  path-prefix.map:
    template: |
      # base/path-prefix.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the prefix string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_beg({{ pathResolver.GetPath("path-prefix.map", "map") }})
      {# Resource libraries populate this map via map-path-prefix-* snippets #}
      {{- render_glob "map-path-prefix-*" -}}

  path-regex.map:
    template: |
      # base/path-regex.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the regex string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_reg({{ pathResolver.GetPath("path-regex.map", "map") }})
      {# Resource libraries populate this map via map-path-regex-* snippets #}
      {{- render_glob "map-path-regex-*" -}}

  weighted-multi-backend.map:
    template: |
      # base/weighted-multi-backend.map
      # Weighted multi-backend routing map
      # Maps random_number:route_key to backend name for MULTIBACKEND qualifier
      # Format: <0 to total_weight-1>:<namespace>_<resource>_<rule_idx> <backend_name>
      # Entries are expanded: weight N generates N consecutive entries
      # Libraries populate via map-weighted-backend-* pattern
      {{- render_glob "map-weighted-backend-*" }}

files:
  400.http:
    template: |
      HTTP/1.0 400 Bad Request
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>400 Bad Request</h1>
      <p>Your browser sent a request that this server could not understand.</p>
      </body></html>

  403.http:
    template: |
      HTTP/1.0 403 Forbidden
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>403 Forbidden</h1>
      <p>You don't have permission to access this resource.</p>
      </body></html>

  408.http:
    template: |
      HTTP/1.0 408 Request Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>408 Request Time-out</h1>
      <p>Your browser didn't send a complete request in time.</p>
      </body></html>

  500.http:
    template: |
      HTTP/1.0 500 Internal Server Error
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>500 Internal Server Error</h1>
      <p>An internal server error occurred.</p>
      </body></html>

  502.http:
    template: |
      HTTP/1.0 502 Bad Gateway
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>502 Bad Gateway</h1>
      <p>The server received an invalid response from an upstream server.</p>
      </body></html>

  503.http:
    template: |
      HTTP/1.0 503 Service Unavailable
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>503 Service Unavailable</h1>
      <p>No server is available to handle this request.</p>
      </body></html>

  504.http:
    template: |
      HTTP/1.0 504 Gateway Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>504 Gateway Time-out</h1>
      <p>The server didn't respond in time.</p>
      </body></html>

haproxyConfig:
  template: |
    global
        log stdout len 4096 local0 info
        daemon
        ca-base /etc/ssl/certs
        crt-base {{ pathResolver.GetPath("", "cert") }}
        tune.ssl.default-dh-param 2048

    defaults
        mode http
        log global
        option httplog
        option dontlognull
        option log-health-checks
        option forwardfor
        timeout connect 5000
        timeout client 50000
        timeout server 50000
        errorfile 400 {{ pathResolver.GetPath("400.http", "file") }}
        errorfile 403 {{ pathResolver.GetPath("403.http", "file") }}
        errorfile 408 {{ pathResolver.GetPath("408.http", "file") }}
        errorfile 500 {{ pathResolver.GetPath("500.http", "file") }}
        errorfile 502 {{ pathResolver.GetPath("502.http", "file") }}
        errorfile 503 {{ pathResolver.GetPath("503.http", "file") }}
        errorfile 504 {{ pathResolver.GetPath("504.http", "file") }}

    {# Include global top-level snippets (e.g., userlist sections) #}
    {{ render "global-top" }}

    {# Initialize global feature registry for conditional infrastructure #}
    {# Libraries can register feature needs via features-* snippets #}
    {# Features are initialized by libraries (e.g., ssl.yaml adds ssl_passthrough_backends) #}
    {%- shared["globalFeatures"] = map[string]any{} -%}

    {# Phase 1: Feature Registration #}
    {# Initialize SSL features first (if SSL library is loaded) #}
    {# Uses render_glob since features-ssl-initialization is from optional ssl.yaml library #}
    {{ render_glob "features-ssl-initialization" }}
    {# Let resource libraries scan resources and register infrastructure needs #}
    {{- render_glob "features-*" -}}

    frontend status
        bind *:8404
        no log
        http-request return status 200 content-type text/plain string "OK" if { path /healthz }
        http-request return status 200 content-type text/plain string "READY" if { path /ready }

    frontend http_frontend
        bind *:{{ extraContext | dig("httpPort") | fallback(8080) }}

        {# Include frontend routing logic (can be overridden by libraries) #}
        {{ render "frontend-routing-logic" }}
        # Debug headers (when enabled via templating settings)
        {%- var debug bool = extraContext | dig("debug") | fallback(false) -%}
        {%- if debug %}
        # HAProxy routing decision introspection
        http-response set-header X-HAProxy-Backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }
        http-response set-header X-HAProxy-Host-Match %[var(txn.host_match)] if { var(txn.host_match) -m found }
        http-response set-header X-HAProxy-Path-Match %[var(txn.path_match)] if { var(txn.path_match) -m found }
        http-response set-header X-HAProxy-Path-Match-Qualifier %[var(txn.path_match_qualifier)] if { var(txn.path_match_qualifier) -m found }
        http-response set-header X-HAProxy-Total-Weight %[var(txn.total_weight)] if { var(txn.total_weight) -m found }
        http-response set-header X-HAProxy-Random-Weight %[var(txn.random_weight)] if { var(txn.random_weight) -m found }
        http-response set-header X-HAProxy-Route-Key %[var(txn.route_key)] if { var(txn.route_key) -m found }
        # Gateway-specific headers (set by gateway.yaml advanced matchers)
        http-response set-header X-Gateway-Matched-Route %[var(txn.matched_route)] if { var(txn.matched_route) -m found }
        http-response set-header X-Gateway-Match-Reason %[var(txn.match_reason)] if { var(txn.match_reason) -m found }
        http-response set-header X-Gateway-Filters-Applied %[var(txn.filters_applied)] if { var(txn.filters_applied) -m found }
        {%- end -%}
        {# Extension point for frontend request/response filters #}
        {# Runs AFTER routing decisions, BEFORE backend selection #}
        {# Libraries can inject filter logic here (header modification, redirects, rewrites) #}
        {{- render_glob "frontend-filters-*" }}
        # Use backend from txn.backend_name (set by qualifier logic in "frontend-routing-logic")
        # Falls through to default_backend if backend_name is empty
        use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

        # Default backend
        default_backend default_backend

    {# Extension point for additional frontends (e.g., custom TCP services) #}
    {# Resource libraries can inject frontends-* snippets #}
    {{- render_glob "frontends-*" -}}

    {# Include all resource-specific backend definitions using plugin pattern #}
    {# Resource libraries implement backends-* snippets (e.g., backends-ingress, backends-gateway) #}
    {{- render_glob "backends-*" }}

    backend default_backend
        http-request return status 404
    {# Trailing newline preserved #}

  # Post-processing: Normalize indentation to 2 spaces
  # Applies regex replacement to ensure consistent indentation throughout the config
  postProcessing:
    - type: regex_replace
      params:
        pattern: "^[ ]+"
        replace: "  "

# Global fixtures merged with all validation tests
# Test fixtures override global fixtures when same resource exists (by namespace/name)
# NOTE: SSL certificate fixtures moved to ssl.yaml library
validationTests:
  _global:
    description: Global fixtures for all validation tests (SSL fixtures moved to ssl.yaml)
    fixtures: {}
    assertions:
      - type: haproxy_valid
        description: Base configuration must be valid
