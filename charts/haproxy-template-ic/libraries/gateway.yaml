# Gateway API Template Library
#
# Provides Kubernetes Gateway API v1.2.0 support (HTTPRoute, GRPCRoute).
# Documentation: ../docs/libraries/gateway.md
#
# Features:
#   - Path matching: Exact, PathPrefix, RegularExpression
#   - Advanced matching: Method, headers, query params (HTTPRoute), gRPC method (GRPCRoute)
#   - Filters: RequestHeaderModifier, ResponseHeaderModifier, RequestRedirect, URLRewrite
#   - Traffic splitting: Weighted backends via MULTIBACKEND qualifier
#
# Architecture:
#   - util-gateway-analysis: Central cached analysis of all routes
#   - Sharded generation: Automatic parallel processing for large route sets
#   - Extension points: frontend-matchers-advanced-*, frontend-filters-*

watchedResources:
  gateways:
    apiVersion: gateway.networking.k8s.io/v1
    resources: gateways
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: false
    # fieldSelector: injected by Helm from gatewayClass.name

  httproutes:
    apiVersion: gateway.networking.k8s.io/v1
    resources: httproutes
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true
    # Filter by Gateway reference using label selector
    # Users can label HTTPRoutes to target specific Gateways
    # Example: kubectl label httproute my-route gateway=haproxy

  grpcroutes:
    apiVersion: gateway.networking.k8s.io/v1
    resources: grpcroutes
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true

  services:
    apiVersion: v1
    resources: services
    indexBy: ["metadata.namespace", "metadata.name"]

  endpoints:
    apiVersion: discovery.k8s.io/v1
    resources: endpointslices
    indexBy: ["metadata.namespace", "metadata.labels.kubernetes\\.io/service-name"]

templateSnippets:
  # ============================================================================
  # Feature Registration
  # ============================================================================

  features-100-gateway-ssl-passthrough:
    template: |
      {#- Register SSL passthrough backends with global feature registry -#}
      {{ render "util-gateway-ssl-passthrough" }}
      {%- if shared.globalFeatures != nil %}
        {%- var globalFeatures map[string]any = shared.globalFeatures %}
        {%- var sslBackends = globalFeatures | dig("sslPassthroughBackends") %}
        {%- if sslBackends != nil %}
          {%- var gwPassthrough map[string]any = shared.gateway_ssl_passthrough %}
          {%- var gatewayBackends []any = gwPassthrough["backends"] %}
          {%- for _, backend := range gatewayBackends %}
            {%- var sslPassthroughBackends []any = globalFeatures["sslPassthroughBackends"] %}
            {%- globalFeatures["sslPassthroughBackends"] = append(sslPassthroughBackends, backend) %}
          {%- end %}
        {%- end %}
      {%- end %}

  # Register Gateway TLS Terminate mode certificates with SSL infrastructure
  features-100-gateway-tls:
    template: |
      {#- Register TLS certificates from Gateway listeners with TLS mode "Terminate" #}
      {#- Dynamically generates certificate files using fileRegistry.Register() #}
      {%- var globalFeatures map[string]any = shared.globalFeatures %}
      {#- Gateway API TLS configuration structure:
          Gateway.spec.listeners[]:
            - name: https
              protocol: HTTPS  # or GRPC
              port: 443
              hostname: example.com  # optional, can be wildcard
              tls:
                mode: Terminate  # we only handle Terminate here, not Passthrough
                certificateRefs:
                  - kind: Secret
                    name: example-tls
                    namespace: default  # optional, defaults to Gateway namespace
      #}
      {%- var registeredSecrets = []any{} %}
      {%- for _, gateway := range resources.gateways.List() %}
        {%%
          var gwSpec = gateway | dig("spec")
          if gwSpec == nil {
            continue
          }
        %%}
        {%- for _, listener := range gwSpec | dig("listeners") | toSlice() %}
          {%%
            // Only process listeners with TLS Terminate mode
            var listenerTls = listener | dig("tls")
            var tlsMode = listenerTls | dig("mode") | fallback("")
            if listenerTls == nil || tlsMode != "Terminate" {
              continue
            }
          %%}
          {%- for _, certRef := range listenerTls | dig("certificateRefs") | toSlice() %}
            {%%
              // Determine secret namespace (defaults to Gateway namespace)
              var gatewayNs = gateway | dig("metadata", "namespace") | fallback("")
              var certNamespace = certRef | dig("namespace") | fallback(gatewayNs)
              var certName = certRef | dig("name") | fallback("")

              // Only process Secret references (skip other kinds)
              var certKind = certRef | dig("kind") | fallback("")
              if certKind != "" && certKind != "Secret" {
                continue
              }

              // Unique key for this secret
              var secretKey = certNamespace + "/" + certName
              if !first_seen("gateway_tls_certs", secretKey) {
                continue
              }
              registeredSecrets = append(registeredSecrets, secretKey)

              // Fetch Secret and extract cert+key
              var secret = resources.secrets.GetSingle(certNamespace, certName)
              var secretData = secret | dig("data")
              var tlsCrt = secretData | dig("tls.crt") | fallback("")
              var tlsKey = secretData | dig("tls.key") | fallback("")
              if secret == nil || secretData == nil || tlsCrt == "" || tlsKey == "" {
                continue
              }

              // Combine cert and key into single PEM (HAProxy format)
              var combinedPem = (tlsCrt | b64decode()) + "\n" + (tlsKey | b64decode())

              // Register certificate file dynamically using fileRegistry
              var certFilename = certNamespace + "_" + certName + ".pem"
              fileRegistry.Register("cert", certFilename, combinedPem)

              // Register with SSL infrastructure for crt-list generation
              var sniPatterns = []any{}
              var listenerHostname = listener | dig("hostname") | fallback("")
              if listenerHostname != "" {
                sniPatterns = append(sniPatterns, listenerHostname)
              }
              var tlsCert = map[string]any{
                "secret_namespace": certNamespace,
                "secret_name": certName,
                "sni_patterns": sniPatterns,
              }
              var tlsCerts []any = globalFeatures["tlsCertificates"]
              globalFeatures["tlsCertificates"] = append(tlsCerts, tlsCert)
            %%}
          {%- end %}
        {%- end %}
      {%- end %}

  # ============================================================================
  # Route Analysis (Cached)
  # ============================================================================

  util-gateway-analysis:
    template: |
      {#- Caches route analysis in shared.gatewayAnalysis: {sortedRoutes, pathGroups, allRoutes} -#}
      {%- import "util-analyze-routes" for AnalyzeRoutes %}
      {%- if !has_cached("gatewayAnalysis") %}
        {%- shared["gatewayAnalysis"] = map[string]any{"pathGroups": map[string]any{}, "sortedRoutes": []any{}, "allRoutes": []any{}} %}
        {{- AnalyzeRoutes(shared["gatewayAnalysis"].(map[string]any)) -}}
        {%- set_cached("gatewayAnalysis", true) %}
      {%- end %}

  util-gateway-ssl-passthrough:
    template: |
      {#- Caches SSL passthrough backends in shared.gateway_ssl_passthrough.backends -#}
      {%- if !has_cached("gateway_ssl_passthrough") %}
        {%- shared["gateway_ssl_passthrough"] = map[string]any{"backends": []any{}} %}
        {%- for _, route := range resources.httproutes.List() %}
          {%%
            var hasPassthrough = false
            for _, rule := range route | dig("spec", "rules") | toSlice() {
              for _, filter := range rule | dig("filters") | toSlice() {
                var filterType = filter | dig("type") | fallback("")
                if filterType == "ExtensionRef" {
                  var kind = filter | dig("extensionRef", "kind") | fallback("")
                  var name = filter | dig("extensionRef", "name") | fallback("")
                  if kind == "SSLPassthrough" || (name != "" && (name | toLower() | regex_search("ssl.*passthrough"))) {
                    hasPassthrough = true
                  }
                }
              }
            }
            if !hasPassthrough { continue }

            var ns = route | dig("metadata", "namespace") | fallback("")
            var routeName = route | dig("metadata", "name") | fallback("")
          %%}
          {%- for _, host := range route | dig("spec", "hostnames") | toSlice() %}
            {%- if first_seen("gateway_ssl_passthrough_hosts", host) %}
              {%- var backends = shared["gateway_ssl_passthrough"].(map[string]any)["backends"].([]any) %}
              {%- shared["gateway_ssl_passthrough"].(map[string]any)["backends"] = append(backends, map[string]any{
                "name": "ssl-passthrough-" + ns + "-" + routeName,
                "sni": host, "namespace": ns, "route": routeName, "route_type": "httproute",
              }) %}
            {%- end %}
          {%- end %}
        {%- end %}
        {%- set_cached("gateway_ssl_passthrough", true) %}
      {%- end %}

  util-analyze-routes:
    template: |
      {#-
        Analyzes HTTPRoute/GRPCRoute resources and populates result with:
        - allRoutes: flat list of normalized route objects
        - pathGroups: routes grouped by host+path for conflict detection
        - sortedRoutes: routes sorted by precedence (method > headers > query > order)
      -#}
      {%- macro AnalyzeRoutes(result map[string]any) %}
        {%- var allRoutes = []any{} %}

        {#- Process HTTPRoutes #}
        {%- for _, route := range resources.httproutes.List() %}
          {%- var hostnames = route | dig("spec", "hostnames") | toSlice() %}
          {%- if len(hostnames) == 0 %}
            {%- hostnames = []any{""} %}
          {%- end %}
          {%- for _, hostname := range hostnames %}
            {%- var ruleIdx = 0 %}
            {%- for _, rule := range route | dig("spec", "rules") | toSlice() %}
              {%- var matchesList = rule | dig("matches") | toSlice() %}
              {%- if len(matchesList) == 0 %}
                {%- matchesList = []any{map[string]any{"path": map[string]any{"type": "PathPrefix", "value": "/"}}} %}
              {%- end %}

              {%- for _, match := range matchesList %}
                {%- var pathValue = match | dig("path") | coalesce(map[string]any{"type": "PathPrefix", "value": "/"}) %}
                {%- var filtersList = rule | dig("filters") | toSlice() | coalesce([]any{}) %}
                {%- var pathKey = hostname + "|" + (pathValue["type"]) + "|" + (pathValue["value"]) %}
                {%- var routeInfo = map[string]any{
                  "route": route,
                  "hostname": hostname,
                  "rule": rule,
                  "ruleIdx": ruleIdx,
                  "match": match,
                  "path": pathValue,
                  "filters": filtersList,
                  "is_grpc": false,
                  "resource_type": "httproute",
                  "pathKey": pathKey,
                } %}
                {%- allRoutes = append(allRoutes, routeInfo) %}
              {%- end %}
              {#- Increment rule counter after processing all matches for this rule #}
              {%- ruleIdx = ruleIdx + 1 %}
            {%- end %}
          {%- end %}
        {%- end %}

        {#- Process GRPCRoutes similarly #}
        {%- for _, route := range resources.grpcroutes.List() %}
          {%- var hostnames = route | dig("spec", "hostnames") | toSlice() %}
          {%- if len(hostnames) == 0 %}
            {%- hostnames = []any{""} %}
          {%- end %}
          {%- for _, hostname := range hostnames %}
            {%- var ruleIdx = 0 %}
            {%- for _, rule := range route | dig("spec", "rules") | toSlice() %}
              {%- var matchesList = rule | dig("matches") | toSlice() %}
              {%- if len(matchesList) == 0 %}
                {%- matchesList = []any{map[string]any{"method": map[string]any{}}} %}
              {%- end %}

              {%- for _, match := range matchesList %}
                {%- var filtersList = rule | dig("filters") | toSlice() | coalesce([]any{}) %}
                {%- var grpcPath = map[string]any{"type": "Exact", "value": "/"} %}
                {%- var pathKey = hostname + "|" + (grpcPath["type"]) + "|" + (grpcPath["value"]) %}
                {%- var routeInfo = map[string]any{
                  "route": route,
                  "hostname": hostname,
                  "rule": rule,
                  "ruleIdx": ruleIdx,
                  "match": match,
                  "path": grpcPath,
                  "filters": filtersList,
                  "is_grpc": true,
                  "resource_type": "grpcroute",
                  "pathKey": pathKey,
                } %}
                {%- allRoutes = append(allRoutes, routeInfo) %}
              {%- end %}
              {#- Increment rule counter after processing all matches for this rule #}
              {%- ruleIdx = ruleIdx + 1 %}
            {%- end %}
          {%- end %}
        {%- end %}

        {#- Group by path key to detect conflicts #}
        {%- var pathGroups = group_by(allRoutes, "pathKey") %}

        {#- Check for conflicts and mark routes needing VAR qualifier #}
        {%- for _, pathKey := range keys(pathGroups) %}
          {%- var routes []any = pathGroups[pathKey] %}
          {#- Check if routes in this group have different matchers #}
          {%- var hasConflicts = false %}
          {%- if len(routes) > 1 %}
            {#- Build comparison key from match conditions #}
            {%- var firstConditions = "" %}
            {%- var firstRoute = routes[0] %}
            {%- var firstMatch = firstRoute["match"] %}
            {%- var firstMethod = firstMatch["method"] %}
            {%- if firstMethod != nil %}
              {%- firstConditions = firstConditions + "method:" + (firstMethod) %}
            {%- end %}
            {%- for idx, header := range firstMatch["headers"] | toSlice() %}
              {%- firstConditions = firstConditions + ";header:" + (header["name"]) + "=" + (header["value"]) %}
            {%- end %}
            {%- for idx, param := range firstMatch["queryParams"] | toSlice() %}
              {%- firstConditions = firstConditions + ";param:" + (param["name"]) + "=" + (param["value"]) %}
            {%- end %}

            {#- Check if any other route has different conditions #}
            {%- for i := 1; i < len(routes); i++ %}
              {%- var routeConditions = "" %}
              {%- var r = routes[i] %}
              {%- var routeMatch = r["match"] %}
              {%- var routeMethod = routeMatch["method"] %}
              {%- if routeMethod != nil %}
                {%- routeConditions = routeConditions + "method:" + (routeMethod) %}
              {%- end %}
              {%- for idx, header := range routeMatch["headers"] | toSlice() %}
                {%- routeConditions = routeConditions + ";header:" + (header["name"]) + "=" + (header["value"]) %}
              {%- end %}
              {%- for idx, param := range routeMatch["queryParams"] | toSlice() %}
                {%- routeConditions = routeConditions + ";param:" + (param["name"]) + "=" + (param["value"]) %}
              {%- end %}

              {%- if firstConditions != routeConditions %}
                {%- hasConflicts = true %}
              {%- end %}
            {%- end %}
          {%- end %}

          {#- Rebuild routes list with updated dicts #}
          {%- var updatedRoutes = []any{} %}
          {%- for _, route := range routes %}
            {%- var routeObj = route["route"] %}
            {%- var routeNs = routeObj | dig("metadata", "namespace") | fallback("") %}
            {%- var routeName = routeObj | dig("metadata", "name") | fallback("") %}
            {%- var ruleIdxVal = route["ruleIdx"] %}
            {%- var routeId = routeNs + "_" + routeName + "_" + (ruleIdxVal) %}
            {%- var updatedRoute = merge(route, map[string]any{
              "hasConflicts": hasConflicts,
              "pathKey": pathKey,
              "routeId": routeId,
            }) %}
            {%- updatedRoutes = append(updatedRoutes, updatedRoute) %}
          {%- end %}

          {#- Build conflictGroup string #}
          {%- var routeIds = map_extract(updatedRoutes, "routeId") %}
          {%- var conflictGroup = join(sort_strings(routeIds), "__") %}

          {#- Add conflictGroup to each route #}
          {%- var finalRoutes = []any{} %}
          {%- for _, route := range updatedRoutes %}
            {%- var routeWithGroup = merge(route, map[string]any{"conflictGroup": conflictGroup}) %}
            {%- finalRoutes = append(finalRoutes, routeWithGroup) %}
          {%- end %}

          {#- Update pathGroups with modified routes #}
          {%- pathGroups[pathKey] = finalRoutes %}
        {%- end %}

        {#- Rebuild allRoutes from updated pathGroups #}
        {%- var finalAllRoutes = []any{} %}
        {%- for _, pathKey := range keys(pathGroups) %}
          {%- var pathRoutes []any = pathGroups[pathKey] %}
          {%- for _, route := range pathRoutes %}
            {%- finalAllRoutes = append(finalAllRoutes, route) %}
          {%- end %}
        {%- end %}

        {%- var sortedRoutes = finalAllRoutes | sort_by([]string{
          "$.path.type",
          "$.path.value | length:desc",
          "$.match.method:exists:desc",
          "$.match.headers | length:desc",
          "$.match.queryParams | length:desc",
          "$.route.metadata.creationTimestamp",
          "$.route.metadata.namespace ~ '/' ~ $.route.metadata.name",
          "$.ruleIdx",
        }) %}

        {#- Pre-compute filter existence flags (optimization: avoids repeated iteration) #}
        {%- var hasRequestHeader = false %}
        {%- var hasResponseHeader = false %}
        {%- var hasRedirect = false %}
        {%- var hasUrlrewrite = false %}
        {%- for _, route := range finalAllRoutes %}
          {%- var filters []any = route["filters"] %}
          {%- for _, filter := range filters %}
            {%- var filterType = filter["type"] %}
            {%- if filterType == "RequestHeaderModifier" %}
              {%- hasRequestHeader = true %}
            {%- else if filterType == "ResponseHeaderModifier" %}
              {%- hasResponseHeader = true %}
            {%- else if filterType == "RequestRedirect" %}
              {%- hasRedirect = true %}
            {%- else if filterType == "URLRewrite" %}
              {%- hasUrlrewrite = true %}
            {%- end %}
          {%- end %}
        {%- end %}

        {#- Populate result map with analysis data #}
        {%- result["pathGroups"] = pathGroups %}
        {%- result["sortedRoutes"] = sortedRoutes %}
        {%- result["allRoutes"] = finalAllRoutes %}
        {#- Filter existence flags for optimized filter template rendering #}
        {%- result["hasRequestHeader_filter"] = hasRequestHeader %}
        {%- result["hasResponseHeader_filter"] = hasResponseHeader %}
        {%- result["hasRedirect_filter"] = hasRedirect %}
        {%- result["hasUrlrewrite_filter"] = hasUrlrewrite %}
      {%- end macro %}

  util-backend-name-gateway:
    template: |
      {#- Macro to generate gateway backend name from route and backend info #}
      {%- macro BackendNameGateway(route any, backend any) string -%}
      gtw_{{ route | dig("metadata", "namespace") | fallback("") }}_{{ route | dig("metadata", "name") | fallback("") }}_{{ backend | dig("name") | fallback("") }}_{{ backend | dig("port") | fallback("") }}
      {%- end macro -%}

  util-route-condition:
    template: |
      {#-
        RouteIdCondition - Generates HAProxy condition to match a Gateway route by ID.

        This is the standard pattern for filter processing: check if req.gw_rule_id
        matches the specific routeId set by the advanced matchers.

        Usage:
          {%- import "util-route-condition" for RouteIdCondition -%}
          http-request set-header X-Custom "value" if {{ RouteIdCondition(routeInfo | dig("routeId")) }}
      -#}
      {%- macro RouteIdCondition(routeId string) string -%}
      { var(req.gw_rule_id) -m str "{{ routeId }}" }
      {%- end macro -%}

  util-generate-backends-gateway:
    template: |
      {#- Macro to generate backends for Gateway API routes (HTTPRoute/GRPCRoute) #}
      {#- Deduplicates backends across all routes using first_seen for deduplication tracking #}
      {#- Parameters: #}
      {#-   routes: list of routes to process (from resources.httproutes or resources.grpcroutes) #}
      {#-   protoFlag: protocol flag for default-server ("" for HTTP, "h2" for gRPC) #}
      {#-   dedupCategory: category name for first_seen deduplication #}
      {%- import "util-backend-servers" for BackendServers -%}
      {%- import "util-backend-name-gateway" for BackendNameGateway -%}
      {%- macro GenerateGatewayBackends(routes []any, protoFlag string, dedupCategory string) -%}
      {%- for _, route := range routes -%}
      {%- var routeNs = route | dig("metadata", "namespace") | fallback("") -%}
      {%- var routeName = route | dig("metadata", "name") | fallback("") -%}
      {%- for _, rule := range route | dig("spec", "rules") | toSlice() -%}
      {%- var backendRefs = rule | dig("backendRefs") -%}
      {%- if backendRefs != nil %}
      {%- for _, backendRef := range backendRefs | toSlice() -%}
      {%- var backendName = backendRef | dig("name") | fallback("") -%}
      {%- var backendPort = backendRef | dig("port") | fallback(80) -%}
      {%- var backend = map[string]any{"name": backendName, "port": backendPort} -%}
      {%- var backendKey = routeNs + "_" + routeName + "_" + backendName + "_" + (backendPort) -%}
      {%- if first_seen(dedupCategory, backendKey) -%}
      {%- var routeTypeLabel = "GRPCRoute" -%}
      {%- if protoFlag == "" -%}{%- routeTypeLabel = "HTTPRoute" -%}{%- end -%}
      # Backend for: {{ routeTypeLabel }} {{ routeNs }}/{{ routeName }} â†’ Service {{ backendName }}:{{ backendPort }}
      backend {{ BackendNameGateway(route, backend) }}
        balance roundrobin
        default-server check{%- if protoFlag != "" %} proto {{ protoFlag }}{%- end %}
        {{ BackendServers(backendName, 10, backendPort, nil) | indent(2, true) -}}
      {%- end -%}
      {%- end -%}
      {%- end -%}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  util-sharded-gateway-backends:
    template: |
      {#-
        Sharded Gateway Backend Generator

        Wraps GenerateGatewayBackends with automatic parallel sharding.
        Sharding is auto-calculated: clamp(resourceCount / 300, 1, 2 * GOMAXPROCS)
        Deduplication via first_seen() is thread-safe (uses sync.Map).
      -#}
      {%- import "util-generate-backends-gateway" for GenerateGatewayBackends -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedGatewayBackends(routes []any, protoFlag string, dedupCategory string) -%}
      {%- var n = toint(CalculateShardCount(len(routes), 100)) -%}
      {%- if n <= 1 || len(routes) < 100 -%}
      {{ GenerateGatewayBackends(routes, protoFlag, dedupCategory) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GenerateGatewayBackends(shard_slice(routes, i, n), protoFlag, dedupCategory) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  backends-500-gateway:
    template: |
      {#- Generate backend definitions from HTTPRoute and GRPCRoute resources -#}
      {%- import "util-sharded-gateway-backends" for ShardedGatewayBackends -%}
      # gateway/backends-gateway
      {{ ShardedGatewayBackends(resources.httproutes.List(), "", "gatewayBackends_http") }}
      {{- ShardedGatewayBackends(resources.grpcroutes.List(), "h2", "gatewayBackends_grpc") -}}

  backends-501-gateway-ssl-passthrough:
    template: |
      {#-
        Gateway API SSL Passthrough Backends

        Purpose:
          TCP backends for SSL passthrough from Gateway API resources.
          Forwards encrypted traffic directly to pods without SSL termination.
          Uses util-gateway-ssl-passthrough for cached analysis.

        Generated HAProxy Config:
          backend ssl-passthrough-<namespace>-<name>
            mode tcp
            server SRV_1 <pod-ip>:<pod-port> check
      -#}
      {#- Get cached SSL passthrough analysis (runs once, shared across all renders) #}
      {%- import "util-backend-servers" for BackendServers -%}
      {{ render "util-gateway-ssl-passthrough" }}

      {%- var sslPassthroughData map[string]any = shared["gateway_ssl_passthrough"] %}
      {%- var sslBackends []any = sslPassthroughData["backends"] %}
      {%- for _, backendInfo := range sslBackends %}
        {%- var biNamespace = backendInfo["namespace"] %}
        {%- var biRoute = backendInfo["route"] %}
        {%- var biName = backendInfo["name"] %}
        {%- var biRouteType = backendInfo["route_type"] %}
        {%- var routeKey = biNamespace + "/" + biRoute %}
        {%- if first_seen("gateway_ssl_passthrough_backends", routeKey) %}
          {#- Get the actual HTTPRoute resource to extract service details #}
          {%- if biRouteType == "httproute" %}
            {%- var route = resources.httproutes.GetSingle(biNamespace, biRoute) %}
            {%- var generated = false %}
            {%- for _, rule := range route | dig("spec", "rules") | toSlice() %}
              {%- if !generated %}
                {%- for _, backendRef := range rule | dig("backendRefs") | toSlice() %}
                  {%- if !generated %}
                    {%- var refName = backendRef | dig("name") | fallback("") %}
                    {%- var refPort = backendRef | dig("port") | fallback(80) %}
      # gateway/backends-gateway-ssl-passthrough

      backend {{ biName }}
          mode tcp
          balance roundrobin
          {{ BackendServers(refName, 10, refPort, nil) | indent(4, false) }}
                    {%- generated = true %}
                  {%- end %}
                {%- end %}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}

  util-path-map-entry-gateway-shard:
    template: |
      {#-
        Gateway Path Map Entry Shard Processor

        Purpose: Generates map file entries for a slice of sorted routes.
        This is the inner macro used by sharding.
      -#}
      {% macro PathMapEntryGatewayShard(sortedRoutes []any, pathGroups map[string]any, pathType string, suffix string) string %}
      {%- for _, routeInfo := range sortedRoutes %}
        {%- var riHostname = routeInfo["hostname"] %}
        {%- var riPath map[string]any = routeInfo["path"] %}
        {%- var riPath_type = riPath["type"] %}
        {%- var riPathValue = riPath["value"] %}
        {%- var pathKey = riHostname + "|" + riPath_type + "|" + riPathValue %}
        {%- if first_seen("gateway_pathMap_" + pathType + suffix, pathKey) %}
          {%- var routes []any = pathGroups[pathKey] %}
          {%- var firstRoute map[string]any = routes[0] %}
          {%- var frPath map[string]any = firstRoute["path"] %}
          {%- var frPath_type = frPath["type"] %}
        {%- if frPath != nil && frPath_type == pathType %}
          {%- var routeIds = []any{} %}
          {%- for _, r := range routes %}
            {%- var rid string = r["routeId"] %}
            {%- routeIds = append(routeIds, rid) %}
          {%- end %}
          {%- var routeIds_str = join(routeIds, "__") -%}
          {%- var frHostname = firstRoute["hostname"] %}
          {%- var frPath_val = frPath["value"] %}
          {%- var frResourceType = firstRoute["resource_type"] %}
          {%- var routeTypeShort = frResourceType | replace("httproute", "http") | replace("grpcroute", "grpc") %}
          {%- var pathSuffix = suffix %}
          {%- if suffix == "/" && hasSuffix(frPath_val, "/") %}
            {%- pathSuffix = "" %}
          {%- end %}
      {{ "\n" }}{{ frHostname }}{{ frPath_val }}{{ pathSuffix }} GW_ROUTE_ID:{{ routeTypeShort }}:{{ routeIds_str }}
        {%- end %}
        {%- end %}
      {%- end %}
      {% end %}

  util-path-map-entry-gateway:
    template: |
      {#- Sharded Gateway Path Map Entry Generator #}
      {%- import "util-path-map-entry-gateway-shard" for PathMapEntryGatewayShard -%}
      {%- import "util-macros" for CalculateShardCount -%}

      {%- macro GeneratePathMapEntries(pathType string, suffix string) %}
      # gateway/util-path-map-entry-gateway ({{ pathType }})

      {#- Get cached route analysis (runs once, shared across all renders) #}
      {{ render "util-gateway-analysis" }}

      {%- var gatewayAnalysis map[string]any = shared["gatewayAnalysis"] %}
      {%- var sortedRoutes []any = gatewayAnalysis["sortedRoutes"] %}
      {%- var pathGroups map[string]any = gatewayAnalysis["pathGroups"] %}

      {%- var n = toint(CalculateShardCount(len(sortedRoutes), 100)) -%}
      {%- if n <= 1 || len(sortedRoutes) < 100 -%}
      {{ PathMapEntryGatewayShard(sortedRoutes, pathGroups, pathType, suffix) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go PathMapEntryGatewayShard(shard_slice(sortedRoutes, i, n), pathGroups, pathType, suffix) }}
      {%- end -%}
      {%- end -%}
      {%- end macro %}

  util-generate-host-map-gateway:
    template: |
      {#- Macro to generate host map entries for Gateway API routes #}
      {%- macro GenerateHostMap(routes []any, route_type string) -%}
      {%- for _, route := range routes %}
      {%- var hostnames = route | dig("spec", "hostnames") | toSlice() %}
      {%- if len(hostnames) > 0 %}
      {%- var routeNs = route | dig("metadata", "namespace") | fallback("") %}
      {%- var routeName = route | dig("metadata", "name") | fallback("") %}
      # {{ route_type }}: {{ routeNs }}/{{ routeName }} ({{ len(hostnames) }} hosts)
      {% for _, hostname := range hostnames %}
      {{ hostname }} {{ hostname }}
      {% end %}
      {%- end %}
      {%- end %}
      {%- end macro -%}

  util-sharded-host-map-gateway:
    template: |
      {#- Sharded host map generator for Gateway API routes -#}
      {%- import "util-generate-host-map-gateway" for GenerateHostMap -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedHostMap(routes []any, route_type string) -%}
      {%- var n = toint(CalculateShardCount(len(routes), 100)) -%}
      {%- if n <= 1 || len(routes) < 100 -%}
      {{ GenerateHostMap(routes, route_type) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GenerateHostMap(shard_slice(routes, i, n), route_type) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  map-host-500-gateway:
    template: |
      {#- Generate host map entries for Gateway API routes #}
      {%- import "util-sharded-host-map-gateway" for ShardedHostMap %}
      # gateway/map-host-gateway
      {{- ShardedHostMap(resources.httproutes.List(), "HTTPRoute") -}}
      {{- ShardedHostMap(resources.grpcroutes.List(), "GRPCRoute") -}}

  map-path-exact-500-gateway:
    template: |
      {#- Generate exact path map entries for HTTPRoute #}
      {%- import "util-path-map-entry-gateway" for GeneratePathMapEntries %}
      # gateway/map-path-exact-gateway
      {{ GeneratePathMapEntries("Exact", "") }}

  map-path-prefix-exact-500-gateway:
    template: |
      {#- Generate prefix-exact path map entries for HTTPRoute #}
      {%- import "util-path-map-entry-gateway" for GeneratePathMapEntries %}
      # gateway/map-path-prefix-exact-gateway
      {{ GeneratePathMapEntries("PathPrefix", "") }}

  map-path-prefix-500-gateway:
    template: |
      {#- Generate prefix path map entries with trailing slash for HTTPRoute #}
      {%- import "util-path-map-entry-gateway" for GeneratePathMapEntries %}
      # gateway/map-path-prefix-gateway
      {{ GeneratePathMapEntries("PathPrefix", "/") }}

  util-generate-path-regex-map-gateway:
    template: |
      {#- Macro to generate regex path map entries for HTTPRoute -#}
      {%- import "util-backend-name-gateway" for BackendNameGateway -%}
      {%- macro GeneratePathRegexMap(routes []any) -%}
      {%- for _, route := range routes %}
      {%- var routeNs = route | dig("metadata", "namespace") | fallback("") %}
      {%- var routeName = route | dig("metadata", "name") | fallback("") %}
      {%- var hostnames = route | dig("spec", "hostnames") | toSlice() | coalesce([]any{""}) %}
      {%- var rules = route | dig("spec", "rules") | toSlice() | coalesce([]any{}) %}
      {%- var regexEntries = []any{} %}
      {%- for _, hostname := range hostnames %}
      {%- for _, rule := range rules %}
      {%- var backendRefs = rule | dig("backendRefs") %}
      {%- if backendRefs != nil %}
      {%- var backendRefs_slice = backendRefs | toSlice() %}
      {%- var firstBackend = backendRefs_slice[0] %}
      {%- var backend = map[string]any{"name": firstBackend | dig("name") | fallback(""), "port": firstBackend | dig("port") | fallback(80)} %}
      {%- var matches []any = rule | dig("matches") | coalesce([]any{map[string]any{}}) %}
      {%- for _, match := range matches %}
      {%- var matchPath_type = match | dig("path", "type") | fallback("") %}
      {%- var matchPathValue = match | dig("path", "value") | fallback("/") %}
      {%- if matchPath_type == "RegularExpression" %}
      {%- regexEntries = append(regexEntries, map[string]any{
        "hostname": hostname,
        "pathValue": matchPathValue,
        "backend": backend,
      }) %}
      {%- end %}
      {%- end %}
      {%- end %}
      {%- end %}
      {%- end %}
      {%- if len(regexEntries) > 0 %}
      # HTTPRoute: {{ routeNs }}/{{ routeName }} ({{ len(regexEntries) }} regex paths)
      {% for _, entry := range regexEntries -%}
      {{ entry["hostname"] }}{{ entry["pathValue"] }} {{ BackendNameGateway(route, entry["backend"]) }}
      {% end -%}
      {%- end %}
      {%- end %}
      {%- end macro -%}

  util-sharded-path-regex-map-gateway:
    template: |
      {#- Sharded regex path map generator for HTTPRoute -#}
      {%- import "util-generate-path-regex-map-gateway" for GeneratePathRegexMap -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedPathRegexMap(routes []any) -%}
      {%- var n = toint(CalculateShardCount(len(routes), 100)) -%}
      {%- if n <= 1 || len(routes) < 100 -%}
      {{ GeneratePathRegexMap(routes) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GeneratePathRegexMap(shard_slice(routes, i, n)) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  map-path-regex-500-gateway:
    template: |
      {#- Generate regex path map entries for HTTPRoute with RegularExpression type -#}
      {%- import "util-sharded-path-regex-map-gateway" for ShardedPathRegexMap %}
      # gateway/map-path-regex-gateway
      {{ ShardedPathRegexMap(resources.httproutes.List()) }}

  util-generate-weighted-backend-map-gateway:
    template: |
      {#- Macro to generate weighted backend map entries for HTTPRoute -#}
      {%- import "util-backend-name-gateway" for BackendNameGateway -%}
      {%- macro GenerateWeightedBackendMap(routes []any) -%}
      {%- for _, route := range routes %}
      {%- var routeNs = route | dig("metadata", "namespace") | fallback("") %}
      {%- var routeName = route | dig("metadata", "name") | fallback("") %}
      {%- var rules = route | dig("spec", "rules") | toSlice() | coalesce([]any{}) %}
      {%- var weightedEntries = []any{} %}
      {%- var ruleIdx = 0 %}
      {%- for _, rule := range rules %}
        {%- var backendRefs = rule | dig("backendRefs") %}
        {%- if backendRefs != nil %}
          {%- var refsSlice = backendRefs | toSlice() %}
          {%- if len(refsSlice) > 1 %}
            {%- var routeKey = routeNs + "_" + routeName + "_" + ruleIdx %}
            {%- var cumulative = 0 %}
            {%- for _, backendRef := range refsSlice %}
              {%- var backend = map[string]any{"name": backendRef | dig("name") | fallback(""), "port": backendRef | dig("port") | fallback(80)} %}
              {%- var weight = backendRef | dig("weight") | fallback(1) %}
              {%- for i := cumulative; i < cumulative + weight; i++ %}
                {%- weightedEntries = append(weightedEntries, map[string]any{
                  "index": i,
                  "routeKey": routeKey,
                  "backend": backend,
                }) %}
              {%- end %}
              {%- cumulative = cumulative + weight %}
            {%- end %}
          {%- end %}
        {%- end %}
        {%- ruleIdx = ruleIdx + 1 %}
      {%- end %}
      {%- if len(weightedEntries) > 0 %}
      # HTTPRoute: {{ routeNs }}/{{ routeName }} (weighted rules)
      {% for _, entry := range weightedEntries -%}
      {{ entry["index"] }}:{{ entry["routeKey"] }} {{ BackendNameGateway(route, entry["backend"]) }}
      {% end -%}
      {%- end %}
      {%- end %}
      {%- end macro -%}

  util-sharded-weighted-backend-map-gateway:
    template: |
      {#- Sharded weighted backend map generator for HTTPRoute -#}
      {%- import "util-generate-weighted-backend-map-gateway" for GenerateWeightedBackendMap -%}
      {%- import "util-macros" for CalculateShardCount -%}
      {%- macro ShardedWeightedBackendMap(routes []any) -%}
      {%- var n = toint(CalculateShardCount(len(routes), 100)) -%}
      {%- if n <= 1 || len(routes) < 100 -%}
      {{ GenerateWeightedBackendMap(routes) }}
      {%- else -%}
      {%- for i := 0; i < n; i++ -%}
      {{ go GenerateWeightedBackendMap(shard_slice(routes, i, n)) }}
      {%- end -%}
      {%- end -%}
      {%- end macro -%}

  map-weighted-backend-500-gateway:
    template: |
      {#- Generate weighted backend map entries for HTTPRoute -#}
      {%- import "util-sharded-weighted-backend-map-gateway" for ShardedWeightedBackendMap %}
      # gateway/map-weighted-backend-gateway
      {{ ShardedWeightedBackendMap(resources.httproutes.List()) }}

  # Advanced matcher setup - processes GW_ROUTE_ID qualifier (runs early)
  # Named with 010- prefix so alphabetical sort matches intended execution order
  frontend-matchers-advanced-010-route-id-setup:
    template: |
      {#- Process GW_ROUTE_ID qualifier to extract route type and route ID #}
      {#- Format: GW_ROUTE_ID:<route_type>:<routeIds> #}
      {#- Example: GW_ROUTE_ID:http:ns1_route1_0__ns2_route2_1 #}
      {#- This runs first (010 prefix) to set variables used by later matchers #}
      # gateway/frontend-matchers-advanced-010-route-id-setup
      http-request set-var(req.gw_route_type) var(txn.path_match),field(2,:) if { var(txn.path_match),field(1,:) -m str GW_ROUTE_ID }
      http-request set-var(req.gw_routeId) var(txn.path_match),field(3,:) if { var(txn.path_match),field(1,:) -m str GW_ROUTE_ID }

  # Advanced matcher generator - creates http-request statements for method/header/query matching
  # Named with 500- prefix so alphabetical sort matches intended execution order (runs after 010-)
  frontend-matchers-advanced-500-gateway:
    template: |
      {{- "" }}
      {# Generate http-request statements for routes with advanced matchers
         This is injected into base template via the advanced-matcher-* extension point #}
      # gateway/frontend-matchers-advanced-500-gateway
      {{ render "util-gateway-analysis" -}}
      {%- var gatewayAnalysis map[string]any = shared["gatewayAnalysis"] %}
      {%- var sortedRoutes []any = gatewayAnalysis["sortedRoutes"] %}
      {%- if len(sortedRoutes) > 0 %}
      # Advanced route matching (method/header/query)
      {%- for _, routeInfo := range sortedRoutes %}
        {%- var riMatch map[string]any = routeInfo["match"] %}
        {%- var riRoute map[string]any = routeInfo["route"] %}
        {%- var riRouteMeta = riRoute | dig("metadata") %}
        {%- var riResourceType = routeInfo["resource_type"] %}
        {%- var riIsGrpc bool = routeInfo["is_grpc"] %}
        {%- var riRouteId = routeInfo["routeId"] %}
        {%- var riConflictGroup = routeInfo["conflictGroup"] %}
        {%- var riRuleIdx = routeInfo["ruleIdx"] %}
        {#- Early exit: skip if another matcher already won #}
        {%- var conditions = []any{"!{ var(req.gw_rule_id) -m found }"} %}

        {#- Only run matcher if this route was matched by the map #}
        {%- conditions = append(conditions, "{ var(req.gw_routeId) -m str \"" + riConflictGroup + "\" }") %}

        {#- Method matcher (HTTPRoute only) #}
        {%- var riMethod = riMatch["method"] %}
        {%- if riMethod != nil && riResourceType == "httproute" %}
          {%- conditions = append(conditions, "{ method " + (riMethod) + " }") %}
        {%- end %}

        {#- Header matchers #}
        {%- var riHeaders = riMatch["headers"] %}
        {%- for _, header := range riHeaders | toSlice() %}
          {%- var headerType = header["type"] %}
          {%- var headerName = header["name"] %}
          {%- var headerValue = header["value"] %}
          {%- if headerType == "Exact" %}
            {%- conditions = append(conditions, "{ req.hdr(" + headerName + ") \"" + headerValue + "\" }") %}
          {%- else if headerType == "RegularExpression" %}
            {#- Escape $ as \$ for HAProxy config (prevents env var expansion) #}
            {%- var escapedHeaderValue = replace(headerValue, "$", "\\$") %}
            {%- conditions = append(conditions, "{ req.hdr(" + headerName + ") -m reg \"" + escapedHeaderValue + "\" }") %}
          {%- end %}
        {%- end %}

        {#- Query parameter matchers (HTTPRoute only) #}
        {%- var riParams = riMatch["queryParams"] %}
        {%- for _, param := range riParams | toSlice() %}
          {%- var paramType = param["type"] %}
          {%- var paramName = param["name"] %}
          {%- var paramValue = param["value"] %}
          {%- if paramType == "Exact" %}
            {%- conditions = append(conditions, "{ urlp(" + paramName + ") \"" + paramValue + "\" }") %}
          {%- else if paramType == "RegularExpression" %}
            {#- Escape $ as \$ for HAProxy config (prevents env var expansion) #}
            {%- var escapedParamValue = replace(paramValue, "$", "\\$") %}
            {%- conditions = append(conditions, "{ urlp(" + paramName + ") -m reg \"" + escapedParamValue + "\" }") %}
          {%- end %}
        {%- end %}

        {#- GRPCRoute method matcher #}
        {%- var grpcMethod = riMatch["method"] %}
        {%- if riIsGrpc && grpcMethod != nil %}
          {%- var grpcMethod_map map[string]any = grpcMethod %}
          {%- var grpcService = grpcMethod_map["service"] %}
          {%- if grpcService != nil %}
            {%- var grpcPath = "/" + (grpcService) %}
            {%- var grpcMethod_name = grpcMethod_map["method"] %}
            {%- if grpcMethod_name != nil %}
              {%- grpcPath = grpcPath + "/" + (grpcMethod_name) %}
            {%- end %}
            {#- Match against :path header which contains gRPC method #}
            {%- var grpcType = grpcMethod_map["type"] %}
            {%- if grpcType == "Exact" %}
              {%- conditions = append(conditions, "{ req.hdr(:path) \"" + grpcPath + "\" }") %}
            {%- else if grpcType == "RegularExpression" %}
              {#- Escape $ as \$ for HAProxy config (prevents env var expansion) #}
              {%- var escapedGrpcPath = replace(grpcPath, "$", "\\$") %}
              {%- conditions = append(conditions, "{ req.hdr(:path) -m reg \"" + escapedGrpcPath + "\" }") %}
            {%- end %}
          {%- end %}
        {%- end %}

        {#- Set req.gw_rule_id to mark this rule as winner #}
        {%- if len(conditions) > 0 %}
          {#- Build matcher type description for provenance comment #}
          {%- var descParts = []any{} %}
          {%- if riMethod != nil && riResourceType == "httproute" %}
            {%- descParts = append(descParts, "method " + (riMethod)) %}
          {%- end %}
          {%- if riHeaders != nil %}
            {%- descParts = append(descParts, len(toSlice(riHeaders)) + " headers") %}
          {%- end %}
          {%- if riParams != nil %}
            {%- descParts = append(descParts, len(toSlice(riParams)) + " query params") %}
          {%- end %}
          {%- if riIsGrpc && grpcMethod != nil %}
            {%- descParts = append(descParts, "gRPC method") %}
          {%- end %}
          {%- var matcherDesc = "path-only" %}
          {%- if len(descParts) > 0 %}{%- matcherDesc = join(descParts, ", ") %}{%- end %}
          {%- var riNs = riRouteMeta | dig("namespace") | fallback("") %}
          {%- var riName = riRouteMeta | dig("name") | fallback("") %}
      # Rule: {{ riResourceType | title() }} {{ riNs }}/{{ riName }} rule[{{ riRuleIdx }}] - {{ matcherDesc }}
      http-request set-var(req.gw_rule_id) str({{ riRouteId }}) if {{ join(conditions, " ") }}
          {#- Debug headers if enabled #}
          {%- if debug | fallback(false) %}
            {#- Build detailed match reason #}
            {%- var matchTypes = []any{} %}
            {%- if riMethod != nil && riResourceType == "httproute" %}
              {%- matchTypes = append(matchTypes, "method") %}
            {%- end %}
            {%- if riHeaders != nil %}
              {%- matchTypes = append(matchTypes, "header") %}
            {%- end %}
            {%- if riParams != nil %}
              {%- matchTypes = append(matchTypes, "query") %}
            {%- end %}
            {%- if riIsGrpc && grpcMethod != nil %}
              {%- matchTypes = append(matchTypes, "grpc-method") %}
            {%- end %}
            {%- var matchTypes_str = "advanced" %}
            {%- if len(matchTypes) > 0 %}{%- matchTypes_str = join(matchTypes, "+") %}{%- end %}
      http-request set-var(txn.matched_route) str({{ riNs }}/{{ riName }}/rule{{ riRuleIdx }}) if {{ join(conditions, " ") }}
      http-request set-var(txn.match_reason) str({{ matchTypes_str }}) if {{ join(conditions, " ") }}
          {% end %}
        {% end %}
      {% end %}
      {% end %}

  # Path match setting - sets txn.path_match based on winning rule ID
  # Named with 900- prefix so alphabetical sort matches intended execution order (runs last)
  frontend-matchers-advanced-900-path-match:
    template: |
      {{- "" }}
      {# Set txn.path_match for backend selection based on winning rule
         Runs after frontend-matchers-advanced-500-gateway sets req.gw_rule_id (900 prefix ensures late ordering) #}
      # gateway/frontend-matchers-advanced-900-path-match
      {{ render "util-gateway-analysis" -}}

      {%- var gatewayAllRoutes = shared.gatewayAnalysis.allRoutes | toSlice() %}
      {%- if len(gatewayAllRoutes) > 0 %}
      # Set txn.path_match for backend selection based on req.gw_rule_id
      {% for _, routeInfo := range gatewayAllRoutes -%}
        {%- var backendRefs []any = routeInfo | dig("rule", "backendRefs") | fallback([]any{}) %}
        {%- if len(backendRefs) > 0 %}
          {%- var qualifier = "" %}
          {%- if len(backendRefs) == 1 %}
            {#- Single backend: BACKEND qualifier #}
            {%- var backendRef map[string]any = backendRefs[0] %}
            {%- var backendName = "gtw_" + (routeInfo | dig("route", "metadata", "namespace")) + "_" + (routeInfo | dig("route", "metadata", "name")) + "_" + (backendRef["name"]) + "_" + (backendRef["port"]) %}
            {%- qualifier = "BACKEND:" + backendName %}
          {%- else %}
            {#- Multiple backends: MULTIBACKEND qualifier #}
            {%- var totalWeight = 0 %}
            {%- for _, ref := range backendRefs %}
              {%- var refMap map[string]any = ref %}
              {%- var weight = refMap | dig("weight") | fallback(1) %}
              {%- totalWeight = totalWeight + (weight) %}
            {%- end %}
            {%- var routeKey = (routeInfo | dig("route", "metadata", "namespace")) + "_" + (routeInfo | dig("route", "metadata", "name")) + "_" + (routeInfo | dig("ruleIdx")) %}
            {%- qualifier = "MULTIBACKEND:" + totalWeight + ":" + routeKey %}
          {%- end %}
      http-request set-var(txn.path_match) str({{ qualifier }}) if { var(req.gw_rule_id) -m str "{{ routeInfo | dig("routeId") }}" }
        {% end %}
      {% end %}
      {% end %}
  # Filter: RequestHeaderModifier - modifies request headers before backend selection
  frontend-filters-500-gateway-request-header:
    template: |
      {#- RequestHeaderModifier: set, add, or remove request headers -#}
      {%- import "util-route-condition" for RouteIdCondition -%}
      {{- render "util-gateway-analysis" -}}
      {%- if shared.gatewayAnalysis.hasRequestHeader_filter %}
      # gateway/frontend-filters-gateway-request-header
      {%- for _, routeInfo := range shared.gatewayAnalysis.allRoutes | toSlice() %}
        {%- for _, filter := range routeInfo | dig("filters") | fallback([]any{}) %}
          {%- if (filter | dig("type")) == "RequestHeaderModifier" %}
            {%- var routeId = routeInfo | dig("routeId") | tostring() %}
            {%- var cond = RouteIdCondition(routeId) %}
            {%- var mod = filter | dig("requestHeaderModifier") %}
            {%- if mod != nil %}
              {%- for _, h := range mod | dig("set") | fallback([]any{}) %}
      http-request set-header {{ h | dig("name") }} "{{ h | dig("value") }}" if {{ cond }}
              {%- end %}
              {%- for _, h := range mod | dig("add") | fallback([]any{}) %}
      http-request add-header {{ h | dig("name") }} "{{ h | dig("value") }}" if {{ cond }}
              {%- end %}
              {%- for _, name := range mod | dig("remove") | fallback([]any{}) %}
      http-request del-header {{ name }} if {{ cond }}
              {%- end %}
              {%- if debug | fallback(false) %}
      http-request set-var(txn.filters_applied) str(RequestHeaderModifier) if {{ cond }} !{ var(txn.filters_applied) -m found }
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}
      {%- end %}
  # Filter: ResponseHeaderModifier - modifies response headers before sending to client
  frontend-filters-500-gateway-response-header:
    template: |
      {#- ResponseHeaderModifier: set, add, or remove response headers -#}
      {%- import "util-route-condition" for RouteIdCondition -%}
      {{- render "util-gateway-analysis" -}}
      {%- if shared.gatewayAnalysis.hasResponseHeader_filter %}
      # gateway/frontend-filters-gateway-response-header
      {%- for _, routeInfo := range shared.gatewayAnalysis.allRoutes | toSlice() %}
        {%- for _, filter := range routeInfo | dig("filters") | fallback([]any{}) %}
          {%- if (filter | dig("type")) == "ResponseHeaderModifier" %}
            {%- var routeId = routeInfo | dig("routeId") | tostring() %}
            {%- var cond = RouteIdCondition(routeId) %}
            {%- var mod = filter | dig("responseHeaderModifier") %}
            {%- if mod != nil %}
              {%- if debug | fallback(false) %}
      http-request set-var(txn.filters_applied) str(ResponseHeaderModifier) if {{ cond }} !{ var(txn.filters_applied) -m found }
              {%- end %}
              {%- for _, h := range mod | dig("set") | fallback([]any{}) %}
      http-response set-header {{ h | dig("name") }} "{{ h | dig("value") }}" if {{ cond }}
              {%- end %}
              {%- for _, h := range mod | dig("add") | fallback([]any{}) %}
      http-response add-header {{ h | dig("name") }} "{{ h | dig("value") }}" if {{ cond }}
              {%- end %}
              {%- for _, name := range mod | dig("remove") | fallback([]any{}) %}
      http-response del-header {{ name }} if {{ cond }}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}
      {%- end %}
  # Filter: RequestRedirect - redirects requests to different locations
  frontend-filters-500-gateway-redirect:
    template: |
      {#- RequestRedirect: redirect to different scheme, host, port, or path -#}
      {%- import "util-route-condition" for RouteIdCondition -%}
      {{- render "util-gateway-analysis" -}}
      {%- if shared.gatewayAnalysis.hasRedirect_filter %}
      # gateway/frontend-filters-gateway-redirect
      {%- for _, routeInfo := range shared.gatewayAnalysis.allRoutes | toSlice() %}
        {%- for _, filter := range routeInfo | dig("filters") | fallback([]any{}) %}
          {%- if (filter | dig("type")) == "RequestRedirect" && (routeInfo | dig("resource_type")) == "httproute" %}
            {%- var routeId = routeInfo | dig("routeId") | tostring() %}
            {%- var cond = RouteIdCondition(routeId) %}
            {%- var redir = filter | dig("requestRedirect") %}
            {%- if redir != nil %}
              {%- var parts = []any{} %}
              {#- Scheme -#}
              {%- var scheme = redir | dig("scheme") | fallback("") %}
              {%- if scheme != "" %}{%- parts = append(parts, "scheme " + scheme) %}{%- end %}
              {#- Path modification -#}
              {%- var pathMod = redir | dig("path") %}
              {%- if pathMod != nil %}
                {%- var pathType = pathMod | dig("type") %}
                {%- if pathType == "ReplaceFullPath" %}
                  {%- var s = redir | dig("scheme") | fallback("http") %}
                  {%- var h = redir | dig("hostname") | fallback("%[req.hdr(Host)]") %}
                  {%- var p = redir | dig("port") | fallback("") %}
                  {%- var fullPath = pathMod | dig("replaceFullPath") %}
                  {%- var loc = s + "://" + h %}
                  {%- if p != "" %}{%- loc = loc + ":" + p %}{%- end %}
                  {%- parts = append(parts, "location \"" + loc + fullPath + "\"") %}
                {%- else if pathType == "ReplacePrefixMatch" %}
                  {%- parts = append(parts, "prefix \"" + (pathMod | dig("replacePrefixMatch")) + "\"") %}
                {%- end %}
              {%- else %}
                {#- Hostname/port change without path modification -#}
                {%- var h = redir | dig("hostname") | fallback("") %}
                {%- var p = redir | dig("port") | fallback("") %}
                {%- if h != "" || p != "" %}
                  {%- var s = redir | dig("scheme") | fallback("http") %}
                  {%- var host = redir | dig("hostname") | fallback("%[req.hdr(Host)]") %}
                  {%- var loc = s + "://" + host %}
                  {%- if p != "" %}{%- loc = loc + ":" + p %}{%- end %}
                  {%- parts = append(parts, "location \"" + loc + "%[path]\"") %}
                {%- end %}
              {%- end %}
              {%- parts = append(parts, "code " + (redir | dig("statusCode") | fallback(302))) %}
              {%- if debug | fallback(false) %}
      http-request set-var(txn.filters_applied) str(RequestRedirect) if {{ cond }} !{ var(txn.filters_applied) -m found }
              {%- end %}
      http-request redirect {{ parts | join(" ") }} if {{ cond }}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}
      {%- end %}
  # Filter: URLRewrite - rewrites request URLs before sending to backend
  frontend-filters-500-gateway-urlrewrite:
    template: |
      {#- URLRewrite: rewrite hostname or path before backend -#}
      {%- import "util-route-condition" for RouteIdCondition -%}
      {{- render "util-gateway-analysis" -}}
      {%- if shared.gatewayAnalysis.hasUrlrewrite_filter %}
      # gateway/frontend-filters-gateway-urlrewrite
      {%- for _, routeInfo := range shared.gatewayAnalysis.allRoutes | toSlice() %}
        {%- for _, filter := range routeInfo | dig("filters") | fallback([]any{}) %}
          {%- if (filter | dig("type")) == "URLRewrite" && (routeInfo | dig("resource_type")) == "httproute" %}
            {%- var routeId = routeInfo | dig("routeId") | tostring() %}
            {%- var cond = RouteIdCondition(routeId) %}
            {%- var rw = filter | dig("urlRewrite") %}
            {%- if rw != nil %}
              {%- if debug | fallback(false) %}
      http-request set-var(txn.filters_applied) str(URLRewrite) if {{ cond }} !{ var(txn.filters_applied) -m found }
              {%- end %}
              {%- var hostname = rw | dig("hostname") | fallback("") %}
              {%- if hostname != "" %}
      http-request set-header Host "{{ hostname }}" if {{ cond }}
              {%- end %}
              {%- var pathMod = rw | dig("path") %}
              {%- if pathMod != nil %}
                {%- var pathType = pathMod | dig("type") %}
                {%- if pathType == "ReplaceFullPath" %}
      http-request set-path "{{ pathMod | dig("replaceFullPath") }}" if {{ cond }}
                {%- else if pathType == "ReplacePrefixMatch" %}
                  {%- var origPrefix = routeInfo | dig("path", "value") %}
                  {%- var regexPrefix = origPrefix | replace(".", "\\.") | replace("/", "\\/") %}
      http-request replace-path "^{{ regexPrefix }}(.*)" "{{ pathMod | dig("replacePrefixMatch") }}\\1" if {{ cond }}
                {%- end %}
              {%- end %}
            {%- end %}
          {%- end %}
        {%- end %}
      {%- end %}
      {%- end %}

validationTests:
  test-httproute-duplicate-backend-different-ports:
    description: HTTPRoute with multiple rules to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-svc
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: admin
                port: 81
                targetPort: 8081
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-svc
          endpoints:
            - addresses: ["10.0.0.1"]
              targetRef:
                name: api-pod-1
          ports:
            - port: 8080
            - port: 8081
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: multi-port
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: api-svc
                    port: 80
              - matches:
                  - path:
                      type: PathPrefix
                      value: /admin
                backendRefs:
                  - name: api-svc
                    port: 81
              - matches:
                  - path:
                      type: PathPrefix
                      value: /app
                backendRefs:
                  - name: api-svc
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_api-svc_80"
        description: Must generate backend for port 80

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_api-svc_81"
        description: Must generate backend for port 81

      - type: match_count
        target: haproxy.cfg
        pattern: "(?m)^backend gtw_default_multi-port_api-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

  test-grpcroute-duplicate-backend-different-ports:
    description: GRPCRoute with multiple rules to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-svc
            namespace: default
          spec:
            ports:
              - name: grpc
                port: 9090
                targetPort: 9090
              - name: grpc-admin
                port: 9091
                targetPort: 9091
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-svc
          endpoints:
            - addresses: ["10.0.0.2"]
              targetRef:
                name: grpc-pod-1
          ports:
            - port: 9090
            - port: 9091
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: multi-port
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9090
              - matches:
                  - method:
                      type: Exact
                      service: com.example.Admin
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9091
              - matches:
                  - method:
                      type: Exact
                      service: com.example.App
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_grpc-svc_9090"
        description: Must generate backend for port 9090

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_grpc-svc_9091"
        description: Must generate backend for port 9091

      - type: match_count
        target: haproxy.cfg
        pattern: "(?m)^backend gtw_default_multi-port_grpc-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

  test-httproute-weight-two-backends:
    description: HTTPRoute with two weighted backends (70/30 split)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: split-route
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - split.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /app
                backendRefs:
                  - name: app-v1
                    port: 80
                    weight: 70
                  - name: app-v2
                    port: 80
                    weight: 30
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_split-route_app-v1_80"
        description: Must generate backend for app-v1

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_split-route_app-v2_80"
        description: Must generate backend for app-v2

      - type: contains
        target: map:path-prefix.map
        pattern: "split.example.com/app GW_ROUTE_ID:http:default_split-route_0"
        description: Path map must use GW_ROUTE_ID qualifier

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_split-route_0 gtw_default_split-route_app-v1_80"
        description: Weighted map must contain first entry for v1

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "69:default_split-route_0 gtw_default_split-route_app-v1_80"
        description: Weighted map must contain last entry for v1 (weight 70 = entries 0-69)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "70:default_split-route_0 gtw_default_split-route_app-v2_80"
        description: Weighted map must contain first entry for v2

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "99:default_split-route_0 gtw_default_split-route_app-v2_80"
        description: Weighted map must contain last entry for v2 (weight 30 = entries 70-99)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_split-route_0 gtw_default_split-route_app-v1_801:default_split-route_0"
        description: Entries must be on separate lines (not concatenated)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "69:default_split-route_0 gtw_default_split-route_app-v1_8070:default_split-route_0"
        description: Boundary entries (v1 end / v2 start) must be on separate lines

      # Map Formatting Tests - Ensure comments don't concatenate with entries
      - type: not_contains
        target: map:host.map
        pattern: "hosts\\)\\S"
        description: Host map comments must not concatenate with entries (Gateway API)

      - type: not_contains
        target: map:path-prefix.map
        pattern: "paths\\)\\S"
        description: Path prefix map comments must not concatenate with entries (Gateway API)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "rules\\)\\S"
        description: Weighted map comments must not concatenate with entries

      - type: contains
        target: map:host.map
        pattern: "(?m)^split\\.example\\.com split\\.example\\.com$"
        description: Host map entries must start at beginning of line (Gateway API)

      - type: contains
        target: map:path-prefix.map
        pattern: "(?m)^split\\.example\\.com/app GW_ROUTE_ID:"
        description: Path map entries must start at beginning of line (Gateway API)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "(?m)^\\d+:default_split-route_0 gtw_"
        description: Weighted map entries must start at beginning of line

  test-httproute-weight-no-matches:
    description: HTTPRoute with no matches block defaults to PathPrefix /
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: default-path
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - default.example.com
            rules:
              - backendRefs:
                  - name: app-v1
                    port: 80
                    weight: 50
                  - name: app-v2
                    port: 80
                    weight: 50
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "default.example.com/ GW_ROUTE_ID:http:default_default-path_0"
        description: Missing matches must default to PathPrefix / with weight 100

  test-httproute-weight-default:
    description: HTTPRoute with default weights (omitted weight defaults to 1)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: default-weight
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - weight.example.com
            rules:
              - matches:
                  - path:
                      type: Exact
                      value: /test
                backendRefs:
                  - name: app-v1
                    port: 80
                  - name: app-v2
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-exact.map
        pattern: "weight.example.com/test GW_ROUTE_ID:http:default_default-weight_0"
        description: Omitted weights must default to 1 (total weight = 2)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_default-weight_0 gtw_default_default-weight_app-v1_80"
        description: Default weight creates single entry for v1

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "1:default_default-weight_0 gtw_default_default-weight_app-v2_80"
        description: Default weight creates single entry for v2

  test-httproute-single-backend:
    description: HTTPRoute with single backend uses BACKEND qualifier
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app
          endpoints:
            - addresses: ["10.0.3.1"]
              targetRef:
                name: app-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: single-backend
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - single.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                backendRefs:
                  - name: app
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_single-backend_app_80"
        description: Must generate backend for single backend

      - type: contains
        target: map:path-prefix.map
        pattern: "single.example.com/ GW_ROUTE_ID:http:default_single-backend_0"
        description: Single backend must use GW_ROUTE_ID qualifier

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "default_single-backend"
        description: Single backend must not generate weighted-multi-backend entries

  test-httproute-method-matching:
    description: HTTPRoute with method matching (GET vs POST to same path)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: read-service
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: write-service
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: read-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: read-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: write-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: write-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: method-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                backendRefs:
                  - name: read-service
                    port: 80
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                backendRefs:
                  - name: write-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http"
        description: Conflicting paths must use GW_ROUTE_ID qualifier

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_method-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_method-route_0__default_method-route_1\" \\} \\{ method GET \\}"
        description: Must generate req.gw_rule_id for GET method

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_method-route_1\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_method-route_0__default_method-route_1\" \\} \\{ method POST \\}"
        description: Must generate req.gw_rule_id for POST method

  test-httproute-multi-hostname-map-newlines:
    description: HTTPRoute with 3 hostnames must generate separate map file lines
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app
          endpoints:
            - addresses: ["10.0.0.1"]
              targetRef:
                name: app-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: multi-host
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - one.example.com
              - two.example.com
              - three.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                backendRefs:
                  - name: app
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: not_contains
        target: map:host.map
        pattern: "one\\.example\\.com one\\.example\\.comtwo\\.example\\.com"
        description: Host map must NOT concatenate hostnames without newlines (bug detection)

      - type: match_count
        target: map:host.map
        pattern: "(?m)^.*\\.example\\.com .*\\.example\\.com$"
        expected: "3"
        description: Host map must have exactly 3 separate lines for hostnames

  test-grpcroute-multi-hostname-map-newlines:
    description: GRPCRoute with 3 hostnames must generate separate map file lines
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-app
            namespace: default
          spec:
            ports:
              - name: grpc
                port: 9090
                targetPort: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-app-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-app
          endpoints:
            - addresses: ["10.0.0.3"]
              targetRef:
                name: grpc-app-pod-1
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: multi-host-grpc
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - one.example.com
              - two.example.com
              - three.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.Service
                      method: TestMethod
                backendRefs:
                  - name: grpc-app
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: not_contains
        target: map:host.map
        pattern: "one\\.example\\.com one\\.example\\.comtwo\\.example\\.com"
        description: Host map must NOT concatenate hostnames without newlines (bug detection)

      - type: match_count
        target: map:host.map
        pattern: "(?m)^.*\\.example\\.com .*\\.example\\.com$"
        expected: "3"
        description: Host map must have exactly 3 separate lines for hostnames

  test-httproute-header-exact:
    description: HTTPRoute with exact header matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: v1-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: v1-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: v1-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: header-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v1
                backendRefs:
                  - name: v1-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_header-route_0\" \\} \\{ req\\.hdr\\(X-Version\\) \"v1\" \\}"
        description: Must generate header exact match condition

  test-httproute-header-regex:
    description: HTTPRoute with regex header matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-header-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: RegularExpression
                        name: User-Agent
                        value: "^Mozilla.*"
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_regex-header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_regex-header-route_0\" \\} \\{ req\\.hdr\\(User-Agent\\) -m reg \"\\^Mozilla\\.\\*\" \\}"
        description: Must generate header regex match condition

  test-httproute-query-params:
    description: HTTPRoute with query parameter matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: search-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: search-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: search-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: query-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /search
                    queryParams:
                      - type: Exact
                        name: version
                        value: v2
                      - type: RegularExpression
                        name: filter
                        value: "^active.*"
                backendRefs:
                  - name: search-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_query-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_query-route_0\" \\} \\{ urlp\\(version\\) \"v2\" \\} \\{ urlp\\(filter\\) -m reg \"\\^active\\.\\*\" \\}"
        description: Must generate query parameter match conditions

  test-httproute-regex-dollar-escaping:
    description: HTTPRoute with query parameter regex containing dollar signs for anchoring
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-dollar-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    queryParams:
                      - type: RegularExpression
                        name: token
                        value: "^secret[0-9]+$"
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_regex-dollar-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_regex-dollar-route_0\" \\} \\{ urlp\\(token\\) -m reg \"\\^secret\\[0-9\\]\\+\\\\\\$\" \\}"
        description: Must generate query parameter regex with escaped dollar sign

  test-httproute-precedence:
    description: Complex precedence ordering with multiple conflicting routes
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc1
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc2
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc3
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc1
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc3-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc3
          endpoints:
            - addresses: ["10.0.3.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route1
            namespace: default
            creationTimestamp: "2024-01-01T00:00:00Z"
          spec:
            hostnames:
              - example.com
            rules:
              # Most specific: /api/v1/users with method and headers
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1/users
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Auth
                        value: token
                backendRefs:
                  - name: svc1
                    port: 80
              # Less specific: /api/v1 with just method
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1
                    method: GET
                backendRefs:
                  - name: svc2
                    port: 80
              # Least specific: /api with no extra matchers
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: svc3
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      # Verify routes are ordered by Gateway API precedence (most specific first)
      - type: match_order
        target: map:path-prefix.map
        patterns:
          - "/api/v1/users.*default_route1_0"   # Most specific: longest path + method + headers
          - "/api/v1[^/].*default_route1_1"      # Medium: medium path + method
          - "/api[^/].*default_route1_2"         # Least specific: shortest path, no extra matchers
        description: Routes must be ordered by Gateway API precedence (most specific first)

  test-httproute-same-path-matcher-precedence:
    description: Routes with SAME path sorted by matcher specificity (method/headers/query)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc-main
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc-v2
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc-main-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc-main
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc-v2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: precedence-test
            namespace: default
            creationTimestamp: "2024-01-01T00:00:00Z"
          spec:
            hostnames:
              - test.example.com
            rules:
              # RULE 0: Medium precedence - GET + 1 header
              # Declared FIRST but should sort to position 2
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v1
                backendRefs:
                  - name: svc-main
                    port: 80
              # RULE 1: Lowest precedence - No matchers (catch-all)
              # Declared SECOND but should sort to position 4 (last)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                backendRefs:
                  - name: svc-main
                    port: 80
              # RULE 2: Highest precedence - GET + 2 headers + 1 query
              # Declared THIRD but should sort to position 1 (first)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v2
                      - type: Exact
                        name: X-Environment
                        value: prod
                    queryParams:
                      - type: Exact
                        name: debug
                        value: "true"
                backendRefs:
                  - name: svc-v2
                    port: 80
              # RULE 3: Low precedence - GET only
              # Declared FOURTH but should sort to position 3
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                backendRefs:
                  - name: svc-v2
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      # Verify all 4 rules are present (including catch-all)
      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_0'
        description: Rule 0 (GET + 1 header) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_1'
        description: Rule 1 (catch-all) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_2'
        description: Rule 2 (GET + 2 headers + 1 query) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_3'
        description: Rule 3 (GET only) must be present

  test-httproute-weighted-with-matchers:
    description: Weighted routing combined with method/header matchers
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: canary-v1
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: canary-v2
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: canary-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: canary-v1
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: canary-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: canary-v2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: canary-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Canary
                        value: "true"
                backendRefs:
                  - name: canary-v1
                    port: 80
                    weight: 90
                  - name: canary-v2
                    port: 80
                    weight: 10
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_canary-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_canary-route_0\" \\} \\{ method GET \\} \\{ req\\.hdr\\(X-Canary\\) \"true\" \\}"
        description: Must generate req.gw_rule_id with conditions

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_canary-route_0 gtw_default_canary-route_canary-v1_80"
        description: Weighted map must contain v1 entries

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "90:default_canary-route_0 gtw_default_canary-route_canary-v2_80"
        description: Weighted map must contain v2 entries

  test-httproute-same-route-conflicts:
    description: Multiple rules in same HTTPRoute with path conflicts
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: auth-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: public-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: auth-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: auth-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: public-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: public-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: multi-rule
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              # Rule 0: /api with auth header
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: Authorization
                        value: Bearer
                backendRefs:
                  - name: auth-service
                    port: 80
              # Rule 1: /api without auth (conflicts with rule 0)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: public-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http:default_multi-rule_0__default_multi-rule_1"
        description: Same route conflicts must include both rule indices

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_multi-rule_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_multi-rule_0__default_multi-rule_1\" \\} \\{ req\\.hdr\\(Authorization\\) \"Bearer\" \\}"
        description: Must set req.gw_rule_id for rule index 0 with header matcher

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(txn\\.path_match\\) str\\(BACKEND:gtw_default_multi-rule_public-service_80\\) if \\{ var\\(req\\.gw_rule_id\\) -m str \"default_multi-rule_1\" \\}"
        description: Must set txn.path_match for rule index 1 based on req.gw_rule_id

  test-httproute-path-exact:
    description: HTTPRoute with Exact path type (no prefix matching)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: exact-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: exact-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: exact-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: exact-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: Exact
                      value: /api/users
                backendRefs:
                  - name: exact-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-exact.map
        pattern: "api.example.com/api/users GW_ROUTE_ID:http:default_exact-route_0"
        description: Exact path must be in path-exact.map

      - type: not_contains
        target: map:path-prefix.map
        pattern: "api.example.com/api/users"
        description: Exact path must not be in path-prefix.map

  test-httproute-path-regex:
    description: HTTPRoute with RegularExpression path type
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: versioned-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: versioned-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: versioned-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: RegularExpression
                      value: "^/api/v[0-9]+/users$"
                backendRefs:
                  - name: versioned-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-regex.map
        pattern: "api\\.example\\.com\\^/api/v\\[0-9\\]\\+/users\\$ gtw_default_regex-route_versioned-service_80"
        description: Regex path must be in path-regex.map

      - type: not_contains
        target: map:path-prefix.map
        pattern: "api.example.com/.*users"
        description: Regex path must not be in path-prefix.map

  test-grpcroute-headers:
    description: GRPCRoute with header matching (Exact and RegularExpression)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-api
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-api-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-api
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-header-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: GetUser
                    headers:
                      - type: Exact
                        name: X-API-Version
                        value: v1
                      - type: RegularExpression
                        name: User-Agent
                        value: "^grpc-.*"
                backendRefs:
                  - name: grpc-api
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\}.*\\{ req\\.hdr\\(X-API-Version\\) \"v1\" \\} \\{ req\\.hdr\\(User-Agent\\) -m reg \"\\^grpc-\\.\\*\" \\}"
        description: Must generate header match conditions for GRPCRoute

  test-grpcroute-method-regex:
    description: GRPCRoute with RegularExpression method type
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-multi
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-multi-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-multi
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-regex-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: RegularExpression
                      service: com.example.*
                      method: Get.*
                backendRefs:
                  - name: grpc-multi
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-regex-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_grpc-regex-route_0\" \\} \\{ req\\.hdr\\(:path\\) -m reg \"/com\\.example\\.\\*/Get\\.\\*\" \\}"
        description: Must generate regex method match for GRPCRoute

  test-httproute-all-matchers:
    description: HTTPRoute with all matcher types combined (method + headers + query params)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: combined-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: combined-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: combined-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: combined-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                    headers:
                      - type: Exact
                        name: Content-Type
                        value: application/json
                    queryParams:
                      - type: Exact
                        name: version
                        value: v2
                backendRefs:
                  - name: combined-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_combined-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_combined-route_0\" \\} \\{ method POST \\} \\{ req\\.hdr\\(Content-Type\\) \"application/json\" \\} \\{ urlp\\(version\\) \"v2\" \\}"
        description: Must combine all matchers with AND logic

  test-httproute-cross-route-conflicts:
    description: Multiple separate HTTPRoutes with conflicting paths (different matchers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: route1-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: route2-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: route1-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: route1-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: route2-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: route2-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route-get
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                backendRefs:
                  - name: route1-service
                    port: 80
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route-post
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                backendRefs:
                  - name: route2-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http:default_route-get_0__default_route-post_0"
        description: Cross-route conflicts must be detected and marked with GW_ROUTE_ID qualifier

  test-grpcroute-multiple-headers:
    description: GRPCRoute with multiple header matchers of different types
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-multi-header
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-multi-header-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-multi-header
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-multi-header-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: Create
                    headers:
                      - type: Exact
                        name: X-Tenant-ID
                        value: tenant1
                      - type: Exact
                        name: X-Environment
                        value: production
                      - type: RegularExpression
                        name: Authorization
                        value: "^Bearer .*"
                backendRefs:
                  - name: grpc-multi-header
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "\\{ req\\.hdr\\(X-Tenant-ID\\) \"tenant1\" \\} \\{ req\\.hdr\\(X-Environment\\) \"production\" \\} \\{ req\\.hdr\\(Authorization\\) -m reg \"\\^Bearer \\.\\*\" \\}"
        description: Must combine all header matchers with AND logic

  test-httproute-invalid-regex:
    description: HTTPRoute with invalid regex pattern (negative test)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: test-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: test-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: test-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: invalid-route
            namespace: default
          spec:
            hostnames:
              - invalid.example.com
            rules:
              - matches:
                  - headers:
                      - type: RegularExpression
                        name: X-Token
                        value: "[invalid"  # Unclosed bracket - invalid regex
                backendRefs:
                  - name: test-service
                    port: 80
    assertions:
      - type: not_contains
        target: haproxy.cfg
        pattern: "invalid\\.example\\.com"
        description: Invalid regex should not generate routing config

  test-httproute-header-edge-cases:
    description: HTTPRoute with edge case header matching (special characters)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: edge-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: edge-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: edge-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: edge-route
            namespace: default
          spec:
            hostnames:
              - edge.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: X-Special-Chars
                        value: "value-with-dashes_and_underscores.dots"
                backendRefs:
                  - name: edge-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "\\{ req\\.hdr\\(X-Special-Chars\\) \"value-with-dashes_and_underscores\\.dots\" \\}"
        description: Must handle special characters in header values

  test-httproute-grpcroute-precedence:
    description: Mixed HTTPRoute and GRPCRoute on same hostname (precedence validation)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: http-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-service
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: http-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: http-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 9090
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: http-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /rest
                backendRefs:
                  - name: http-service
                    port: 80
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.Service
                      method: GetData
                backendRefs:
                  - name: grpc-service
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:host.map
        pattern: "api\\.example\\.com api\\.example\\.com"
        description: Shared hostname must be in host map

      - type: contains
        target: map:path-prefix.map
        pattern: "api\\.example\\.com/rest GW_ROUTE_ID:http:default_http-route_0"
        description: HTTPRoute path must route to HTTP service

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_routeId\\) -m str \"default_grpc-route_0\" \\} \\{ req\\.hdr\\(:path\\) \"/com\\.example\\.Service/GetData\" \\}"
        description: GRPCRoute method must route to gRPC service

  test-httproute-request-header-modifier:
    description: HTTPRoute with RequestHeaderModifier filter (add, set, remove headers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: header-filter-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                filters:
                  - type: RequestHeaderModifier
                    requestHeaderModifier:
                      add:
                        - name: X-Custom-Header
                          value: custom-value
                      set:
                        - name: X-Replace-Header
                          value: new-value
                      remove:
                        - X-Remove-Header
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request add-header X-Custom-Header "custom-value" if'
        description: Must generate add-header directive for RequestHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request set-header X-Replace-Header "new-value" if'
        description: Must generate set-header directive for RequestHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request del-header X-Remove-Header if'
        description: Must generate del-header directive for RequestHeaderModifier filter

  test-httproute-response-header-modifier:
    description: HTTPRoute with ResponseHeaderModifier filter (add, set, remove response headers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: response-filter-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                filters:
                  - type: ResponseHeaderModifier
                    responseHeaderModifier:
                      add:
                        - name: X-Response-Header
                          value: response-value
                      set:
                        - name: X-Replace-Response
                          value: new-response
                      remove:
                        - X-Remove-Response
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response add-header X-Response-Header "response-value" if'
        description: Must generate add-header directive for ResponseHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response set-header X-Replace-Response "new-response" if'
        description: Must generate set-header directive for ResponseHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response del-header X-Remove-Response if'
        description: Must generate del-header directive for ResponseHeaderModifier filter

  test-httproute-request-redirect:
    description: HTTPRoute with RequestRedirect filter (scheme, path, status code)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: redirect-route
            namespace: default
          spec:
            hostnames:
              - old.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /old
                filters:
                  - type: RequestRedirect
                    requestRedirect:
                      scheme: https
                      hostname: new.example.com
                      path:
                        type: ReplacePrefixMatch
                        replacePrefixMatch: /new
                      statusCode: 301
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request redirect scheme https prefix "/new" code 301 if'
        description: Must generate redirect directive with scheme, prefix, and status code

  test-httproute-url-rewrite:
    description: HTTPRoute with URLRewrite filter (hostname and path rewrite)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: rewrite-route
            namespace: default
          spec:
            hostnames:
              - external.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1
                filters:
                  - type: URLRewrite
                    urlRewrite:
                      hostname: internal.example.com
                      path:
                        type: ReplacePrefixMatch
                        replacePrefixMatch: /api/v2
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request set-header Host "internal.example.com" if'
        description: Must generate hostname rewrite directive

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request replace-path'
        description: Must generate path prefix replacement directive

      - type: contains
        target: haproxy.cfg
        pattern: '"/api/v2'
        description: Must rewrite to new path prefix
