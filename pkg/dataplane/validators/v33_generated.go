// Code generated by gen-validators; DO NOT EDIT.

// Copyright 2025 Philipp Hossner
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package validators

import (
	"encoding/binary"

	"github.com/cespare/xxhash/v2"
	"github.com/haproxytech/client-native/v6/models"
)

// Version-specific validators for v33.
// These functions validate client-native models directly without JSON conversion.

// ValidateAclV33 validates a acl model.
func ValidateAclV33(m *models.ACL) error {
	if m == nil {
		return nil
	}

	if m.ACLName == "" {
		return &ValidationError{Field: "acl_name", Message: "required"}
	}

	if m.Criterion == "" {
		return &ValidationError{Field: "criterion", Message: "required"}
	}

	if m.ACLName != "" && !patternNoWhitespace.MatchString(m.ACLName) {
		return &ValidationError{Field: "acl_name", Message: "invalid format"}
	}

	if m.Criterion != "" && !patternNoWhitespace.MatchString(m.Criterion) {
		return &ValidationError{Field: "criterion", Message: "invalid format"}
	}

	return nil
}

// HashAclV33 computes a content hash for cache lookup.
func HashAclV33(m *models.ACL) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.ACLName)
	_, _ = h.WriteString(m.Criterion)
	_, _ = h.WriteString(m.Value)
	return h.Sum64()
}

// ValidateBackendSwitchingRuleV33 validates a backend_switching_rule model.
func ValidateBackendSwitchingRuleV33(m *models.BackendSwitchingRule) error {
	if m == nil {
		return nil
	}

	if m.Name == "" {
		return &ValidationError{Field: "name", Message: "required"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.Name != "" && !patternNoWhitespace.MatchString(m.Name) {
		return &ValidationError{Field: "name", Message: "invalid format"}
	}

	return nil
}

// HashBackendSwitchingRuleV33 computes a content hash for cache lookup.
func HashBackendSwitchingRuleV33(m *models.BackendSwitchingRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.Name)
	return h.Sum64()
}

// ValidateBindV33 validates a bind model.
func ValidateBindV33(m *models.Bind) error {
	if m == nil {
		return nil
	}

	if m.Name == "" {
		return &ValidationError{Field: "name", Message: "required"}
	}

	if m.Address != "" && !patternNoWhitespace.MatchString(m.Address) {
		return &ValidationError{Field: "address", Message: "invalid format"}
	}

	if m.Alpn != "" && !patternNoWhitespace.MatchString(m.Alpn) {
		return &ValidationError{Field: "alpn", Message: "invalid format"}
	}

	if m.ForceStrictSni != "" {
		switch m.ForceStrictSni {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_strict_sni", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.GUIDPrefix != "" && !patternGUID.MatchString(m.GUIDPrefix) {
		return &ValidationError{Field: "guid_prefix", Message: "invalid format"}
	}

	if m.Level != "" {
		switch m.Level {
		case "user", "operator", "admin":
			// valid
		default:
			return &ValidationError{Field: "level", Message: "must be one of: user, operator, admin"}
		}
	}

	if m.Name != "" && !patternNoWhitespace.MatchString(m.Name) {
		return &ValidationError{Field: "name", Message: "invalid format"}
	}

	if m.Port != nil {
		if *m.Port < 1 || *m.Port > 65535 {
			return &ValidationError{Field: "port", Message: "must be between 1 and 65535"}
		}
	}

	if m.PortRangeEnd != nil {
		if *m.PortRangeEnd < 1 || *m.PortRangeEnd > 65535 {
			return &ValidationError{Field: "port-range-end", Message: "must be between 1 and 65535"}
		}
	}

	if m.QuicCcAlgo != "" {
		switch m.QuicCcAlgo {
		case "cubic", "newreno", "bbr", "nocc":
			// valid
		default:
			return &ValidationError{Field: "quic-cc-algo", Message: "must be one of: cubic, newreno, bbr, nocc"}
		}
	}

	if m.QuicSocket != "" {
		switch m.QuicSocket {
		case "connection", "listener":
			// valid
		default:
			return &ValidationError{Field: "quic-socket", Message: "must be one of: connection, listener"}
		}
	}

	if m.QuicCcAlgoBurstSize != nil {
		if *m.QuicCcAlgoBurstSize > 1024 {
			return &ValidationError{Field: "quic_cc_algo_burst_size", Message: "must be <= 1024"}
		}
	}

	if m.QuicCcAlgoMaxWindow != nil {
		if *m.QuicCcAlgoMaxWindow < 10 || *m.QuicCcAlgoMaxWindow > 4194304 {
			return &ValidationError{Field: "quic_cc_algo_max_window", Message: "must be between 10 and 4194304"}
		}
	}

	if m.SeverityOutput != "" {
		switch m.SeverityOutput {
		case "none", "number", "string":
			// valid
		default:
			return &ValidationError{Field: "severity_output", Message: "must be one of: none, number, string"}
		}
	}

	if m.SslCafile != "" && !patternNoWhitespace.MatchString(m.SslCafile) {
		return &ValidationError{Field: "ssl_cafile", Message: "invalid format"}
	}

	if m.SslCertificate != "" && !patternNoWhitespace.MatchString(m.SslCertificate) {
		return &ValidationError{Field: "ssl_certificate", Message: "invalid format"}
	}

	if m.SslMaxVer != "" {
		switch m.SslMaxVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_max_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.SslMinVer != "" {
		switch m.SslMinVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_min_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.Sslv3 != "" {
		switch m.Sslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.TLSTickets != "" {
		switch m.TLSTickets {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tls_tickets", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv10 != "" {
		switch m.Tlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv11 != "" {
		switch m.Tlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv12 != "" {
		switch m.Tlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv13 != "" {
		switch m.Tlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Verify != "" {
		switch m.Verify {
		case "none", "optional", "required":
			// valid
		default:
			return &ValidationError{Field: "verify", Message: "must be one of: none, optional, required"}
		}
	}

	return nil
}

// HashBindV33 computes a content hash for cache lookup.
func HashBindV33(m *models.Bind) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_ = binary.Write(h, binary.LittleEndian, m.AcceptNetscalerCip)
	if m.AcceptProxy {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Address)
	if m.Allow0rtt {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Alpn)
	_, _ = h.WriteString(m.Backlog)
	_, _ = h.WriteString(m.CaIgnoreErr)
	_, _ = h.WriteString(m.CaSignFile)
	_, _ = h.WriteString(m.CaSignPass)
	_, _ = h.WriteString(m.CaVerifyFile)
	_, _ = h.WriteString(m.Ciphers)
	_, _ = h.WriteString(m.Ciphersuites)
	_, _ = h.WriteString(m.ClientSigalgs)
	_, _ = h.WriteString(m.CrlFile)
	_, _ = h.WriteString(m.CrtIgnoreErr)
	_, _ = h.WriteString(m.CrtList)
	_, _ = h.WriteString(m.Curves)
	if m.DeferAccept {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Ecdhe)
	if m.ExposeFdListeners {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.ForceSslv3 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.ForceStrictSni)
	if m.ForceTlsv10 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.ForceTlsv11 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.ForceTlsv12 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.ForceTlsv13 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.GenerateCertificates {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_ = binary.Write(h, binary.LittleEndian, m.Gid)
	_, _ = h.WriteString(m.Group)
	_, _ = h.WriteString(m.GUIDPrefix)
	_, _ = h.WriteString(m.ID)
	if m.IdlePing != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.IdlePing)
	}
	_, _ = h.WriteString(m.Interface)
	_, _ = h.WriteString(m.Level)
	_ = binary.Write(h, binary.LittleEndian, m.Maxconn)
	_, _ = h.WriteString(m.Mode)
	_, _ = h.WriteString(m.Mss)
	_, _ = h.WriteString(m.Name)
	_, _ = h.WriteString(m.Namespace)
	_ = binary.Write(h, binary.LittleEndian, m.Nbconn)
	_ = binary.Write(h, binary.LittleEndian, m.Nice)
	if m.NoAlpn {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoCaNames {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoSslv3 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoStrictSni {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoTLSTickets {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoTlsv10 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoTlsv11 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoTlsv12 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NoTlsv13 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Npn)
	if m.Port != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Port)
	}
	if m.PortRangeEnd != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PortRangeEnd)
	}
	if m.PreferClientCiphers {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Proto)
	_, _ = h.WriteString(m.QuicCcAlgo)
	if m.QuicForceRetry {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.QuicSocket)
	if m.QuicCcAlgoBurstSize != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.QuicCcAlgoBurstSize)
	}
	if m.QuicCcAlgoMaxWindow != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.QuicCcAlgoMaxWindow)
	}
	_, _ = h.WriteString(m.SeverityOutput)
	_, _ = h.WriteString(m.Sigalgs)
	if m.Ssl {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.SslCafile)
	_, _ = h.WriteString(m.SslCertificate)
	_, _ = h.WriteString(m.SslMaxVer)
	_, _ = h.WriteString(m.SslMinVer)
	_, _ = h.WriteString(m.Sslv3)
	if m.StrictSni {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.TCPUserTimeout != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TCPUserTimeout)
	}
	if m.Tfo {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Thread)
	_, _ = h.WriteString(m.TLSTicketKeys)
	_, _ = h.WriteString(m.TLSTickets)
	_, _ = h.WriteString(m.Tlsv10)
	_, _ = h.WriteString(m.Tlsv11)
	_, _ = h.WriteString(m.Tlsv12)
	_, _ = h.WriteString(m.Tlsv13)
	if m.Transparent {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.UID)
	_, _ = h.WriteString(m.User)
	if m.V4v6 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.V6only {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Verify)
	return h.Sum64()
}

// ValidateCaptureV33 validates a capture model.
func ValidateCaptureV33(m *models.Capture) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.Type != "" {
		switch m.Type {
		case "request", "response":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: request, response"}
		}
	}

	return nil
}

// HashCaptureV33 computes a content hash for cache lookup.
func HashCaptureV33(m *models.Capture) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_ = binary.Write(h, binary.LittleEndian, m.Length)
	_, _ = h.WriteString(m.Type)
	return h.Sum64()
}

// ValidateFilterV33 validates a filter model.
func ValidateFilterV33(m *models.Filter) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.AppName != "" && !patternNoWhitespace.MatchString(m.AppName) {
		return &ValidationError{Field: "app_name", Message: "invalid format"}
	}

	if m.BandwidthLimitName != "" && !patternNoWhitespace.MatchString(m.BandwidthLimitName) {
		return &ValidationError{Field: "bandwidth_limit_name", Message: "invalid format"}
	}

	if m.CacheName != "" && !patternNoWhitespace.MatchString(m.CacheName) {
		return &ValidationError{Field: "cache_name", Message: "invalid format"}
	}

	if m.SpoeConfig != "" && !patternNoWhitespace.MatchString(m.SpoeConfig) {
		return &ValidationError{Field: "spoe_config", Message: "invalid format"}
	}

	if m.SpoeEngine != "" && !patternNoWhitespace.MatchString(m.SpoeEngine) {
		return &ValidationError{Field: "spoe_engine", Message: "invalid format"}
	}

	if m.TraceName != "" && !patternNoWhitespace.MatchString(m.TraceName) {
		return &ValidationError{Field: "trace_name", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "bwlim-in", "bwlim-out", "cache", "compression", "fcgi-app", "spoe", "trace":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: bwlim-in, bwlim-out, cache, compression, fcgi-app, spoe, trace"}
		}
	}

	return nil
}

// HashFilterV33 computes a content hash for cache lookup.
func HashFilterV33(m *models.Filter) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.AppName)
	_, _ = h.WriteString(m.BandwidthLimitName)
	_, _ = h.WriteString(m.CacheName)
	_ = binary.Write(h, binary.LittleEndian, m.DefaultLimit)
	_ = binary.Write(h, binary.LittleEndian, m.DefaultPeriod)
	_, _ = h.WriteString(m.Key)
	_ = binary.Write(h, binary.LittleEndian, m.Limit)
	_ = binary.Write(h, binary.LittleEndian, m.MinSize)
	_, _ = h.WriteString(m.SpoeConfig)
	_, _ = h.WriteString(m.SpoeEngine)
	_, _ = h.WriteString(m.Table)
	if m.TraceHexdump {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.TraceName)
	if m.TraceRndForwarding {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.TraceRndParsing {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Type)
	return h.Sum64()
}

// ValidateHttpAfterResponseRuleV33 validates a http_after_response_rule model.
func ValidateHttpAfterResponseRuleV33(m *models.HTTPAfterResponseRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.ACLFile != "" && !patternNoWhitespace.MatchString(m.ACLFile) {
		return &ValidationError{Field: "acl_file", Message: "invalid format"}
	}

	if m.ACLKeyfmt != "" && !patternNoWhitespace.MatchString(m.ACLKeyfmt) {
		return &ValidationError{Field: "acl_keyfmt", Message: "invalid format"}
	}

	if m.CaptureSample != "" && !patternCaptureSample.MatchString(m.CaptureSample) {
		return &ValidationError{Field: "capture_sample", Message: "invalid format"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.LogLevel != "" {
		switch m.LogLevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "silent":
			// valid
		default:
			return &ValidationError{Field: "log_level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug, silent"}
		}
	}

	if m.MapFile != "" && !patternNoWhitespace.MatchString(m.MapFile) {
		return &ValidationError{Field: "map_file", Message: "invalid format"}
	}

	if m.MapKeyfmt != "" && !patternNoWhitespace.MatchString(m.MapKeyfmt) {
		return &ValidationError{Field: "map_keyfmt", Message: "invalid format"}
	}

	if m.MapValuefmt != "" && !patternNoWhitespace.MatchString(m.MapValuefmt) {
		return &ValidationError{Field: "map_valuefmt", Message: "invalid format"}
	}

	if m.Status != 0 && (m.Status < 100 || m.Status > 999) {
		return &ValidationError{Field: "status", Message: "must be between 100 and 999"}
	}

	if m.StrictMode != "" {
		switch m.StrictMode {
		case "on", "off":
			// valid
		default:
			return &ValidationError{Field: "strict_mode", Message: "must be one of: on, off"}
		}
	}

	if m.Type != "" {
		switch m.Type {
		case "add-header", "allow", "capture", "del-acl", "del-header", "del-map", "replace-header", "replace-value", "sc-add-gpc", "sc-inc-gpc", "sc-inc-gpc0", "sc-inc-gpc1", "sc-set-gpt", "sc-set-gpt0", "set-header", "set-log-level", "set-map", "set-status", "set-var", "set-var-fmt", "strict-mode", "unset-var", "do-log":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: add-header, allow, capture, del-acl, del-header, del-map, replace-header, replace-value, sc-add-gpc, sc-inc-gpc, sc-inc-gpc0, sc-inc-gpc1, sc-set-gpt, sc-set-gpt0, set-header, set-log-level, set-map, set-status, set-var, set-var-fmt, strict-mode, unset-var, do-log"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashHttpAfterResponseRuleV33 computes a content hash for cache lookup.
func HashHttpAfterResponseRuleV33(m *models.HTTPAfterResponseRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.ACLFile)
	_, _ = h.WriteString(m.ACLKeyfmt)
	if m.CaptureID != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.CaptureID)
	}
	_ = binary.Write(h, binary.LittleEndian, m.CaptureLen)
	_, _ = h.WriteString(m.CaptureSample)
	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.HdrFormat)
	_, _ = h.WriteString(m.HdrMatch)
	_, _ = h.WriteString(m.HdrMethod)
	_, _ = h.WriteString(m.HdrName)
	_, _ = h.WriteString(m.LogLevel)
	_, _ = h.WriteString(m.MapFile)
	_, _ = h.WriteString(m.MapKeyfmt)
	_, _ = h.WriteString(m.MapValuefmt)
	_, _ = h.WriteString(m.ScExpr)
	_ = binary.Write(h, binary.LittleEndian, m.ScID)
	_ = binary.Write(h, binary.LittleEndian, m.ScIdx)
	if m.ScInt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ScInt)
	}
	_ = binary.Write(h, binary.LittleEndian, m.Status)
	_, _ = h.WriteString(m.StatusReason)
	_, _ = h.WriteString(m.StrictMode)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.VarExpr)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	return h.Sum64()
}

// ValidateHttpCheckV33 validates a http_check model.
func ValidateHttpCheckV33(m *models.HTTPCheck) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.Addr != "" && !patternNoWhitespace.MatchString(m.Addr) {
		return &ValidationError{Field: "addr", Message: "invalid format"}
	}

	if m.Alpn != "" && !patternNoWhitespace.MatchString(m.Alpn) {
		return &ValidationError{Field: "alpn", Message: "invalid format"}
	}

	if m.ErrorStatus != "" {
		switch m.ErrorStatus {
		case "L7OKC", "L7RSP", "L7STS", "L6RSP", "L4CON":
			// valid
		default:
			return &ValidationError{Field: "error_status", Message: "must be one of: L7OKC, L7RSP, L7STS, L6RSP, L4CON"}
		}
	}

	if m.Match != "" && !patternNoWhitespace.MatchString(m.Match) {
		return &ValidationError{Field: "match", Message: "invalid format"}
	}

	if m.Match != "" {
		switch m.Match {
		case "status", "rstatus", "hdr", "fhdr", "string", "rstring":
			// valid
		default:
			return &ValidationError{Field: "match", Message: "must be one of: status, rstatus, hdr, fhdr, string, rstring"}
		}
	}

	if m.Method != "" {
		switch m.Method {
		case "HEAD", "PUT", "POST", "GET", "TRACE", "PATCH", "DELETE", "CONNECT", "OPTIONS":
			// valid
		default:
			return &ValidationError{Field: "method", Message: "must be one of: HEAD, PUT, POST, GET, TRACE, PATCH, DELETE, CONNECT, OPTIONS"}
		}
	}

	if m.OkStatus != "" {
		switch m.OkStatus {
		case "L7OK", "L7OKC", "L6OK", "L4OK":
			// valid
		default:
			return &ValidationError{Field: "ok_status", Message: "must be one of: L7OK, L7OKC, L6OK, L4OK"}
		}
	}

	if m.Port != nil {
		if *m.Port < 1 || *m.Port > 65535 {
			return &ValidationError{Field: "port", Message: "must be between 1 and 65535"}
		}
	}

	if m.ToutStatus != "" {
		switch m.ToutStatus {
		case "L7TOUT", "L6TOUT", "L4TOUT":
			// valid
		default:
			return &ValidationError{Field: "tout_status", Message: "must be one of: L7TOUT, L6TOUT, L4TOUT"}
		}
	}

	if m.Type != "" {
		switch m.Type {
		case "comment", "connect", "disable-on-404", "expect", "send", "send-state", "set-var", "set-var-fmt", "unset-var":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: comment, connect, disable-on-404, expect, send, send-state, set-var, set-var-fmt, unset-var"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashHttpCheckV33 computes a content hash for cache lookup.
func HashHttpCheckV33(m *models.HTTPCheck) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Addr)
	_, _ = h.WriteString(m.Alpn)
	_, _ = h.WriteString(m.Body)
	_, _ = h.WriteString(m.BodyLogFormat)
	_, _ = h.WriteString(m.CheckComment)
	if m.Default {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.ErrorStatus)
	if m.ExclamationMark {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.Linger {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Match)
	_, _ = h.WriteString(m.Method)
	if m.MinRecv != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.MinRecv)
	}
	_, _ = h.WriteString(m.OkStatus)
	_, _ = h.WriteString(m.OnError)
	_, _ = h.WriteString(m.OnSuccess)
	_, _ = h.WriteString(m.Pattern)
	if m.Port != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Port)
	}
	_, _ = h.WriteString(m.PortString)
	_, _ = h.WriteString(m.Proto)
	if m.SendProxy {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Sni)
	if m.Ssl {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.StatusCode)
	_, _ = h.WriteString(m.ToutStatus)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.URI)
	_, _ = h.WriteString(m.URILogFormat)
	_, _ = h.WriteString(m.VarExpr)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	_, _ = h.WriteString(m.Version)
	if m.ViaSocks4 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	return h.Sum64()
}

// ValidateHttpErrorRuleV33 validates a http_error_rule model.
func ValidateHttpErrorRuleV33(m *models.HTTPErrorRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.ReturnContentFormat != "" {
		switch m.ReturnContentFormat {
		case "default-errorfiles", "errorfile", "errorfiles", "file", "lf-file", "string", "lf-string":
			// valid
		default:
			return &ValidationError{Field: "return_content_format", Message: "must be one of: default-errorfiles, errorfile, errorfiles, file, lf-file, string, lf-string"}
		}
	}

	if m.Type != "" {
		switch m.Type {
		case "status":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: status"}
		}
	}

	return nil
}

// HashHttpErrorRuleV33 computes a content hash for cache lookup.
func HashHttpErrorRuleV33(m *models.HTTPErrorRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.ReturnContent)
	_, _ = h.WriteString(m.ReturnContentFormat)
	if m.ReturnContentType != nil {
		_, _ = h.WriteString(*m.ReturnContentType)
	}
	_ = binary.Write(h, binary.LittleEndian, m.Status)
	_, _ = h.WriteString(m.Type)
	return h.Sum64()
}

// ValidateHttpRequestRuleV33 validates a http_request_rule model.
func ValidateHttpRequestRuleV33(m *models.HTTPRequestRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.ACLFile != "" && !patternNoWhitespace.MatchString(m.ACLFile) {
		return &ValidationError{Field: "acl_file", Message: "invalid format"}
	}

	if m.ACLKeyfmt != "" && !patternNoWhitespace.MatchString(m.ACLKeyfmt) {
		return &ValidationError{Field: "acl_keyfmt", Message: "invalid format"}
	}

	if m.AuthRealm != "" && !patternNoWhitespace.MatchString(m.AuthRealm) {
		return &ValidationError{Field: "auth_realm", Message: "invalid format"}
	}

	if m.CacheName != "" && !patternNoWhitespace.MatchString(m.CacheName) {
		return &ValidationError{Field: "cache_name", Message: "invalid format"}
	}

	if m.CaptureSample != "" && !patternCaptureSample.MatchString(m.CaptureSample) {
		return &ValidationError{Field: "capture_sample", Message: "invalid format"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.DenyStatus != nil {
		if *m.DenyStatus < 200 || *m.DenyStatus > 599 {
			return &ValidationError{Field: "deny_status", Message: "must be between 200 and 599"}
		}
	}

	if m.HintFormat != "" && !patternNoWhitespace.MatchString(m.HintFormat) {
		return &ValidationError{Field: "hint_format", Message: "invalid format"}
	}

	if m.HintName != "" && !patternNoWhitespace.MatchString(m.HintName) {
		return &ValidationError{Field: "hint_name", Message: "invalid format"}
	}

	if m.LogLevel != "" {
		switch m.LogLevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "silent":
			// valid
		default:
			return &ValidationError{Field: "log_level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug, silent"}
		}
	}

	if m.LuaAction != "" && !patternNoWhitespace.MatchString(m.LuaAction) {
		return &ValidationError{Field: "lua_action", Message: "invalid format"}
	}

	if m.MapFile != "" && !patternNoWhitespace.MatchString(m.MapFile) {
		return &ValidationError{Field: "map_file", Message: "invalid format"}
	}

	if m.MapKeyfmt != "" && !patternNoWhitespace.MatchString(m.MapKeyfmt) {
		return &ValidationError{Field: "map_keyfmt", Message: "invalid format"}
	}

	if m.MapValuefmt != "" && !patternNoWhitespace.MatchString(m.MapValuefmt) {
		return &ValidationError{Field: "map_valuefmt", Message: "invalid format"}
	}

	if m.MarkValue != "" && !pattern_48e2.MatchString(m.MarkValue) {
		return &ValidationError{Field: "mark_value", Message: "invalid format"}
	}

	if m.MethodFmt != "" && !patternNoWhitespace.MatchString(m.MethodFmt) {
		return &ValidationError{Field: "method_fmt", Message: "invalid format"}
	}

	if m.NiceValue != 0 && (m.NiceValue < -1024 || m.NiceValue > 1024) {
		return &ValidationError{Field: "nice_value", Message: "must be between -1024 and 1024"}
	}

	if m.Normalizer != "" {
		switch m.Normalizer {
		case "fragment-encode", "fragment-strip", "path-merge-slashes", "path-strip-dot", "path-strip-dotdot", "percent-decode-unreserved", "percent-to-uppercase", "query-sort-by-name":
			// valid
		default:
			return &ValidationError{Field: "normalizer", Message: "must be one of: fragment-encode, fragment-strip, path-merge-slashes, path-strip-dot, path-strip-dotdot, percent-decode-unreserved, percent-to-uppercase, query-sort-by-name"}
		}
	}

	if m.PathFmt != "" && !patternNoWhitespace.MatchString(m.PathFmt) {
		return &ValidationError{Field: "path_fmt", Message: "invalid format"}
	}

	if m.PathMatch != "" && !patternNoWhitespace.MatchString(m.PathMatch) {
		return &ValidationError{Field: "path_match", Message: "invalid format"}
	}

	if m.Protocol != "" {
		switch m.Protocol {
		case "ipv4", "ipv6":
			// valid
		default:
			return &ValidationError{Field: "protocol", Message: "must be one of: ipv4, ipv6"}
		}
	}

	if m.RedirType != "" {
		switch m.RedirType {
		case "location", "prefix", "scheme":
			// valid
		default:
			return &ValidationError{Field: "redir_type", Message: "must be one of: location, prefix, scheme"}
		}
	}

	if m.RedirValue != "" && !patternNoWhitespace.MatchString(m.RedirValue) {
		return &ValidationError{Field: "redir_value", Message: "invalid format"}
	}

	if m.ReturnContentFormat != "" {
		switch m.ReturnContentFormat {
		case "default-errorfiles", "errorfile", "errorfiles", "file", "lf-file", "string", "lf-string":
			// valid
		default:
			return &ValidationError{Field: "return_content_format", Message: "must be one of: default-errorfiles, errorfile, errorfiles, file, lf-file, string, lf-string"}
		}
	}

	if m.ReturnStatusCode != nil {
		if *m.ReturnStatusCode < 200 || *m.ReturnStatusCode > 599 {
			return &ValidationError{Field: "return_status_code", Message: "must be between 200 and 599"}
		}
	}

	if m.SpoeEngine != "" && !patternNoWhitespace.MatchString(m.SpoeEngine) {
		return &ValidationError{Field: "spoe_engine", Message: "invalid format"}
	}

	if m.SpoeGroup != "" && !patternNoWhitespace.MatchString(m.SpoeGroup) {
		return &ValidationError{Field: "spoe_group", Message: "invalid format"}
	}

	if m.StrictMode != "" {
		switch m.StrictMode {
		case "on", "off":
			// valid
		default:
			return &ValidationError{Field: "strict_mode", Message: "must be one of: on, off"}
		}
	}

	if m.TimeoutType != "" {
		switch m.TimeoutType {
		case "server", "tunnel", "client":
			// valid
		default:
			return &ValidationError{Field: "timeout_type", Message: "must be one of: server, tunnel, client"}
		}
	}

	if m.TosValue != "" && !pattern_48e2.MatchString(m.TosValue) {
		return &ValidationError{Field: "tos_value", Message: "invalid format"}
	}

	if m.TrackScKey != "" && !patternNoWhitespace.MatchString(m.TrackScKey) {
		return &ValidationError{Field: "track_sc_key", Message: "invalid format"}
	}

	if m.TrackScTable != "" && !patternNoWhitespace.MatchString(m.TrackScTable) {
		return &ValidationError{Field: "track_sc_table", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "add-acl", "add-header", "allow", "auth", "cache-use", "capture", "del-acl", "del-header", "del-map", "deny", "disable-l7-retry", "do-resolve", "early-hint", "lua", "normalize-uri", "pause", "redirect", "reject", "replace-header", "replace-path", "replace-pathq", "replace-uri", "replace-value", "return", "sc-add-gpc", "sc-inc-gpc", "sc-inc-gpc0", "sc-inc-gpc1", "sc-set-gpt", "sc-set-gpt0", "send-spoe-group", "set-bc-mark", "set-bc-tos", "set-dst", "set-dst-port", "set-fc-mark", "set-fc-tos", "set-header", "set-log-level", "set-map", "set-mark", "set-method", "set-nice", "set-path", "set-pathq", "set-priority-class", "set-priority-offset", "set-query", "set-src", "set-src-port", "set-timeout", "set-tos", "set-uri", "set-var", "set-var-fmt", "silent-drop", "strict-mode", "tarpit", "track-sc", "unset-var", "use-service", "wait-for-body", "wait-for-handshake", "set-bandwidth-limit", "set-retries", "do-log":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: add-acl, add-header, allow, auth, cache-use, capture, del-acl, del-header, del-map, deny, disable-l7-retry, do-resolve, early-hint, lua, normalize-uri, pause, redirect, reject, replace-header, replace-path, replace-pathq, replace-uri, replace-value, return, sc-add-gpc, sc-inc-gpc, sc-inc-gpc0, sc-inc-gpc1, sc-set-gpt, sc-set-gpt0, send-spoe-group, set-bc-mark, set-bc-tos, set-dst, set-dst-port, set-fc-mark, set-fc-tos, set-header, set-log-level, set-map, set-mark, set-method, set-nice, set-path, set-pathq, set-priority-class, set-priority-offset, set-query, set-src, set-src-port, set-timeout, set-tos, set-uri, set-var, set-var-fmt, silent-drop, strict-mode, tarpit, track-sc, unset-var, use-service, wait-for-body, wait-for-handshake, set-bandwidth-limit, set-retries, do-log"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashHttpRequestRuleV33 computes a content hash for cache lookup.
func HashHttpRequestRuleV33(m *models.HTTPRequestRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.ACLFile)
	_, _ = h.WriteString(m.ACLKeyfmt)
	_, _ = h.WriteString(m.AuthRealm)
	_, _ = h.WriteString(m.BandwidthLimitLimit)
	_, _ = h.WriteString(m.BandwidthLimitName)
	_, _ = h.WriteString(m.BandwidthLimitPeriod)
	_, _ = h.WriteString(m.CacheName)
	if m.CaptureID != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.CaptureID)
	}
	_ = binary.Write(h, binary.LittleEndian, m.CaptureLen)
	_, _ = h.WriteString(m.CaptureSample)
	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	if m.DenyStatus != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.DenyStatus)
	}
	_, _ = h.WriteString(m.Expr)
	_, _ = h.WriteString(m.HdrFormat)
	_, _ = h.WriteString(m.HdrMatch)
	_, _ = h.WriteString(m.HdrMethod)
	_, _ = h.WriteString(m.HdrName)
	_, _ = h.WriteString(m.HintFormat)
	_, _ = h.WriteString(m.HintName)
	_, _ = h.WriteString(m.LogLevel)
	_, _ = h.WriteString(m.LuaAction)
	_, _ = h.WriteString(m.LuaParams)
	_, _ = h.WriteString(m.MapFile)
	_, _ = h.WriteString(m.MapKeyfmt)
	_, _ = h.WriteString(m.MapValuefmt)
	_, _ = h.WriteString(m.MarkValue)
	_, _ = h.WriteString(m.MethodFmt)
	_ = binary.Write(h, binary.LittleEndian, m.NiceValue)
	_, _ = h.WriteString(m.Normalizer)
	if m.NormalizerFull {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.NormalizerStrict {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.PathFmt)
	_, _ = h.WriteString(m.PathMatch)
	_, _ = h.WriteString(m.Protocol)
	_, _ = h.WriteString(m.QueryFmt)
	if m.RedirCode != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.RedirCode)
	}
	_, _ = h.WriteString(m.RedirOption)
	_, _ = h.WriteString(m.RedirType)
	_, _ = h.WriteString(m.RedirValue)
	_, _ = h.WriteString(m.Resolvers)
	_, _ = h.WriteString(m.ReturnContent)
	_, _ = h.WriteString(m.ReturnContentFormat)
	if m.ReturnContentType != nil {
		_, _ = h.WriteString(*m.ReturnContentType)
	}
	if m.ReturnStatusCode != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ReturnStatusCode)
	}
	_ = binary.Write(h, binary.LittleEndian, m.RstTTL)
	_, _ = h.WriteString(m.ScExpr)
	_ = binary.Write(h, binary.LittleEndian, m.ScID)
	_ = binary.Write(h, binary.LittleEndian, m.ScIdx)
	if m.ScInt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ScInt)
	}
	_, _ = h.WriteString(m.ServiceName)
	_, _ = h.WriteString(m.SpoeEngine)
	_, _ = h.WriteString(m.SpoeGroup)
	_, _ = h.WriteString(m.StrictMode)
	_, _ = h.WriteString(m.Timeout)
	_, _ = h.WriteString(m.TimeoutType)
	_, _ = h.WriteString(m.TosValue)
	_, _ = h.WriteString(m.TrackScKey)
	if m.TrackScStickCounter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TrackScStickCounter)
	}
	_, _ = h.WriteString(m.TrackScTable)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.URIFmt)
	_, _ = h.WriteString(m.URIMatch)
	_, _ = h.WriteString(m.VarExpr)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	if m.WaitAtLeast != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.WaitAtLeast)
	}
	if m.WaitTime != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.WaitTime)
	}
	return h.Sum64()
}

// ValidateHttpResponseRuleV33 validates a http_response_rule model.
func ValidateHttpResponseRuleV33(m *models.HTTPResponseRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.ACLFile != "" && !patternNoWhitespace.MatchString(m.ACLFile) {
		return &ValidationError{Field: "acl_file", Message: "invalid format"}
	}

	if m.ACLKeyfmt != "" && !patternNoWhitespace.MatchString(m.ACLKeyfmt) {
		return &ValidationError{Field: "acl_keyfmt", Message: "invalid format"}
	}

	if m.CacheName != "" && !patternNoWhitespace.MatchString(m.CacheName) {
		return &ValidationError{Field: "cache_name", Message: "invalid format"}
	}

	if m.CaptureSample != "" && !patternNoWhitespace.MatchString(m.CaptureSample) {
		return &ValidationError{Field: "capture_sample", Message: "invalid format"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.DenyStatus != nil {
		if *m.DenyStatus < 200 || *m.DenyStatus > 599 {
			return &ValidationError{Field: "deny_status", Message: "must be between 200 and 599"}
		}
	}

	if m.LogLevel != "" {
		switch m.LogLevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "silent":
			// valid
		default:
			return &ValidationError{Field: "log_level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug, silent"}
		}
	}

	if m.LuaAction != "" && !patternNoWhitespace.MatchString(m.LuaAction) {
		return &ValidationError{Field: "lua_action", Message: "invalid format"}
	}

	if m.MapFile != "" && !patternNoWhitespace.MatchString(m.MapFile) {
		return &ValidationError{Field: "map_file", Message: "invalid format"}
	}

	if m.MapKeyfmt != "" && !patternNoWhitespace.MatchString(m.MapKeyfmt) {
		return &ValidationError{Field: "map_keyfmt", Message: "invalid format"}
	}

	if m.MapValuefmt != "" && !patternNoWhitespace.MatchString(m.MapValuefmt) {
		return &ValidationError{Field: "map_valuefmt", Message: "invalid format"}
	}

	if m.MarkValue != "" && !pattern_48e2.MatchString(m.MarkValue) {
		return &ValidationError{Field: "mark_value", Message: "invalid format"}
	}

	if m.NiceValue != 0 && (m.NiceValue < -1024 || m.NiceValue > 1024) {
		return &ValidationError{Field: "nice_value", Message: "must be between -1024 and 1024"}
	}

	if m.RedirType != "" {
		switch m.RedirType {
		case "location", "prefix", "scheme":
			// valid
		default:
			return &ValidationError{Field: "redir_type", Message: "must be one of: location, prefix, scheme"}
		}
	}

	if m.RedirValue != "" && !patternNoWhitespace.MatchString(m.RedirValue) {
		return &ValidationError{Field: "redir_value", Message: "invalid format"}
	}

	if m.ReturnContentFormat != "" {
		switch m.ReturnContentFormat {
		case "default-errorfiles", "errorfile", "errorfiles", "file", "lf-file", "string", "lf-string":
			// valid
		default:
			return &ValidationError{Field: "return_content_format", Message: "must be one of: default-errorfiles, errorfile, errorfiles, file, lf-file, string, lf-string"}
		}
	}

	if m.ReturnStatusCode != nil {
		if *m.ReturnStatusCode < 200 || *m.ReturnStatusCode > 599 {
			return &ValidationError{Field: "return_status_code", Message: "must be between 200 and 599"}
		}
	}

	if m.SpoeEngine != "" && !patternNoWhitespace.MatchString(m.SpoeEngine) {
		return &ValidationError{Field: "spoe_engine", Message: "invalid format"}
	}

	if m.SpoeGroup != "" && !patternNoWhitespace.MatchString(m.SpoeGroup) {
		return &ValidationError{Field: "spoe_group", Message: "invalid format"}
	}

	if m.Status != 0 && (m.Status < 100 || m.Status > 999) {
		return &ValidationError{Field: "status", Message: "must be between 100 and 999"}
	}

	if m.StrictMode != "" {
		switch m.StrictMode {
		case "on", "off":
			// valid
		default:
			return &ValidationError{Field: "strict_mode", Message: "must be one of: on, off"}
		}
	}

	if m.TimeoutType != "" {
		switch m.TimeoutType {
		case "server", "tunnel", "client":
			// valid
		default:
			return &ValidationError{Field: "timeout_type", Message: "must be one of: server, tunnel, client"}
		}
	}

	if m.TosValue != "" && !pattern_48e2.MatchString(m.TosValue) {
		return &ValidationError{Field: "tos_value", Message: "invalid format"}
	}

	if m.TrackScKey != "" && !patternNoWhitespace.MatchString(m.TrackScKey) {
		return &ValidationError{Field: "track_sc_key", Message: "invalid format"}
	}

	if m.TrackScTable != "" && !patternNoWhitespace.MatchString(m.TrackScTable) {
		return &ValidationError{Field: "track_sc_table", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "add-acl", "add-header", "allow", "cache-store", "capture", "del-acl", "del-header", "del-map", "deny", "lua", "pause", "redirect", "replace-header", "replace-value", "return", "sc-add-gpc", "sc-inc-gpc", "sc-inc-gpc0", "sc-inc-gpc1", "sc-set-gpt", "sc-set-gpt0", "send-spoe-group", "set-fc-mark", "set-fc-tos", "set-header", "set-log-level", "set-map", "set-mark", "set-nice", "set-status", "set-timeout", "set-tos", "set-var", "set-var-fmt", "silent-drop", "strict-mode", "track-sc", "unset-var", "wait-for-body", "set-bandwidth-limit", "do-log":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: add-acl, add-header, allow, cache-store, capture, del-acl, del-header, del-map, deny, lua, pause, redirect, replace-header, replace-value, return, sc-add-gpc, sc-inc-gpc, sc-inc-gpc0, sc-inc-gpc1, sc-set-gpt, sc-set-gpt0, send-spoe-group, set-fc-mark, set-fc-tos, set-header, set-log-level, set-map, set-mark, set-nice, set-status, set-timeout, set-tos, set-var, set-var-fmt, silent-drop, strict-mode, track-sc, unset-var, wait-for-body, set-bandwidth-limit, do-log"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashHttpResponseRuleV33 computes a content hash for cache lookup.
func HashHttpResponseRuleV33(m *models.HTTPResponseRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.ACLFile)
	_, _ = h.WriteString(m.ACLKeyfmt)
	_, _ = h.WriteString(m.BandwidthLimitLimit)
	_, _ = h.WriteString(m.BandwidthLimitName)
	_, _ = h.WriteString(m.BandwidthLimitPeriod)
	_, _ = h.WriteString(m.CacheName)
	if m.CaptureID != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.CaptureID)
	}
	_, _ = h.WriteString(m.CaptureSample)
	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	if m.DenyStatus != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.DenyStatus)
	}
	_, _ = h.WriteString(m.Expr)
	_, _ = h.WriteString(m.HdrFormat)
	_, _ = h.WriteString(m.HdrMatch)
	_, _ = h.WriteString(m.HdrMethod)
	_, _ = h.WriteString(m.HdrName)
	_, _ = h.WriteString(m.LogLevel)
	_, _ = h.WriteString(m.LuaAction)
	_, _ = h.WriteString(m.LuaParams)
	_, _ = h.WriteString(m.MapFile)
	_, _ = h.WriteString(m.MapKeyfmt)
	_, _ = h.WriteString(m.MapValuefmt)
	_, _ = h.WriteString(m.MarkValue)
	_ = binary.Write(h, binary.LittleEndian, m.NiceValue)
	if m.RedirCode != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.RedirCode)
	}
	_, _ = h.WriteString(m.RedirOption)
	_, _ = h.WriteString(m.RedirType)
	_, _ = h.WriteString(m.RedirValue)
	_, _ = h.WriteString(m.ReturnContent)
	_, _ = h.WriteString(m.ReturnContentFormat)
	if m.ReturnContentType != nil {
		_, _ = h.WriteString(*m.ReturnContentType)
	}
	if m.ReturnStatusCode != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ReturnStatusCode)
	}
	_ = binary.Write(h, binary.LittleEndian, m.RstTTL)
	_, _ = h.WriteString(m.ScExpr)
	_ = binary.Write(h, binary.LittleEndian, m.ScID)
	_ = binary.Write(h, binary.LittleEndian, m.ScIdx)
	if m.ScInt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ScInt)
	}
	_, _ = h.WriteString(m.SpoeEngine)
	_, _ = h.WriteString(m.SpoeGroup)
	_ = binary.Write(h, binary.LittleEndian, m.Status)
	_, _ = h.WriteString(m.StatusReason)
	_, _ = h.WriteString(m.StrictMode)
	_, _ = h.WriteString(m.Timeout)
	_, _ = h.WriteString(m.TimeoutType)
	_, _ = h.WriteString(m.TosValue)
	_, _ = h.WriteString(m.TrackScKey)
	if m.TrackScStickCounter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TrackScStickCounter)
	}
	_, _ = h.WriteString(m.TrackScTable)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.VarExpr)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	if m.WaitAtLeast != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.WaitAtLeast)
	}
	if m.WaitTime != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.WaitTime)
	}
	return h.Sum64()
}

// ValidateLogTargetV33 validates a log_target model.
func ValidateLogTargetV33(m *models.LogTarget) error {
	if m == nil {
		return nil
	}

	if m.Address != "" && !patternNoWhitespace.MatchString(m.Address) {
		return &ValidationError{Field: "address", Message: "invalid format"}
	}

	if m.Facility != "" {
		switch m.Facility {
		case "kern", "user", "mail", "daemon", "auth", "syslog", "lpr", "news", "uucp", "cron", "auth2", "ftp", "ntp", "audit", "alert", "cron2", "local0", "local1", "local2", "local3", "local4", "local5", "local6", "local7":
			// valid
		default:
			return &ValidationError{Field: "facility", Message: "must be one of: kern, user, mail, daemon, auth, syslog, lpr, news, uucp, cron, auth2, ftp, ntp, audit, alert, cron2, local0, local1, local2, local3, local4, local5, local6, local7"}
		}
	}

	if m.Format != "" {
		switch m.Format {
		case "local", "rfc3164", "rfc5424", "priority", "short", "timed", "iso", "raw":
			// valid
		default:
			return &ValidationError{Field: "format", Message: "must be one of: local, rfc3164, rfc5424, priority, short, timed, iso, raw"}
		}
	}

	if m.Level != "" {
		switch m.Level {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug":
			// valid
		default:
			return &ValidationError{Field: "level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug"}
		}
	}

	if m.Minlevel != "" {
		switch m.Minlevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug":
			// valid
		default:
			return &ValidationError{Field: "minlevel", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug"}
		}
	}

	return nil
}

// HashLogTargetV33 computes a content hash for cache lookup.
func HashLogTargetV33(m *models.LogTarget) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Address)
	_, _ = h.WriteString(m.Facility)
	_, _ = h.WriteString(m.Format)
	if m.Global {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_ = binary.Write(h, binary.LittleEndian, m.Length)
	_, _ = h.WriteString(m.Level)
	_, _ = h.WriteString(m.Minlevel)
	if m.Nolog {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Profile)
	_, _ = h.WriteString(m.SampleRange)
	_ = binary.Write(h, binary.LittleEndian, m.SampleSize)
	return h.Sum64()
}

// ValidateServerV33 validates a server model.
func ValidateServerV33(m *models.Server) error {
	if m == nil {
		return nil
	}

	if m.Name == "" {
		return &ValidationError{Field: "name", Message: "required"}
	}

	if m.Address == "" {
		return &ValidationError{Field: "address", Message: "required"}
	}

	if m.Address != "" && !patternNoWhitespace.MatchString(m.Address) {
		return &ValidationError{Field: "address", Message: "invalid format"}
	}

	if m.AgentAddr != "" && !patternNoWhitespace.MatchString(m.AgentAddr) {
		return &ValidationError{Field: "agent-addr", Message: "invalid format"}
	}

	if m.AgentCheck != "" {
		switch m.AgentCheck {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "agent-check", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.AgentPort != nil {
		if *m.AgentPort < 1 || *m.AgentPort > 65535 {
			return &ValidationError{Field: "agent-port", Message: "must be between 1 and 65535"}
		}
	}

	if m.Alpn != "" && !patternNoWhitespace.MatchString(m.Alpn) {
		return &ValidationError{Field: "alpn", Message: "invalid format"}
	}

	if m.Backup != "" {
		switch m.Backup {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "backup", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Check != "" {
		switch m.Check {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckPoolConnName != "" && !patternNoWhitespace.MatchString(m.CheckPoolConnName) {
		return &ValidationError{Field: "check-pool-conn-name", Message: "invalid format"}
	}

	if m.CheckReusePool != "" {
		switch m.CheckReusePool {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-reuse-pool", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckSendProxy != "" {
		switch m.CheckSendProxy {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-send-proxy", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckSni != "" && !patternNoWhitespace.MatchString(m.CheckSni) {
		return &ValidationError{Field: "check-sni", Message: "invalid format"}
	}

	if m.CheckSsl != "" {
		switch m.CheckSsl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckAlpn != "" && !patternNoWhitespace.MatchString(m.CheckAlpn) {
		return &ValidationError{Field: "check_alpn", Message: "invalid format"}
	}

	if m.CheckProto != "" && !patternNoWhitespace.MatchString(m.CheckProto) {
		return &ValidationError{Field: "check_proto", Message: "invalid format"}
	}

	if m.CheckViaSocks4 != "" {
		switch m.CheckViaSocks4 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check_via_socks4", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Cookie != "" && !patternNoWhitespace.MatchString(m.Cookie) {
		return &ValidationError{Field: "cookie", Message: "invalid format"}
	}

	if m.ForceSslv3 != "" {
		switch m.ForceSslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv10 != "" {
		switch m.ForceTlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv11 != "" {
		switch m.ForceTlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv12 != "" {
		switch m.ForceTlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv13 != "" {
		switch m.ForceTlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.GUID != "" && !patternGUID.MatchString(m.GUID) {
		return &ValidationError{Field: "guid", Message: "invalid format"}
	}

	if m.HashKey != "" && !patternNoWhitespace.MatchString(m.HashKey) {
		return &ValidationError{Field: "hash_key", Message: "invalid format"}
	}

	if m.HealthCheckAddress != "" && !patternNoWhitespace.MatchString(m.HealthCheckAddress) {
		return &ValidationError{Field: "health_check_address", Message: "invalid format"}
	}

	if m.HealthCheckPort != nil {
		if *m.HealthCheckPort < 1 || *m.HealthCheckPort > 65535 {
			return &ValidationError{Field: "health_check_port", Message: "must be between 1 and 65535"}
		}
	}

	if m.InitAddr != nil && *m.InitAddr != "" && !patternNoWhitespace.MatchString(*m.InitAddr) {
		return &ValidationError{Field: "init-addr", Message: "invalid format"}
	}

	if m.InitState != "" {
		switch m.InitState {
		case "fully-up", "up", "down", "fully-down":
			// valid
		default:
			return &ValidationError{Field: "init-state", Message: "must be one of: fully-up, up, down, fully-down"}
		}
	}

	if m.LogProto != "" {
		switch m.LogProto {
		case "legacy", "octet-count":
			// valid
		default:
			return &ValidationError{Field: "log_proto", Message: "must be one of: legacy, octet-count"}
		}
	}

	if m.Maintenance != "" {
		switch m.Maintenance {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "maintenance", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Name != "" && !patternNoWhitespace.MatchString(m.Name) {
		return &ValidationError{Field: "name", Message: "invalid format"}
	}

	if m.NoSslv3 != "" {
		switch m.NoSslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv10 != "" {
		switch m.NoTlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv11 != "" {
		switch m.NoTlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv12 != "" {
		switch m.NoTlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv13 != "" {
		switch m.NoTlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoVerifyhost != "" {
		switch m.NoVerifyhost {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_verifyhost", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Observe != "" {
		switch m.Observe {
		case "layer4", "layer7":
			// valid
		default:
			return &ValidationError{Field: "observe", Message: "must be one of: layer4, layer7"}
		}
	}

	if m.OnError != "" {
		switch m.OnError {
		case "fastinter", "fail-check", "sudden-death", "mark-down":
			// valid
		default:
			return &ValidationError{Field: "on-error", Message: "must be one of: fastinter, fail-check, sudden-death, mark-down"}
		}
	}

	if m.OnMarkedDown != "" {
		switch m.OnMarkedDown {
		case "shutdown-sessions":
			// valid
		default:
			return &ValidationError{Field: "on-marked-down", Message: "must be one of: shutdown-sessions"}
		}
	}

	if m.OnMarkedUp != "" {
		switch m.OnMarkedUp {
		case "shutdown-backup-sessions":
			// valid
		default:
			return &ValidationError{Field: "on-marked-up", Message: "must be one of: shutdown-backup-sessions"}
		}
	}

	if m.PoolConnName != "" && !patternNoWhitespace.MatchString(m.PoolConnName) {
		return &ValidationError{Field: "pool_conn_name", Message: "invalid format"}
	}

	if m.Port != nil {
		if *m.Port < 1 || *m.Port > 65535 {
			return &ValidationError{Field: "port", Message: "must be between 1 and 65535"}
		}
	}

	if m.Proto != "" && !patternNoWhitespace.MatchString(m.Proto) {
		return &ValidationError{Field: "proto", Message: "invalid format"}
	}

	if m.ResolveNet != "" && !patternResolveNet.MatchString(m.ResolveNet) {
		return &ValidationError{Field: "resolve-net", Message: "invalid format"}
	}

	if m.ResolvePrefer != "" {
		switch m.ResolvePrefer {
		case "ipv4", "ipv6":
			// valid
		default:
			return &ValidationError{Field: "resolve-prefer", Message: "must be one of: ipv4, ipv6"}
		}
	}

	if m.ResolveOpts != "" && !patternResolveOpts.MatchString(m.ResolveOpts) {
		return &ValidationError{Field: "resolve_opts", Message: "invalid format"}
	}

	if m.Resolvers != "" && !patternNoWhitespace.MatchString(m.Resolvers) {
		return &ValidationError{Field: "resolvers", Message: "invalid format"}
	}

	if m.SendProxy != "" {
		switch m.SendProxy {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send-proxy", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2 != "" {
		switch m.SendProxyV2 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send-proxy-v2", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2Ssl != "" {
		switch m.SendProxyV2Ssl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send_proxy_v2_ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2SslCn != "" {
		switch m.SendProxyV2SslCn {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send_proxy_v2_ssl_cn", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Sni != "" && !patternNoWhitespace.MatchString(m.Sni) {
		return &ValidationError{Field: "sni", Message: "invalid format"}
	}

	if m.Socks4 != "" && !patternNoWhitespace.MatchString(m.Socks4) {
		return &ValidationError{Field: "socks4", Message: "invalid format"}
	}

	if m.Ssl != "" {
		switch m.Ssl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SslCafile != "" && !patternNoWhitespace.MatchString(m.SslCafile) {
		return &ValidationError{Field: "ssl_cafile", Message: "invalid format"}
	}

	if m.SslCertificate != "" && !patternNoWhitespace.MatchString(m.SslCertificate) {
		return &ValidationError{Field: "ssl_certificate", Message: "invalid format"}
	}

	if m.SslMaxVer != "" {
		switch m.SslMaxVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_max_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.SslMinVer != "" {
		switch m.SslMinVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_min_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.SslReuse != "" {
		switch m.SslReuse {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "ssl_reuse", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Sslv3 != "" {
		switch m.Sslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Stick != "" {
		switch m.Stick {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "stick", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tfo != "" {
		switch m.Tfo {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tfo", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.TLSTickets != "" {
		switch m.TLSTickets {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tls_tickets", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv10 != "" {
		switch m.Tlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv11 != "" {
		switch m.Tlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv12 != "" {
		switch m.Tlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv13 != "" {
		switch m.Tlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Verify != "" {
		switch m.Verify {
		case "none", "required":
			// valid
		default:
			return &ValidationError{Field: "verify", Message: "must be one of: none, required"}
		}
	}

	if m.Ws != "" {
		switch m.Ws {
		case "auto", "h1", "h2":
			// valid
		default:
			return &ValidationError{Field: "ws", Message: "must be one of: auto, h1, h2"}
		}
	}

	return nil
}

// HashServerV33 computes a content hash for cache lookup.
func HashServerV33(m *models.Server) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Address)
	_, _ = h.WriteString(m.AgentAddr)
	_, _ = h.WriteString(m.AgentCheck)
	if m.AgentInter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.AgentInter)
	}
	if m.AgentPort != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.AgentPort)
	}
	_, _ = h.WriteString(m.AgentSend)
	if m.Allow0rtt {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Alpn)
	_, _ = h.WriteString(m.Backup)
	_, _ = h.WriteString(m.Check)
	_, _ = h.WriteString(m.CheckPoolConnName)
	_, _ = h.WriteString(m.CheckReusePool)
	_, _ = h.WriteString(m.CheckSendProxy)
	_, _ = h.WriteString(m.CheckSni)
	_, _ = h.WriteString(m.CheckSsl)
	_, _ = h.WriteString(m.CheckAlpn)
	_, _ = h.WriteString(m.CheckProto)
	_, _ = h.WriteString(m.CheckViaSocks4)
	_, _ = h.WriteString(m.Ciphers)
	_, _ = h.WriteString(m.Ciphersuites)
	_, _ = h.WriteString(m.ClientSigalgs)
	_, _ = h.WriteString(m.Cookie)
	_, _ = h.WriteString(m.CrlFile)
	_, _ = h.WriteString(m.Curves)
	if m.Downinter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Downinter)
	}
	_ = binary.Write(h, binary.LittleEndian, m.ErrorLimit)
	if m.Fall != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Fall)
	}
	if m.Fastinter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Fastinter)
	}
	_, _ = h.WriteString(m.ForceSslv3)
	_, _ = h.WriteString(m.ForceTlsv10)
	_, _ = h.WriteString(m.ForceTlsv11)
	_, _ = h.WriteString(m.ForceTlsv12)
	_, _ = h.WriteString(m.ForceTlsv13)
	_, _ = h.WriteString(m.GUID)
	_, _ = h.WriteString(m.HashKey)
	_, _ = h.WriteString(m.HealthCheckAddress)
	if m.HealthCheckPort != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.HealthCheckPort)
	}
	if m.ID != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ID)
	}
	if m.IdlePing != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.IdlePing)
	}
	if m.InitAddr != nil {
		_, _ = h.WriteString(*m.InitAddr)
	}
	_, _ = h.WriteString(m.InitState)
	if m.Inter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Inter)
	}
	if m.LogBufsize != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.LogBufsize)
	}
	_, _ = h.WriteString(m.LogProto)
	_, _ = h.WriteString(m.Maintenance)
	if m.MaxReuse != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.MaxReuse)
	}
	if m.Maxconn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Maxconn)
	}
	if m.Maxqueue != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Maxqueue)
	}
	if m.Minconn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Minconn)
	}
	_, _ = h.WriteString(m.Name)
	_, _ = h.WriteString(m.Namespace)
	_, _ = h.WriteString(m.NoSslv3)
	_, _ = h.WriteString(m.NoTlsv10)
	_, _ = h.WriteString(m.NoTlsv11)
	_, _ = h.WriteString(m.NoTlsv12)
	_, _ = h.WriteString(m.NoTlsv13)
	_, _ = h.WriteString(m.NoVerifyhost)
	_, _ = h.WriteString(m.Npn)
	_, _ = h.WriteString(m.Observe)
	_, _ = h.WriteString(m.OnError)
	_, _ = h.WriteString(m.OnMarkedDown)
	_, _ = h.WriteString(m.OnMarkedUp)
	_, _ = h.WriteString(m.PoolConnName)
	if m.PoolLowConn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolLowConn)
	}
	if m.PoolMaxConn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolMaxConn)
	}
	if m.PoolPurgeDelay != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolPurgeDelay)
	}
	if m.Port != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Port)
	}
	_, _ = h.WriteString(m.Proto)
	_, _ = h.WriteString(m.Redir)
	_, _ = h.WriteString(m.ResolveNet)
	_, _ = h.WriteString(m.ResolvePrefer)
	_, _ = h.WriteString(m.ResolveOpts)
	_, _ = h.WriteString(m.Resolvers)
	if m.Rise != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Rise)
	}
	_, _ = h.WriteString(m.SendProxy)
	_, _ = h.WriteString(m.SendProxyV2)
	_, _ = h.WriteString(m.SendProxyV2Ssl)
	_, _ = h.WriteString(m.SendProxyV2SslCn)
	_ = binary.Write(h, binary.LittleEndian, m.Shard)
	_, _ = h.WriteString(m.Sigalgs)
	if m.Slowstart != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Slowstart)
	}
	_, _ = h.WriteString(m.Sni)
	_, _ = h.WriteString(m.Socks4)
	_, _ = h.WriteString(m.Source)
	_, _ = h.WriteString(m.Ssl)
	_, _ = h.WriteString(m.SslCafile)
	_, _ = h.WriteString(m.SslCertificate)
	_, _ = h.WriteString(m.SslMaxVer)
	_, _ = h.WriteString(m.SslMinVer)
	_, _ = h.WriteString(m.SslReuse)
	_, _ = h.WriteString(m.Sslv3)
	_, _ = h.WriteString(m.Stick)
	if m.StrictMaxconn {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.TCPUt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TCPUt)
	}
	_, _ = h.WriteString(m.Tfo)
	_, _ = h.WriteString(m.TLSTickets)
	_, _ = h.WriteString(m.Tlsv10)
	_, _ = h.WriteString(m.Tlsv11)
	_, _ = h.WriteString(m.Tlsv12)
	_, _ = h.WriteString(m.Tlsv13)
	_, _ = h.WriteString(m.Track)
	_, _ = h.WriteString(m.Verify)
	_, _ = h.WriteString(m.Verifyhost)
	if m.Weight != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Weight)
	}
	_, _ = h.WriteString(m.Ws)
	return h.Sum64()
}

// ValidateServerSwitchingRuleV33 validates a server_switching_rule model.
func ValidateServerSwitchingRuleV33(m *models.ServerSwitchingRule) error {
	if m == nil {
		return nil
	}

	if m.TargetServer == "" {
		return &ValidationError{Field: "target_server", Message: "required"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.TargetServer != "" && !patternNoWhitespace.MatchString(m.TargetServer) {
		return &ValidationError{Field: "target_server", Message: "invalid format"}
	}

	return nil
}

// HashServerSwitchingRuleV33 computes a content hash for cache lookup.
func HashServerSwitchingRuleV33(m *models.ServerSwitchingRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.TargetServer)
	return h.Sum64()
}

// ValidateServerTemplateV33 validates a server_template model.
func ValidateServerTemplateV33(m *models.ServerTemplate) error {
	if m == nil {
		return nil
	}

	if m.Prefix == "" {
		return &ValidationError{Field: "prefix", Message: "required"}
	}

	if m.NumOrRange == "" {
		return &ValidationError{Field: "num_or_range", Message: "required"}
	}

	if m.Fqdn == "" {
		return &ValidationError{Field: "fqdn", Message: "required"}
	}

	if m.AgentAddr != "" && !patternNoWhitespace.MatchString(m.AgentAddr) {
		return &ValidationError{Field: "agent-addr", Message: "invalid format"}
	}

	if m.AgentCheck != "" {
		switch m.AgentCheck {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "agent-check", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.AgentPort != nil {
		if *m.AgentPort < 1 || *m.AgentPort > 65535 {
			return &ValidationError{Field: "agent-port", Message: "must be between 1 and 65535"}
		}
	}

	if m.Alpn != "" && !patternNoWhitespace.MatchString(m.Alpn) {
		return &ValidationError{Field: "alpn", Message: "invalid format"}
	}

	if m.Backup != "" {
		switch m.Backup {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "backup", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Check != "" {
		switch m.Check {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckPoolConnName != "" && !patternNoWhitespace.MatchString(m.CheckPoolConnName) {
		return &ValidationError{Field: "check-pool-conn-name", Message: "invalid format"}
	}

	if m.CheckReusePool != "" {
		switch m.CheckReusePool {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-reuse-pool", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckSendProxy != "" {
		switch m.CheckSendProxy {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-send-proxy", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckSni != "" && !patternNoWhitespace.MatchString(m.CheckSni) {
		return &ValidationError{Field: "check-sni", Message: "invalid format"}
	}

	if m.CheckSsl != "" {
		switch m.CheckSsl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check-ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.CheckAlpn != "" && !patternNoWhitespace.MatchString(m.CheckAlpn) {
		return &ValidationError{Field: "check_alpn", Message: "invalid format"}
	}

	if m.CheckProto != "" && !patternNoWhitespace.MatchString(m.CheckProto) {
		return &ValidationError{Field: "check_proto", Message: "invalid format"}
	}

	if m.CheckViaSocks4 != "" {
		switch m.CheckViaSocks4 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "check_via_socks4", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Cookie != "" && !patternNoWhitespace.MatchString(m.Cookie) {
		return &ValidationError{Field: "cookie", Message: "invalid format"}
	}

	if m.ForceSslv3 != "" {
		switch m.ForceSslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv10 != "" {
		switch m.ForceTlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv11 != "" {
		switch m.ForceTlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv12 != "" {
		switch m.ForceTlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.ForceTlsv13 != "" {
		switch m.ForceTlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "force_tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.GUID != "" && !patternGUID.MatchString(m.GUID) {
		return &ValidationError{Field: "guid", Message: "invalid format"}
	}

	if m.HashKey != "" && !patternNoWhitespace.MatchString(m.HashKey) {
		return &ValidationError{Field: "hash_key", Message: "invalid format"}
	}

	if m.HealthCheckAddress != "" && !patternNoWhitespace.MatchString(m.HealthCheckAddress) {
		return &ValidationError{Field: "health_check_address", Message: "invalid format"}
	}

	if m.HealthCheckPort != nil {
		if *m.HealthCheckPort < 1 || *m.HealthCheckPort > 65535 {
			return &ValidationError{Field: "health_check_port", Message: "must be between 1 and 65535"}
		}
	}

	if m.InitAddr != nil && *m.InitAddr != "" && !patternNoWhitespace.MatchString(*m.InitAddr) {
		return &ValidationError{Field: "init-addr", Message: "invalid format"}
	}

	if m.InitState != "" {
		switch m.InitState {
		case "fully-up", "up", "down", "fully-down":
			// valid
		default:
			return &ValidationError{Field: "init-state", Message: "must be one of: fully-up, up, down, fully-down"}
		}
	}

	if m.LogProto != "" {
		switch m.LogProto {
		case "legacy", "octet-count":
			// valid
		default:
			return &ValidationError{Field: "log_proto", Message: "must be one of: legacy, octet-count"}
		}
	}

	if m.Maintenance != "" {
		switch m.Maintenance {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "maintenance", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoSslv3 != "" {
		switch m.NoSslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv10 != "" {
		switch m.NoTlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv11 != "" {
		switch m.NoTlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv12 != "" {
		switch m.NoTlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoTlsv13 != "" {
		switch m.NoTlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.NoVerifyhost != "" {
		switch m.NoVerifyhost {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "no_verifyhost", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Observe != "" {
		switch m.Observe {
		case "layer4", "layer7":
			// valid
		default:
			return &ValidationError{Field: "observe", Message: "must be one of: layer4, layer7"}
		}
	}

	if m.OnError != "" {
		switch m.OnError {
		case "fastinter", "fail-check", "sudden-death", "mark-down":
			// valid
		default:
			return &ValidationError{Field: "on-error", Message: "must be one of: fastinter, fail-check, sudden-death, mark-down"}
		}
	}

	if m.OnMarkedDown != "" {
		switch m.OnMarkedDown {
		case "shutdown-sessions":
			// valid
		default:
			return &ValidationError{Field: "on-marked-down", Message: "must be one of: shutdown-sessions"}
		}
	}

	if m.OnMarkedUp != "" {
		switch m.OnMarkedUp {
		case "shutdown-backup-sessions":
			// valid
		default:
			return &ValidationError{Field: "on-marked-up", Message: "must be one of: shutdown-backup-sessions"}
		}
	}

	if m.PoolConnName != "" && !patternNoWhitespace.MatchString(m.PoolConnName) {
		return &ValidationError{Field: "pool_conn_name", Message: "invalid format"}
	}

	if m.Port != nil {
		if *m.Port < 1 || *m.Port > 65535 {
			return &ValidationError{Field: "port", Message: "must be between 1 and 65535"}
		}
	}

	if m.Prefix != "" && !patternNoWhitespace.MatchString(m.Prefix) {
		return &ValidationError{Field: "prefix", Message: "invalid format"}
	}

	if m.Proto != "" && !patternNoWhitespace.MatchString(m.Proto) {
		return &ValidationError{Field: "proto", Message: "invalid format"}
	}

	if m.ResolveNet != "" && !patternResolveNet.MatchString(m.ResolveNet) {
		return &ValidationError{Field: "resolve-net", Message: "invalid format"}
	}

	if m.ResolvePrefer != "" {
		switch m.ResolvePrefer {
		case "ipv4", "ipv6":
			// valid
		default:
			return &ValidationError{Field: "resolve-prefer", Message: "must be one of: ipv4, ipv6"}
		}
	}

	if m.ResolveOpts != "" && !patternResolveOpts.MatchString(m.ResolveOpts) {
		return &ValidationError{Field: "resolve_opts", Message: "invalid format"}
	}

	if m.Resolvers != "" && !patternNoWhitespace.MatchString(m.Resolvers) {
		return &ValidationError{Field: "resolvers", Message: "invalid format"}
	}

	if m.SendProxy != "" {
		switch m.SendProxy {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send-proxy", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2 != "" {
		switch m.SendProxyV2 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send-proxy-v2", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2Ssl != "" {
		switch m.SendProxyV2Ssl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send_proxy_v2_ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SendProxyV2SslCn != "" {
		switch m.SendProxyV2SslCn {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "send_proxy_v2_ssl_cn", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Sni != "" && !patternNoWhitespace.MatchString(m.Sni) {
		return &ValidationError{Field: "sni", Message: "invalid format"}
	}

	if m.Socks4 != "" && !patternNoWhitespace.MatchString(m.Socks4) {
		return &ValidationError{Field: "socks4", Message: "invalid format"}
	}

	if m.Ssl != "" {
		switch m.Ssl {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "ssl", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.SslCafile != "" && !patternNoWhitespace.MatchString(m.SslCafile) {
		return &ValidationError{Field: "ssl_cafile", Message: "invalid format"}
	}

	if m.SslCertificate != "" && !patternNoWhitespace.MatchString(m.SslCertificate) {
		return &ValidationError{Field: "ssl_certificate", Message: "invalid format"}
	}

	if m.SslMaxVer != "" {
		switch m.SslMaxVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_max_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.SslMinVer != "" {
		switch m.SslMinVer {
		case "SSLv3", "TLSv1.0", "TLSv1.1", "TLSv1.2", "TLSv1.3":
			// valid
		default:
			return &ValidationError{Field: "ssl_min_ver", Message: "must be one of: SSLv3, TLSv1.0, TLSv1.1, TLSv1.2, TLSv1.3"}
		}
	}

	if m.SslReuse != "" {
		switch m.SslReuse {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "ssl_reuse", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Sslv3 != "" {
		switch m.Sslv3 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "sslv3", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Stick != "" {
		switch m.Stick {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "stick", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tfo != "" {
		switch m.Tfo {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tfo", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.TLSTickets != "" {
		switch m.TLSTickets {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tls_tickets", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv10 != "" {
		switch m.Tlsv10 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv10", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv11 != "" {
		switch m.Tlsv11 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv11", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv12 != "" {
		switch m.Tlsv12 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv12", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Tlsv13 != "" {
		switch m.Tlsv13 {
		case "enabled", "disabled":
			// valid
		default:
			return &ValidationError{Field: "tlsv13", Message: "must be one of: enabled, disabled"}
		}
	}

	if m.Verify != "" {
		switch m.Verify {
		case "none", "required":
			// valid
		default:
			return &ValidationError{Field: "verify", Message: "must be one of: none, required"}
		}
	}

	if m.Ws != "" {
		switch m.Ws {
		case "auto", "h1", "h2":
			// valid
		default:
			return &ValidationError{Field: "ws", Message: "must be one of: auto, h1, h2"}
		}
	}

	return nil
}

// HashServerTemplateV33 computes a content hash for cache lookup.
func HashServerTemplateV33(m *models.ServerTemplate) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.AgentAddr)
	_, _ = h.WriteString(m.AgentCheck)
	if m.AgentInter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.AgentInter)
	}
	if m.AgentPort != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.AgentPort)
	}
	_, _ = h.WriteString(m.AgentSend)
	if m.Allow0rtt {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Alpn)
	_, _ = h.WriteString(m.Backup)
	_, _ = h.WriteString(m.Check)
	_, _ = h.WriteString(m.CheckPoolConnName)
	_, _ = h.WriteString(m.CheckReusePool)
	_, _ = h.WriteString(m.CheckSendProxy)
	_, _ = h.WriteString(m.CheckSni)
	_, _ = h.WriteString(m.CheckSsl)
	_, _ = h.WriteString(m.CheckAlpn)
	_, _ = h.WriteString(m.CheckProto)
	_, _ = h.WriteString(m.CheckViaSocks4)
	_, _ = h.WriteString(m.Ciphers)
	_, _ = h.WriteString(m.Ciphersuites)
	_, _ = h.WriteString(m.ClientSigalgs)
	_, _ = h.WriteString(m.Cookie)
	_, _ = h.WriteString(m.CrlFile)
	_, _ = h.WriteString(m.Curves)
	if m.Downinter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Downinter)
	}
	_ = binary.Write(h, binary.LittleEndian, m.ErrorLimit)
	if m.Fall != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Fall)
	}
	if m.Fastinter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Fastinter)
	}
	_, _ = h.WriteString(m.ForceSslv3)
	_, _ = h.WriteString(m.ForceTlsv10)
	_, _ = h.WriteString(m.ForceTlsv11)
	_, _ = h.WriteString(m.ForceTlsv12)
	_, _ = h.WriteString(m.ForceTlsv13)
	_, _ = h.WriteString(m.Fqdn)
	_, _ = h.WriteString(m.GUID)
	_, _ = h.WriteString(m.HashKey)
	_, _ = h.WriteString(m.HealthCheckAddress)
	if m.HealthCheckPort != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.HealthCheckPort)
	}
	if m.ID != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ID)
	}
	if m.IdlePing != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.IdlePing)
	}
	if m.InitAddr != nil {
		_, _ = h.WriteString(*m.InitAddr)
	}
	_, _ = h.WriteString(m.InitState)
	if m.Inter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Inter)
	}
	if m.LogBufsize != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.LogBufsize)
	}
	_, _ = h.WriteString(m.LogProto)
	_, _ = h.WriteString(m.Maintenance)
	if m.MaxReuse != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.MaxReuse)
	}
	if m.Maxconn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Maxconn)
	}
	if m.Maxqueue != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Maxqueue)
	}
	if m.Minconn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Minconn)
	}
	_, _ = h.WriteString(m.Namespace)
	_, _ = h.WriteString(m.NoSslv3)
	_, _ = h.WriteString(m.NoTlsv10)
	_, _ = h.WriteString(m.NoTlsv11)
	_, _ = h.WriteString(m.NoTlsv12)
	_, _ = h.WriteString(m.NoTlsv13)
	_, _ = h.WriteString(m.NoVerifyhost)
	_, _ = h.WriteString(m.Npn)
	_, _ = h.WriteString(m.NumOrRange)
	_, _ = h.WriteString(m.Observe)
	_, _ = h.WriteString(m.OnError)
	_, _ = h.WriteString(m.OnMarkedDown)
	_, _ = h.WriteString(m.OnMarkedUp)
	_, _ = h.WriteString(m.PoolConnName)
	if m.PoolLowConn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolLowConn)
	}
	if m.PoolMaxConn != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolMaxConn)
	}
	if m.PoolPurgeDelay != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.PoolPurgeDelay)
	}
	if m.Port != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Port)
	}
	_, _ = h.WriteString(m.Prefix)
	_, _ = h.WriteString(m.Proto)
	_, _ = h.WriteString(m.Redir)
	_, _ = h.WriteString(m.ResolveNet)
	_, _ = h.WriteString(m.ResolvePrefer)
	_, _ = h.WriteString(m.ResolveOpts)
	_, _ = h.WriteString(m.Resolvers)
	if m.Rise != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Rise)
	}
	_, _ = h.WriteString(m.SendProxy)
	_, _ = h.WriteString(m.SendProxyV2)
	_, _ = h.WriteString(m.SendProxyV2Ssl)
	_, _ = h.WriteString(m.SendProxyV2SslCn)
	_ = binary.Write(h, binary.LittleEndian, m.Shard)
	_, _ = h.WriteString(m.Sigalgs)
	if m.Slowstart != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Slowstart)
	}
	_, _ = h.WriteString(m.Sni)
	_, _ = h.WriteString(m.Socks4)
	_, _ = h.WriteString(m.Source)
	_, _ = h.WriteString(m.Ssl)
	_, _ = h.WriteString(m.SslCafile)
	_, _ = h.WriteString(m.SslCertificate)
	_, _ = h.WriteString(m.SslMaxVer)
	_, _ = h.WriteString(m.SslMinVer)
	_, _ = h.WriteString(m.SslReuse)
	_, _ = h.WriteString(m.Sslv3)
	_, _ = h.WriteString(m.Stick)
	if m.StrictMaxconn {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	if m.TCPUt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TCPUt)
	}
	_, _ = h.WriteString(m.Tfo)
	_, _ = h.WriteString(m.TLSTickets)
	_, _ = h.WriteString(m.Tlsv10)
	_, _ = h.WriteString(m.Tlsv11)
	_, _ = h.WriteString(m.Tlsv12)
	_, _ = h.WriteString(m.Tlsv13)
	_, _ = h.WriteString(m.Track)
	_, _ = h.WriteString(m.Verify)
	_, _ = h.WriteString(m.Verifyhost)
	if m.Weight != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Weight)
	}
	_, _ = h.WriteString(m.Ws)
	return h.Sum64()
}

// ValidateStickRuleV33 validates a stick_rule model.
func ValidateStickRuleV33(m *models.StickRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.Pattern == "" {
		return &ValidationError{Field: "pattern", Message: "required"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.Pattern != "" && !patternNoWhitespace.MatchString(m.Pattern) {
		return &ValidationError{Field: "pattern", Message: "invalid format"}
	}

	if m.Table != "" && !patternNoWhitespace.MatchString(m.Table) {
		return &ValidationError{Field: "table", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "match", "on", "store-request", "store-response":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: match, on, store-request, store-response"}
		}
	}

	return nil
}

// HashStickRuleV33 computes a content hash for cache lookup.
func HashStickRuleV33(m *models.StickRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.Pattern)
	_, _ = h.WriteString(m.Table)
	_, _ = h.WriteString(m.Type)
	return h.Sum64()
}

// ValidateTcpCheckV33 validates a tcp_check model.
func ValidateTcpCheckV33(m *models.TCPCheck) error {
	if m == nil {
		return nil
	}

	if m.Action == "" {
		return &ValidationError{Field: "action", Message: "required"}
	}

	if m.Action != "" {
		switch m.Action {
		case "comment", "connect", "expect", "send", "send-lf", "send-binary", "send-binary-lf", "set-var", "set-var-fmt", "unset-var":
			// valid
		default:
			return &ValidationError{Field: "action", Message: "must be one of: comment, connect, expect, send, send-lf, send-binary, send-binary-lf, set-var, set-var-fmt, unset-var"}
		}
	}

	if m.Addr != "" && !patternNoWhitespace.MatchString(m.Addr) {
		return &ValidationError{Field: "addr", Message: "invalid format"}
	}

	if m.Alpn != "" && !patternNoWhitespace.MatchString(m.Alpn) {
		return &ValidationError{Field: "alpn", Message: "invalid format"}
	}

	if m.ErrorStatus != "" {
		switch m.ErrorStatus {
		case "L7OKC", "L7RSP", "L7STS", "L6RSP", "L4CON":
			// valid
		default:
			return &ValidationError{Field: "error_status", Message: "must be one of: L7OKC, L7RSP, L7STS, L6RSP, L4CON"}
		}
	}

	if m.Match != "" && !patternNoWhitespace.MatchString(m.Match) {
		return &ValidationError{Field: "match", Message: "invalid format"}
	}

	if m.Match != "" {
		switch m.Match {
		case "string", "rstring", "string-lf", "binary", "rbinary", "binary-lf":
			// valid
		default:
			return &ValidationError{Field: "match", Message: "must be one of: string, rstring, string-lf, binary, rbinary, binary-lf"}
		}
	}

	if m.OkStatus != "" {
		switch m.OkStatus {
		case "L7OK", "L7OKC", "L6OK", "L4OK":
			// valid
		default:
			return &ValidationError{Field: "ok_status", Message: "must be one of: L7OK, L7OKC, L6OK, L4OK"}
		}
	}

	if m.Port != nil {
		if *m.Port < 1 || *m.Port > 65535 {
			return &ValidationError{Field: "port", Message: "must be between 1 and 65535"}
		}
	}

	if m.ToutStatus != "" {
		switch m.ToutStatus {
		case "L7TOUT", "L6TOUT", "L4TOUT":
			// valid
		default:
			return &ValidationError{Field: "tout_status", Message: "must be one of: L7TOUT, L6TOUT, L4TOUT"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashTcpCheckV33 computes a content hash for cache lookup.
func HashTcpCheckV33(m *models.TCPCheck) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Action)
	_, _ = h.WriteString(m.Addr)
	_, _ = h.WriteString(m.Alpn)
	_, _ = h.WriteString(m.CheckComment)
	_, _ = h.WriteString(m.Data)
	if m.Default {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.ErrorStatus)
	if m.ExclamationMark {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Fmt)
	_, _ = h.WriteString(m.HexFmt)
	_, _ = h.WriteString(m.HexString)
	if m.Linger {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Match)
	_ = binary.Write(h, binary.LittleEndian, m.MinRecv)
	_, _ = h.WriteString(m.OkStatus)
	_, _ = h.WriteString(m.OnError)
	_, _ = h.WriteString(m.OnSuccess)
	_, _ = h.WriteString(m.Pattern)
	if m.Port != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Port)
	}
	_, _ = h.WriteString(m.PortString)
	_, _ = h.WriteString(m.Proto)
	if m.SendProxy {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.Sni)
	if m.Ssl {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	_, _ = h.WriteString(m.StatusCode)
	_, _ = h.WriteString(m.ToutStatus)
	_, _ = h.WriteString(m.VarExpr)
	_, _ = h.WriteString(m.VarFmt)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	if m.ViaSocks4 {
		_, _ = h.Write([]byte{1})
	} else {
		_, _ = h.Write([]byte{0})
	}
	return h.Sum64()
}

// ValidateTcpRequestRuleV33 validates a tcp_request_rule model.
func ValidateTcpRequestRuleV33(m *models.TCPRequestRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.Action != "" {
		switch m.Action {
		case "accept", "attach-srv", "capture", "do-resolve", "expect-netscaler-cip", "expect-proxy", "lua", "reject", "sc-add-gpc", "sc-inc-gpc", "sc-inc-gpc0", "sc-inc-gpc1", "sc-set-gpt", "sc-set-gpt0", "send-spoe-group", "set-bandwidth-limit", "set-bc-mark", "set-bc-tos", "set-dst-port", "set-dst", "set-fc-mark", "set-fc-tos", "set-log-level", "set-mark", "set-nice", "set-priority-class", "set-priority-offset", "set-src", "set-src-port", "set-tos", "set-var", "set-var-fmt", "silent-drop", "switch-mode", "track-sc", "unset-var", "use-service", "set-retries", "do-log":
			// valid
		default:
			return &ValidationError{Field: "action", Message: "must be one of: accept, attach-srv, capture, do-resolve, expect-netscaler-cip, expect-proxy, lua, reject, sc-add-gpc, sc-inc-gpc, sc-inc-gpc0, sc-inc-gpc1, sc-set-gpt, sc-set-gpt0, send-spoe-group, set-bandwidth-limit, set-bc-mark, set-bc-tos, set-dst-port, set-dst, set-fc-mark, set-fc-tos, set-log-level, set-mark, set-nice, set-priority-class, set-priority-offset, set-src, set-src-port, set-tos, set-var, set-var-fmt, silent-drop, switch-mode, track-sc, unset-var, use-service, set-retries, do-log"}
		}
	}

	if m.CaptureSample != "" && !patternCaptureSample.MatchString(m.CaptureSample) {
		return &ValidationError{Field: "capture_sample", Message: "invalid format"}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.LogLevel != "" {
		switch m.LogLevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "silent":
			// valid
		default:
			return &ValidationError{Field: "log_level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug, silent"}
		}
	}

	if m.LuaAction != "" && !patternNoWhitespace.MatchString(m.LuaAction) {
		return &ValidationError{Field: "lua_action", Message: "invalid format"}
	}

	if m.MarkValue != "" && !pattern_48e2.MatchString(m.MarkValue) {
		return &ValidationError{Field: "mark_value", Message: "invalid format"}
	}

	if m.NiceValue != 0 && (m.NiceValue < -1024 || m.NiceValue > 1024) {
		return &ValidationError{Field: "nice_value", Message: "must be between -1024 and 1024"}
	}

	if m.ResolveProtocol != "" {
		switch m.ResolveProtocol {
		case "ipv4", "ipv6":
			// valid
		default:
			return &ValidationError{Field: "resolve_protocol", Message: "must be one of: ipv4, ipv6"}
		}
	}

	if m.TosValue != "" && !pattern_48e2.MatchString(m.TosValue) {
		return &ValidationError{Field: "tos_value", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "connection", "content", "inspect-delay", "session":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: connection, content, inspect-delay, session"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashTcpRequestRuleV33 computes a content hash for cache lookup.
func HashTcpRequestRuleV33(m *models.TCPRequestRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Action)
	_, _ = h.WriteString(m.BandwidthLimitLimit)
	_, _ = h.WriteString(m.BandwidthLimitName)
	_, _ = h.WriteString(m.BandwidthLimitPeriod)
	_ = binary.Write(h, binary.LittleEndian, m.CaptureLen)
	_, _ = h.WriteString(m.CaptureSample)
	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.Expr)
	_, _ = h.WriteString(m.GptValue)
	_, _ = h.WriteString(m.LogLevel)
	_, _ = h.WriteString(m.LuaAction)
	_, _ = h.WriteString(m.LuaParams)
	_, _ = h.WriteString(m.MarkValue)
	_ = binary.Write(h, binary.LittleEndian, m.NiceValue)
	_, _ = h.WriteString(m.ResolveProtocol)
	_, _ = h.WriteString(m.ResolveResolvers)
	_, _ = h.WriteString(m.ResolveVar)
	_ = binary.Write(h, binary.LittleEndian, m.RstTTL)
	_, _ = h.WriteString(m.ScIdx)
	_, _ = h.WriteString(m.ScIncID)
	if m.ScInt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ScInt)
	}
	_, _ = h.WriteString(m.ServerName)
	_, _ = h.WriteString(m.ServiceName)
	_, _ = h.WriteString(m.SpoeEngineName)
	_, _ = h.WriteString(m.SpoeGroupName)
	_, _ = h.WriteString(m.SwitchModeProto)
	if m.Timeout != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Timeout)
	}
	_, _ = h.WriteString(m.TosValue)
	_, _ = h.WriteString(m.TrackKey)
	if m.TrackStickCounter != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.TrackStickCounter)
	}
	_, _ = h.WriteString(m.TrackTable)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	return h.Sum64()
}

// ValidateTcpResponseRuleV33 validates a tcp_response_rule model.
func ValidateTcpResponseRuleV33(m *models.TCPResponseRule) error {
	if m == nil {
		return nil
	}

	if m.Type == "" {
		return &ValidationError{Field: "type", Message: "required"}
	}

	if m.Action != "" {
		switch m.Action {
		case "accept", "close", "lua", "reject", "sc-add-gpc", "sc-inc-gpc", "sc-inc-gpc0", "sc-inc-gpc1", "sc-set-gpt", "sc-set-gpt0", "send-spoe-group", "set-bandwidth-limit", "set-fc-mark", "set-fc-tos", "set-log-level", "set-mark", "set-nice", "set-tos", "set-var", "set-var-fmt", "silent-drop", "unset-var", "do-log":
			// valid
		default:
			return &ValidationError{Field: "action", Message: "must be one of: accept, close, lua, reject, sc-add-gpc, sc-inc-gpc, sc-inc-gpc0, sc-inc-gpc1, sc-set-gpt, sc-set-gpt0, send-spoe-group, set-bandwidth-limit, set-fc-mark, set-fc-tos, set-log-level, set-mark, set-nice, set-tos, set-var, set-var-fmt, silent-drop, unset-var, do-log"}
		}
	}

	if m.Cond != "" {
		switch m.Cond {
		case "if", "unless":
			// valid
		default:
			return &ValidationError{Field: "cond", Message: "must be one of: if, unless"}
		}
	}

	if m.LogLevel != "" {
		switch m.LogLevel {
		case "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug", "silent":
			// valid
		default:
			return &ValidationError{Field: "log_level", Message: "must be one of: emerg, alert, crit, err, warning, notice, info, debug, silent"}
		}
	}

	if m.LuaAction != "" && !patternNoWhitespace.MatchString(m.LuaAction) {
		return &ValidationError{Field: "lua_action", Message: "invalid format"}
	}

	if m.MarkValue != "" && !pattern_48e2.MatchString(m.MarkValue) {
		return &ValidationError{Field: "mark_value", Message: "invalid format"}
	}

	if m.NiceValue != 0 && (m.NiceValue < -1024 || m.NiceValue > 1024) {
		return &ValidationError{Field: "nice_value", Message: "must be between -1024 and 1024"}
	}

	if m.SpoeEngine != "" && !patternNoWhitespace.MatchString(m.SpoeEngine) {
		return &ValidationError{Field: "spoe_engine", Message: "invalid format"}
	}

	if m.SpoeGroup != "" && !patternNoWhitespace.MatchString(m.SpoeGroup) {
		return &ValidationError{Field: "spoe_group", Message: "invalid format"}
	}

	if m.TosValue != "" && !pattern_48e2.MatchString(m.TosValue) {
		return &ValidationError{Field: "tos_value", Message: "invalid format"}
	}

	if m.Type != "" {
		switch m.Type {
		case "content", "inspect-delay":
			// valid
		default:
			return &ValidationError{Field: "type", Message: "must be one of: content, inspect-delay"}
		}
	}

	if m.VarName != "" && !patternNoWhitespace.MatchString(m.VarName) {
		return &ValidationError{Field: "var_name", Message: "invalid format"}
	}

	if m.VarScope != "" && !patternNoWhitespace.MatchString(m.VarScope) {
		return &ValidationError{Field: "var_scope", Message: "invalid format"}
	}

	return nil
}

// HashTcpResponseRuleV33 computes a content hash for cache lookup.
func HashTcpResponseRuleV33(m *models.TCPResponseRule) uint64 {
	if m == nil {
		return 0
	}

	h := xxhash.New()

	_, _ = h.WriteString(m.Action)
	_, _ = h.WriteString(m.BandwidthLimitLimit)
	_, _ = h.WriteString(m.BandwidthLimitName)
	_, _ = h.WriteString(m.BandwidthLimitPeriod)
	_, _ = h.WriteString(m.Cond)
	_, _ = h.WriteString(m.CondTest)
	_, _ = h.WriteString(m.Expr)
	_, _ = h.WriteString(m.LogLevel)
	_, _ = h.WriteString(m.LuaAction)
	_, _ = h.WriteString(m.LuaParams)
	_, _ = h.WriteString(m.MarkValue)
	_ = binary.Write(h, binary.LittleEndian, m.NiceValue)
	_ = binary.Write(h, binary.LittleEndian, m.RstTTL)
	_, _ = h.WriteString(m.ScExpr)
	_ = binary.Write(h, binary.LittleEndian, m.ScID)
	_ = binary.Write(h, binary.LittleEndian, m.ScIdx)
	if m.ScInt != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.ScInt)
	}
	_, _ = h.WriteString(m.SpoeEngine)
	_, _ = h.WriteString(m.SpoeGroup)
	if m.Timeout != nil {
		_ = binary.Write(h, binary.LittleEndian, *m.Timeout)
	}
	_, _ = h.WriteString(m.TosValue)
	_, _ = h.WriteString(m.Type)
	_, _ = h.WriteString(m.VarFormat)
	_, _ = h.WriteString(m.VarName)
	_, _ = h.WriteString(m.VarScope)
	return h.Sum64()
}
